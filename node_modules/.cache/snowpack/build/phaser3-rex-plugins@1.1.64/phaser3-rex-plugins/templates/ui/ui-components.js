var DeepClone = function (inObject) {
    var outObject;
    var value;
    var key;

    if ((typeof inObject !== 'object') || (inObject === null)) {
        //  inObject is not an object
        return inObject;
    }

    //  Create an array or object to hold the values
    outObject = Array.isArray(inObject) ? [] : {};

    for (key in inObject) {
        value = inObject[key];

        //  Recursively (deep) copy for nested objects, including arrays
        outObject[key] = DeepClone(value);
    }

    return outObject;
};

var SetTexture = function (key, baseFrameName, columns, rows) {
    if (Array.isArray(baseFrameName)) {
        rows = columns;
        columns = baseFrameName;
        baseFrameName = undefined;
    }

    if (baseFrameName === undefined) {
        baseFrameName = '__BASE';
    }

    columns = DeepClone(columns);
    rows = DeepClone(rows);

    this.textureKey = key;
    this.baseFrameName = baseFrameName;
    this.columns.data = columns;
    this.columns.count = (columns) ? columns.length : 0;
    this.columns.stretch = 0;
    this.columns.minWidth = 0;
    this.columns.scale = 1;
    this.rows.data = rows;
    this.rows.count = (rows) ? rows.length : 0;
    this.rows.stretch = 0;
    this.rows.minHeight = 0;
    this.rows.scale = 1;

    var texture = this.scene.textures.get(key);
    if (!texture) {
        this.clear();
        return this;
    }
    if (!columns || !rows) {
        this.clear();
        return this;
    }

    // Get remainder width/height for unknown width/height
    var baseFrame = texture.frames[baseFrameName];
    var remainderTextureWidth = baseFrame.width;
    var unknownColumnWidthCount = 0;
    for (var i = 0, cnt = columns.length; i < cnt; i++) {
        if (columns[i] === undefined) {
            unknownColumnWidthCount++;
        } else if (typeof (columns[i]) === 'number') {
            remainderTextureWidth -= columns[i];
        } else {
            remainderTextureWidth -= columns[i].width;
        }
    }
    var unknownColumnWidth = remainderTextureWidth / unknownColumnWidthCount;

    var remainderTextureHeight = baseFrame.height;
    var unknownRowHeightCount = 0;
    for (var i = 0, cnt = rows.length; i < cnt; i++) {
        if (rows[i] === undefined) {
            unknownRowHeightCount++;
        } else if (typeof (rows[i]) === 'number') {
            remainderTextureHeight -= rows[i];
        } else {
            remainderTextureHeight -= rows[i].width;
        }
    }
    var unknownRowHeight = remainderTextureHeight / unknownRowHeightCount;

    var row, col, rowHeight, colWidth, frameName;
    var offsetX = 0, offsetY = 0;
    for (var j = 0, jcnt = rows.length; j < jcnt; j++) {
        // Unknown height
        if (rows[j] === undefined) {
            rows[j] = unknownRowHeight;
        }

        if (typeof (rows[j]) === 'number') {
            rows[j] = {
                height: rows[j],
                stretch: (j % 2),
            };
        }

        row = rows[j];
        rowHeight = row.height;

        this.rows.stretch += (row.stretch | 0);
        this.rows.minHeight += (row.stretch > 0) ? 0 : rowHeight;

        offsetX = 0;
        for (var i = 0, icnt = columns.length; i < icnt; i++) {
            // Unknown width
            if (columns[i] === undefined) {
                columns[i] = unknownColumnWidth;
            }

            if (typeof (columns[i]) === 'number') {
                columns[i] = {
                    width: columns[i],
                    stretch: (i % 2),
                };
            }

            col = columns[i];
            colWidth = col.width;

            if (j === 0) {
                this.columns.stretch += (col.stretch | 0);
                this.columns.minWidth += (col.stretch > 0) ? 0 : colWidth;
            }

            if ((colWidth >= 1) && (rowHeight >= 1)) {
                frameName = this.getFrameNameCallback(i, j, baseFrameName);
                if (frameName) {
                    texture.add(
                        frameName, 0,
                        (offsetX + baseFrame.cutX), (offsetY + baseFrame.cutY),
                        colWidth, rowHeight
                    );
                    // Do nothing if frameName is existed
                }
            }
            offsetX += colWidth;
        }
        offsetY += rowHeight;
    }

    this.updateTexture();
    return this;
};

var MakeChildImageGameObject = function (parent, key, className) {
    if (className === undefined) {
        className = 'image';
    }
    if (!parent[key]) {
        parent[key] = parent.scene.make[className]({
            add: false,
            origin: { x: 0, y: 0 },
        });
        parent.once('destroy', function () {
            if (parent[key]) {
                parent[key].destroy();
                parent[key] = undefined;
            }
        });
    }
    return parent[key];
};

var UpdateTexture = function () {
    this.clear();

    if (this.textureKey === undefined) {
        return this;
    }
    var texture = this.scene.textures.get(this.textureKey);
    if (!texture) {
        return this;
    }

    var minWidth = this.columns.minWidth * this.maxFixedPartScaleX;  // Fixed-part width
    var minHeight = this.rows.minHeight * this.maxFixedPartScaleY;   // Fixed-part height
    var stretchWidth = this.width - minWidth;
    var stretchHeight = this.height - minHeight;
    var fixedPartScaleX = (stretchWidth >= 0) ? this.maxFixedPartScaleX : (this.width / minWidth);
    var fixedPartScaleY = (stretchHeight >= 0) ? this.maxFixedPartScaleY : (this.height / minHeight);

    if (this.preserveRatio) {
        var minScale = Math.min(fixedPartScaleX, fixedPartScaleY);
        if (fixedPartScaleX > minScale) {
            var compensationWidth = (fixedPartScaleX - minScale) * minWidth;
            if (stretchWidth >= 0) {
                stretchWidth += compensationWidth;
            } else {
                stretchWidth = compensationWidth;
            }
            fixedPartScaleX = minScale;
        }
        if (fixedPartScaleY > minScale) {
            var compensationHeight = (fixedPartScaleY - minScale) * minHeight;
            if (stretchHeight >= 0) {
                stretchHeight += compensationHeight;
            } else {
                stretchHeight = compensationHeight;
            }
            fixedPartScaleY = minScale;
        }
    }
    this.columns.scale = fixedPartScaleX;
    this.rows.scale = fixedPartScaleY;

    var proportionWidth;
    if (stretchWidth > 0) {
        proportionWidth = (this.columns.stretch > 0) ? (stretchWidth / this.columns.stretch) : 0;
    } else {
        proportionWidth = 0;
    }

    var proportionHeight;
    if (stretchHeight > 0) {
        proportionHeight = (this.rows.stretch > 0) ? (stretchHeight / this.rows.stretch) : 0;
    } else {
        proportionHeight = 0;
    }

    var frameName, col, row, colWidth, rowHeight;
    var offsetX = 0, offsetY = 0;
    var gameObject, imageType;
    for (var j = 0, jcnt = this.rows.count; j < jcnt; j++) {
        row = this.rows.data[j];
        rowHeight = (row.stretch === 0) ? (row.height * fixedPartScaleY) : (proportionHeight * row.stretch);

        offsetX = 0;
        for (var i = 0, icnt = this.columns.count; i < icnt; i++) {
            col = this.columns.data[i];
            colWidth = (col.stretch === 0) ? (col.width * fixedPartScaleX) : (proportionWidth * col.stretch);

            frameName = this.getFrameNameCallback(i, j, this.baseFrameName);
            if (frameName && (colWidth > 0) && (rowHeight > 0) && texture.has(frameName)) {
                if ((row.stretch === 0) && (col.stretch === 0)) { // Fixed parts
                    imageType = 0; // Draw image
                } else { // Stretchable parts
                    if (this.getStretchMode(i, j) === 0) { // Scaled image
                        imageType = 0; // Draw scaled image
                    } else { // Repeat tile-sprite
                        imageType = 1; // Draw tile-sprite
                    }
                }

                if (imageType === 0) {
                    gameObject = MakeChildImageGameObject(this, '_image', 'image');
                    gameObject
                        .setTexture(this.textureKey, frameName)
                        .setDisplaySize(colWidth, rowHeight);
                } else {
                    gameObject = MakeChildImageGameObject(this, '_tileSprite', 'tileSprite');
                    gameObject
                        .setTexture(this.textureKey, frameName)
                        .setSize(colWidth, rowHeight);
                }
            }

            if (gameObject) {
                this.draw(gameObject, offsetX, offsetY);
                gameObject = undefined;
            }
            offsetX += colWidth;
        }

        offsetY += rowHeight;
    }
};

const IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
const GetValue = Phaser.Utils.Objects.GetValue;

var SetStretchMode = function(mode) {
    if (IsPlainObject(mode)) {
        this.stretchMode.edge = parseMode(GetValue(mode, 'edge', 0));
        this.stretchMode.internal = parseMode(GetValue(mode, 'internal', 0));
    } else {
        mode = parseMode(mode);
        this.stretchMode.edge = mode;
        this.stretchMode.internal = mode;
    }
    return this;
};

var parseMode = function (mode) {
    if (typeof (mode) === 'string') {
        mode = EXTENDMODE[mode];
    }
    return mode;
};

const EXTENDMODE = {
    scale: 0,
    repeat: 1,
};

var IsEdge = function (colIndex, rowIndex) {
    return (colIndex === 0) || (colIndex === (this.columns.count - 1)) ||
        (rowIndex === 0) || (rowIndex === (this.rows.count - 1));
};

var GetStretchMode = function(colIndex, rowIndex) {
    return (IsEdge.call(this, colIndex, rowIndex)) ? this.stretchMode.edge : this.stretchMode.internal;
};

var SetPreserveRatio = function (enable) {
    if (enable == undefined) {
        enable = true;
    }

    this.preserveRatio = enable;
    return this;
};

var SetMaxFixedPartScale = function (scaleX, scaleY) {
    if (scaleY === undefined) {
        scaleY = scaleX;
    }

    this.maxFixedPartScaleX = scaleX;
    this.maxFixedPartScaleY = scaleY;
    return this;
};

var Methods = {
    setTexture: SetTexture,
    updateTexture: UpdateTexture,
    setStretchMode: SetStretchMode,
    getStretchMode: GetStretchMode,
    setPreserveRatio: SetPreserveRatio,
    setMaxFixedPartScale: SetMaxFixedPartScale,
};

const DefaultBaseFrameName = '__BASE';

var GetFrameNameCallback = function (colIndex, rowIndex, baseFrameName) {
    if (baseFrameName === DefaultBaseFrameName) {
        return `${colIndex},${rowIndex}`;
    } else {
        return `${baseFrameName}_${colIndex},${rowIndex}`;
    }
};

const RenderTexture = Phaser.GameObjects.RenderTexture;
const IsPlainObject$1 = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1 = Phaser.Utils.Objects.GetValue;

class NinePatch extends RenderTexture {
    constructor(scene, x, y, width, height, key, baseFrame, columns, rows, config) {
        if (IsPlainObject$1(x)) {
            config = x;
            x = GetValue$1(config, 'x', 0);
            y = GetValue$1(config, 'y', 0);
            width = GetValue$1(config, 'width', 1);
            height = GetValue$1(config, 'height', 1);
            key = GetValue$1(config, 'key', undefined);
            baseFrame = GetValue$1(config, 'baseFrame', undefined);
            columns = GetValue$1(config, 'columns', undefined);
            rows = GetValue$1(config, 'rows', undefined);
        } else if (IsPlainObject$1(width)) {
            config = width;
            width = GetValue$1(config, 'width', 1);
            height = GetValue$1(config, 'height', 1);
            key = GetValue$1(config, 'key', undefined);
            baseFrame = GetValue$1(config, 'baseFrame', undefined);
            columns = GetValue$1(config, 'columns', undefined);
            rows = GetValue$1(config, 'rows', undefined);
        } else if (IsPlainObject$1(key)) {
            config = key;
            key = GetValue$1(config, 'key', undefined);
            baseFrame = GetValue$1(config, 'baseFrame', undefined);
            columns = GetValue$1(config, 'columns', undefined);
            rows = GetValue$1(config, 'rows', undefined);
        } else if (IsPlainObject$1(baseFrame)) {
            config = baseFrame;
            baseFrame = GetValue$1(config, 'baseFrame', undefined);
            columns = GetValue$1(config, 'columns', undefined);
            rows = GetValue$1(config, 'rows', undefined);
        } else if (Array.isArray(baseFrame)) {
            config = rows;
            rows = columns;
            columns = baseFrame;
            baseFrame = GetValue$1(config, 'baseFrame', undefined);
        } else if (IsPlainObject$1(columns)) {
            config = columns;
            columns = GetValue$1(config, 'columns', undefined);
            rows = GetValue$1(config, 'rows', undefined);
        }

        super(scene, x, y, width, height);
        this.columns = {};
        this.rows = {};
        this.stretchMode = {};
        this._tileSprite = undefined; // Reserved for drawing image
        this._image = undefined; // Reserved for drawing image

        this.setOrigin(0.5, 0.5);
        this.setGetFrameNameCallback(GetValue$1(config, 'getFrameNameCallback', undefined));
        this.setStretchMode(GetValue$1(config, 'stretchMode', 0));
        this.setPreserveRatio(GetValue$1(config, 'preserveRatio', true));

        var maxFixedPartScale = GetValue$1(config, 'maxFixedPartScale', 1);
        var maxFixedPartScaleX = GetValue$1(config, 'maxFixedPartScaleX', maxFixedPartScale);
        var maxFixedPartScaleY = GetValue$1(config, 'maxFixedPartScaleY', undefined);
        this.setMaxFixedPartScale(maxFixedPartScaleX, maxFixedPartScaleY);
        this.setTexture(key, baseFrame, columns, rows); // Also update render texture
    }

    setGetFrameNameCallback(callback) {
        if (callback === undefined) {
            callback = GetFrameNameCallback;
        }
        this.getFrameNameCallback = callback;
        return this;
    }

    get minWidth() {
        return this.columns.minWidth;
    }

    get minHeight() {
        return this.rows.minHeight;
    }

    get fixedPartScaleX() {
        return this.columns.scale;
    }

    get fixedPartScaleY() {
        return this.rows.scale;
    }

    resize(width, height) {
        if ((this.width === width) && (this.height === height)) {
            return this;
        }

        super.resize(width, height);
        this.updateTexture();
        return this;
    }
}

Object.assign(
    NinePatch.prototype,
    Methods
);

const GetValue$2 = Phaser.Utils.Objects.GetValue;

class RoundRectangle {
    constructor(x, y, width, height, radiusConfig) {
        this.cornerRadius = {};
        this._width = 0;
        this._height = 0;
        this.setTo(x, y, width, height, radiusConfig);
    }

    setTo(x, y, width, height, radiusConfig) {
        this.setPosition(x, y);
        this.setRadius(radiusConfig);
        this.setSize(width, height);
        return this;
    }

    setPosition(x, y) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = x;
        }
        this.x = x;
        this.y = y;
        return this;
    }

    setRadius(config) {
        if (config === undefined) {
            config = 0;
        }
        var defaultRadiusX, defaultRadiusY;
        if (typeof (config) === 'number') {
            defaultRadiusX = config;
            defaultRadiusY = config;
        } else {
            defaultRadiusX = GetValue$2(config, 'x', 0);
            defaultRadiusY = GetValue$2(config, 'y', 0);
        }

        var radius = this.cornerRadius;
        radius.tl = GetRadius(GetValue$2(config, 'tl', undefined), defaultRadiusX, defaultRadiusY);
        radius.tr = GetRadius(GetValue$2(config, 'tr', undefined), defaultRadiusX, defaultRadiusY);
        radius.bl = GetRadius(GetValue$2(config, 'bl', undefined), defaultRadiusX, defaultRadiusY);
        radius.br = GetRadius(GetValue$2(config, 'br', undefined), defaultRadiusX, defaultRadiusY);
        return this;
    }

    setSize(width, height) {
        this.width = width;
        this.height = height;
        return this;
    }

    get minWidth() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.x + radius.tr.x, radius.bl.x + radius.br.x);
    }

    get minHeight() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.y + radius.bl.y, radius.tr.y + radius.br.y);
    }

    get width() {
        return this._width;
    }

    set width(value) {
        if (value == null) {
            value = 0;
        }
        this._width = Math.max(value, this.minWidth);
    }

    get height() {
        return this._height;
    }

    set height(value) {
        if (value == null) {
            value = 0;
        }
        this._height = Math.max(value, this.minHeight);
    }

    get radius() {
        var radius = this.cornerRadius;
        var max = Math.max(
            radius.tl.x,
            radius.tl.y,
            radius.tr.x,
            radius.tr.y,
            radius.bl.x,
            radius.bl.y,
            radius.br.x,
            radius.br.y
        );
        return max;
    }
}

var GetRadius = function (radius, defaultRadiusX, defaultRadiusY) {
    if (radius === undefined) {
        return {
            x: defaultRadiusX,
            y: defaultRadiusY
        };
    } else if (typeof (radius) === 'number') {
        return {
            x: radius,
            y: radius
        };
    } else {
        return radius;
    }
};

var LineTo = function (x, y, pathData) {
    var cnt = pathData.length;
    if (cnt >= 2) {
        var lastX = pathData[cnt - 2];
        var lastY = pathData[cnt - 1];
        if ((x === lastX) && (y === lastY)) {
            return pathData;
        }
    }

    pathData.push(x, y);
    return pathData;
};

const DegToRad = Phaser.Math.DegToRad;

var ArcTo = function (centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration, pathData) {
    // startAngle, endAngle: 0 ~ 360
    if (antiClockWise && (endAngle > startAngle)) {
        endAngle -= 360;
    } else if (!antiClockWise && (endAngle < startAngle)) {
        endAngle += 360;
    }

    var deltaAngle = endAngle - startAngle;
    var step = DegToRad(deltaAngle) / iteration;
    startAngle = DegToRad(startAngle);
    for (var i = 0; i <= iteration; i++) {
        var angle = startAngle + (step * i);
        var x = centerX + (radiusX * Math.cos(angle));
        var y = centerY + (radiusY * Math.sin(angle));
        LineTo(x, y, pathData);
    }
    return pathData;
};

/*
src: {
    fillColor, 
    fillAlpha, 
    pathData, 
    pathIndexes  // Earcut(pathData)
}
*/

var Utils = Phaser.Renderer.WebGL.Utils;

var FillPathWebGL = function (pipeline, calcMatrix, src, alpha, dx, dy)
{
    var fillTintColor = Utils.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);

    var path = src.pathData;
    var pathIndexes = src.pathIndexes;

    for (var i = 0; i < pathIndexes.length; i += 3)
    {
        var p0 = pathIndexes[i] * 2;
        var p1 = pathIndexes[i + 1] * 2;
        var p2 = pathIndexes[i + 2] * 2;

        var x0 = path[p0 + 0] - dx;
        var y0 = path[p0 + 1] - dy;
        var x1 = path[p1 + 0] - dx;
        var y1 = path[p1 + 1] - dy;
        var x2 = path[p2 + 0] - dx;
        var y2 = path[p2 + 1] - dy;

        var tx0 = calcMatrix.getX(x0, y0);
        var ty0 = calcMatrix.getY(x0, y0);
        var tx1 = calcMatrix.getX(x1, y1);
        var ty1 = calcMatrix.getY(x1, y1);
        var tx2 = calcMatrix.getX(x2, y2);
        var ty2 = calcMatrix.getY(x2, y2);

        pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
    }
};

/*
src: {
    strokeColor,
    strokeAlpha,
    pathData,
    lineWidth,
    closePath
}
*/
var Utils$1 = Phaser.Renderer.WebGL.Utils;

var StrokePathWebGL = function (pipeline, src, alpha, dx, dy)
{
    var strokeTint = pipeline.strokeTint;
    var strokeTintColor = Utils$1.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);

    strokeTint.TL = strokeTintColor;
    strokeTint.TR = strokeTintColor;
    strokeTint.BL = strokeTintColor;
    strokeTint.BR = strokeTintColor;

    var path = src.pathData;
    var pathLength = path.length - 1;
    var lineWidth = src.lineWidth;
    var halfLineWidth = lineWidth / 2;

    var px1 = path[0] - dx;
    var py1 = path[1] - dy;

    if (!src.closePath)
    {
        pathLength -= 2;
    }

    for (var i = 2; i < pathLength; i += 2)
    {
        var px2 = path[i] - dx;
        var py2 = path[i + 1] - dy;

        pipeline.batchLine(
            px1,
            py1,
            px2,
            py2,
            halfLineWidth,
            halfLineWidth,
            lineWidth,
            i - 2,
            (src.closePath) ? (i === pathLength - 1) : false
        );

        px1 = px2;
        py1 = py2;
    }
};

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */

const TransformMatrix = Phaser.GameObjects.Components.TransformMatrix;

var tempMatrix1 = new TransformMatrix();
var tempMatrix2 = new TransformMatrix();
var tempMatrix3 = new TransformMatrix();

var result = { camera: tempMatrix1, sprite: tempMatrix2, calc: tempMatrix3 };

/**
 * Calculates the Transform Matrix of the given Game Object and Camera, factoring in
 * the parent matrix if provided.
 *
 * Note that the object this results contains _references_ to the Transform Matrices,
 * not new instances of them. Therefore, you should use their values immediately, or
 * copy them to your own matrix, as they will be replaced as soon as another Game
 * Object is rendered.
 *
 * @function Phaser.GameObjects.GetCalcMatrix
 * @memberof Phaser.GameObjects
 * @since 3.50.0
 *
 * @param {Phaser.GameObjects.GameObject} src - The Game Object to calculate the transform matrix for.
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera being used to render the Game Object.
 * @param {Phaser.GameObjects.Components.TransformMatrix} [parentMatrix] - The transform matrix of the parent container, if any.
 *
 * @return {Phaser.Types.GameObjects.GetCalcMatrixResults} The results object containing the updated transform matrices.
 */
var GetCalcMatrix = function (src, camera, parentMatrix) {
    var camMatrix = tempMatrix1;
    var spriteMatrix = tempMatrix2;
    var calcMatrix = tempMatrix3;

    spriteMatrix.applyITRS(src.x, src.y, src.rotation, src.scaleX, src.scaleY);

    camMatrix.copyFrom(camera.matrix);

    if (parentMatrix) {
        //  Multiply the camera by the parent matrix
        camMatrix.multiplyWithOffset(parentMatrix, -camera.scrollX * src.scrollFactorX, -camera.scrollY * src.scrollFactorY);

        //  Undo the camera scroll
        spriteMatrix.e = src.x;
        spriteMatrix.f = src.y;
    }
    else {
        spriteMatrix.e -= camera.scrollX * src.scrollFactorX;
        spriteMatrix.f -= camera.scrollY * src.scrollFactorY;
    }

    //  Multiply by the Sprite matrix, store result in calcMatrix
    camMatrix.multiply(spriteMatrix, calcMatrix);

    return result;
};

var PolygonWebGLRenderer = function (renderer, src, camera, parentMatrix) {
    if (src.dirty) {
        src.updateData();
        src.dirty = false;
    }

    camera.addToRenderList(src);

    var pipeline = renderer.pipelines.set(src.pipeline);

    var result = GetCalcMatrix(src, camera, parentMatrix);

    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

    var dx = src._displayOriginX;
    var dy = src._displayOriginY;

    var alpha = camera.alpha * src.alpha;

    renderer.pipelines.preBatch(src);

    if (src.isFilled) {
        FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
    }

    if (src.isStroked) {
        StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }

    renderer.pipelines.postBatch(src);
};

var FillStyleCanvas = function (ctx, src, altColor, altAlpha)
{
    var fillColor = (altColor) ? altColor : src.fillColor;
    var fillAlpha = (altAlpha) ? altAlpha : src.fillAlpha;

    var red = ((fillColor & 0xFF0000) >>> 16);
    var green = ((fillColor & 0xFF00) >>> 8);
    var blue = (fillColor & 0xFF);

    ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
};

var LineStyleCanvas = function (ctx, src, altColor, altAlpha)
{
    var strokeColor = (altColor) ? altColor : src.strokeColor;
    var strokeAlpha = (altAlpha) ? altAlpha : src.strokeAlpha;

    var red = ((strokeColor & 0xFF0000) >>> 16);
    var green = ((strokeColor & 0xFF00) >>> 8);
    var blue = (strokeColor & 0xFF);

    ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';
    ctx.lineWidth = src.lineWidth;
};

const SetTransform = Phaser.Renderer.Canvas.SetTransform;

var PolygonCanvasRenderer = function (renderer, src, camera, parentMatrix) {
    if (src.dirty) {
        src.updateData();
        src.dirty = false;
    }

    camera.addToRenderList(src);

    var ctx = renderer.currentContext;

    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
        var dx = src._displayOriginX;
        var dy = src._displayOriginY;

        var path = src.pathData;
        var pathLength = path.length - 1;

        var px1 = path[0] - dx;
        var py1 = path[1] - dy;

        ctx.beginPath();

        ctx.moveTo(px1, py1);

        if (!src.closePath) {
            pathLength -= 2;
        }

        for (var i = 2; i < pathLength; i += 2) {
            var px2 = path[i] - dx;
            var py2 = path[i + 1] - dy;

            ctx.lineTo(px2, py2);
        }

        ctx.closePath();

        if (src.isFilled) {
            FillStyleCanvas(ctx, src);

            ctx.fill();
        }

        if (src.isStroked) {
            LineStyleCanvas(ctx, src);

            ctx.stroke();
        }

        //  Restore the context saved in SetTransform
        ctx.restore();
    }
};

var Render = {
    renderWebGL: PolygonWebGLRenderer,
    renderCanvas: PolygonCanvasRenderer

};

const Shape = Phaser.GameObjects.Shape;
const GetValue$3 = Phaser.Utils.Objects.GetValue;
const Earcut = Phaser.Geom.Polygon.Earcut;

class RoundRectangle$1 extends Shape {
    constructor(scene, x, y, width, height, radiusConfig, fillColor, fillAlpha) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }

        var geom = new RoundRectangle();  // Configurate it later
        super(scene, 'rexRoundRectangleShape', geom);

        var radius = GetValue$3(radiusConfig, 'radius', radiusConfig);
        geom.setTo(0, 0, width, height, radius);

        var iteration = GetValue$3(radiusConfig, 'iteration', undefined);
        this.setIteration(iteration);
        this.setPosition(x, y);

        if (fillColor !== undefined) {
            this.setFillStyle(fillColor, fillAlpha);
        }

        this.updateDisplayOrigin();
        this.dirty = true;
    }

    updateData() {
        var geom = this.geom;
        var pathData = this.pathData;

        pathData.length = 0;

        var cornerRadius = geom.cornerRadius,
            radius,
            iteration = this.iteration + 1;
        // bottom-right
        radius = cornerRadius.br;
        if (isArcCorner(radius)) {
            var centerX = geom.width - radius.x;
            var centerY = geom.height - radius.y;
            ArcTo(centerX, centerY, radius.x, radius.y, 0, 90, false, iteration, pathData);
        } else {
            LineTo(geom.width, geom.height, pathData);
        }

        // bottom-left
        radius = cornerRadius.bl;
        if (isArcCorner(radius)) {
            var centerX = radius.x;
            var centerY = geom.height - radius.y;
            ArcTo(centerX, centerY, radius.x, radius.y, 90, 180, false, iteration, pathData);
        } else {
            LineTo(0, geom.height, pathData);
        }

        // top-left
        radius = cornerRadius.tl;
        if (isArcCorner(radius)) {
            var centerX = radius.x;
            var centerY = radius.y;
            ArcTo(centerX, centerY, radius.x, radius.y, 180, 270, false, iteration, pathData);
        } else {
            LineTo(0, 0, pathData);
        }

        // top-right
        radius = cornerRadius.tr;
        if (isArcCorner(radius)) {
            var centerX = geom.width - radius.x;
            var centerY = radius.y;
            ArcTo(centerX, centerY, radius.x, radius.y, 270, 360, false, iteration, pathData);
        } else {
            LineTo(geom.width, 0, pathData);
        }

        pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve
        this.pathIndexes = Earcut(pathData);
        return this;
    }

    get width() {
        return this.geom.width;
    }
    set width(value) {
        this.resize(value, this.height);
    }

    get height() {
        return this.geom.height;
    }
    set height(value) {
        this.resize(this.width, value);
    }

    resize(width, height) {
        if (height === undefined) {
            height = width;
        }
        if ((this.geom.width === width) && (this.geom.height === height)) {
            return this;
        }
        this.geom.height = height;
        this.geom.width = width;
        this.updateDisplayOrigin();
        this.dirty = true;

        var input = this.input;
        if (input && !input.customHitArea) {
            input.hitArea.width = width;
            input.hitArea.height = height;
        }
        return this;
    }

    get iteration() {
        return this._iteration;
    }

    set iteration(value) {
        // Set iteration first time
        if (this._iteration === undefined) {
            this._iteration = value;
            return;
        }

        // Change iteration value
        if (this._iteration === value) {
            return;
        }

        this._iteration = value;
        this.dirty = true;
    }

    setIteration(iteration) {
        if (iteration === undefined) {
            iteration = 6;
        }
        this.iteration = iteration;
        return this;
    }

    get radius() {
        return this.geom.radius;
    }

    set radius(value) {
        this.geom.setRadius(value);
        this.updateDisplayOrigin();
        this.dirty = true;
    }

    setRadius(value) {
        if (value === undefined) {
            value = 0;
        }
        this.radius = value;
        return this;
    }

    get cornerRadius() {
        return this.geom.cornerRadius;
    }

    set cornerRadius(value) {
        this.radius = value;
    }

    setCornerRadius(value) {
        return this.setRadius(value);
    }
}

var isArcCorner = function (radius) {
    return ((radius.x !== 0) && (radius.y !== 0));
};


Object.assign(
    RoundRectangle$1.prototype,
    Render
);

// copy from Phaser.GameObjects.Text

const Utils$2 = Phaser.Renderer.WebGL.Utils;

var WebGLRenderer = function (renderer, src, camera, parentMatrix) {
    if (src.dirty) {
        src.updateTexture();
        src.dirty = false;
    }

    if ((src.width === 0) || (src.height === 0)) {
        return;
    }

    camera.addToRenderList(src);

    var frame = src.frame;
    var width = frame.width;
    var height = frame.height;
    var getTint = Utils$2.getTintAppendFloatAlpha;
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);

    renderer.pipelines.preBatch(src);

    pipeline.batchTexture(
        src,
        frame.glTexture,
        width, height,
        src.x, src.y,
        width / src.resolution, height / src.resolution,
        src.scaleX, src.scaleY,
        src.rotation,
        src.flipX, src.flipY,
        src.scrollFactorX, src.scrollFactorY,
        src.displayOriginX, src.displayOriginY,
        0, 0, width, height,
        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
        getTint(src.tintTopRight, camera.alpha * src._alphaTR),
        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
        src.tintFill,
        0, 0,
        camera,
        parentMatrix,
        false,
        textureUnit
    );

    renderer.pipelines.postBatch(src);
};

// copy from Phaser.GameObjects.Text

var CanvasRenderer = function (renderer, src, camera, parentMatrix) {
    if (src.dirty) {
        src.updateTexture();
        src.dirty = false;
    }

    if ((src.width === 0) || (src.height === 0)) {
        return;
    }

    camera.addToRenderList(src);

    renderer.batchSprite(src, src.frame, camera, parentMatrix);
};

var Render$1 = {
    renderWebGL: WebGLRenderer,
    renderCanvas: CanvasRenderer

};

const Color = Phaser.Display.Color;

var CanvasMethods = {
    clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.dirty = true;
        return this;
    },

    fill(color) {
        this.context.fillStyle = color;
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.dirty = true;
        return this;
    },

    loadFromURL(url, callback) {
        var self = this;
        var img = new Image();
        img.onload = function () {
            if ((self.width !== img.width) || (self.height !== img.height)) {
                self.resize(img.width, img.height);
            } else {
                self.clear();
            }
            self.context.drawImage(img, 0, 0);
            self.updateTexture();

            if (callback) {
                callback();
            }

            img.onload = null;
            img.src = '';
            img.remove();
        };
        img.src = url;
        return this;
    },

    loadFromURLPromise(url) {
        var self = this;
        return new Promise(function (resolve, reject) {
            self.loadFromURL(url, resolve);
        });
    },

    getDataURL(type, encoderOptions) {
        return this.canvas.toDataURL(type, encoderOptions);
    },

    getPixel(x, y, out) {
        if (out === undefined) {
            out = new Color();
        }
        var rgb = this.context.getImageData(x, y, 1, 1);
        out.setTo(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
        return out;
    },

    setPixel(x, y, r, g, b, a) {
        if (typeof (r) !== 'number') {
            var color = r;
            r = color.red;
            g = color.green;
            b = color.blue;
            a = color.alpha;
        }

        if (a === undefined) {
            a = ((r !== 0) || (g !== 0) || (b !== 0)) ? 255 : 0;
        }

        var imgData = this.context.createImageData(1, 1);
        imgData.data[0] = r;
        imgData.data[1] = g;
        imgData.data[2] = b;
        imgData.data[3] = a;
        this.context.putImageData(imgData, x, y);
        this.dirty = true;
        return this;
    }
};

var CopyCanvasToTexture = function (scene, srcCanvas, key, x, y, width, height) {
    var textures = scene.textures;
    var renderer = scene.renderer;

    if (x === undefined) {
        x = 0;
    }
    if (y === undefined) {
        y = 0;
    }
    if (width === undefined) {
        width = srcCanvas.width;
    }
    if (height === undefined) {
        height = srcCanvas.height;
    }

    var texture;
    if (textures.exists(key)) {
        texture = textures.get(key);
    } else {
        texture = textures.createCanvas(key, width, height);
    }

    var destCanvas = texture.getSourceImage();
    if (destCanvas.width !== width) {
        destCanvas.width = width;
    }
    if (destCanvas.height !== height) {
        destCanvas.height = height;
    }

    var destCtx = destCanvas.getContext('2d');
    destCtx.clearRect(0, 0, width, height);
    destCtx.drawImage(srcCanvas, x, y, width, height);
    if (renderer.gl && texture) {
        renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);
    }
};

var TextureMethods = {
    updateTexture(callback, scope) {
        if (callback) {
            if (scope) {
                callback.call(scope, this.canvas, this.context);
            } else {
                callback(this.canvas, this.context);
            }
        }

        if ((this.canvas.width !== this.frame.width) || (this.canvas.height !== this.frame.height)) {
            this.frame.setSize(this.canvas.width, this.canvas.height);
        }
        if (this.renderer.gl) {
            this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, true);
            this.frame.glTexture = this.frame.source.glTexture;
        }
        this.dirty = false;

        var input = this.input;
        if (input && !input.customHitArea) {
            input.hitArea.width = this.width;
            input.hitArea.height = this.height;
        }
        return this;
    },

    generateTexture(key, x, y, width, height) {
        var srcCanvas = this.canvas;
        if (width === undefined) {
            width = srcCanvas.width;
        } else {
            width *= this.resolution;
        }
        if (height === undefined) {
            height = srcCanvas.height;
        } else {
            height *= this.resolution;
        }

        CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);

        return this;
    },

    loadTexture(key, frame) {
        var textureFrame = this.scene.textures.getFrame(key, frame);
        if (!textureFrame) {
            return this;
        }

        if ((this.width !== textureFrame.cutWidth) || (this.height !== textureFrame.cutHeight)) {
            this.resize(textureFrame.cutWidth, textureFrame.cutHeight);
        } else {
            this.clear();
        }
        this.context.drawImage(textureFrame.source.image,
            textureFrame.cutX, textureFrame.cutY, textureFrame.cutWidth, textureFrame.cutHeight,
            0, 0, this.canvas.width, this.canvas.height);
        this.dirty = true;
        return this;
    }

};

const CanvasPool = Phaser.Display.Canvas.CanvasPool;
const GameObject = Phaser.GameObjects.GameObject;

class Canvas extends GameObject {
    constructor(scene, x, y, width, height) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }
        if (width === undefined) {
            width = 1;
        }
        if (height === undefined) {
            height = 1;
        }

        super(scene, 'rexCanvas');

        this.renderer = scene.sys.game.renderer;

        this.resolution = 1;
        this._width = width;
        this._height = height;
        width = Math.max(Math.ceil(width * this.resolution), 1);
        height = Math.max(Math.ceil(height * this.resolution), 1);
        this.canvas = CanvasPool.create(this, width, height);
        this.context = this.canvas.getContext('2d');
        this.dirty = false;

        this.setPosition(x, y);
        this.setOrigin(0.5, 0.5);
        this.initPipeline();

        this._crop = this.resetCropObject();

        //  Create a Texture for this Text object
        this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);

        //  Get the frame
        this.frame = this.texture.get();

        //  Set the resolution
        this.frame.source.resolution = this.resolution;

        if (this.renderer && this.renderer.gl) {
            //  Clear the default 1x1 glTexture, as we override it later
            this.renderer.deleteTexture(this.frame.source.glTexture);
            this.frame.source.glTexture = null;
        }

        this.dirty = true;

        scene.sys.game.events.on('contextrestored', this.onContextRestored, this);
    }

    onContextRestored() {
        this.dirty = true;
    }

    preDestroy() {
        this.scene.sys.game.events.off('contextrestored', this.onContextRestored, this);
        CanvasPool.remove(this.canvas);
        this.texture.destroy();

        this.canvas = null;
        this.context = null;
    }

    get width() {
        return this._width;
    }

    set width(value) {
        this.setSize(value, this._height);
    }

    get height() {
        return this._height;
    }

    set height(value) {
        this.setSize(this._width, value);
    }

    setSize(width, height) {
        if ((this._width === width) && (this._height === height)) {
            return this;
        }

        this._width = width;
        this._height = height;

        this.updateDisplayOrigin();

        width = Math.max(Math.ceil(width * this.resolution), 1);
        height = Math.max(Math.ceil(height * this.resolution), 1);
        this.canvas.width = width;
        this.canvas.height = height;

        this.frame.setSize(width, height);

        this.dirty = true;
        return this;
    }

    get displayWidth() {
        return this.scaleX * this._width;
    }

    set displayWidth(value) {
        this.scaleX = value / this._width;
    }

    get displayHeight() {
        return this.scaleY * this._height;
    }

    set displayHeight(value) {
        this.scaleY = value / this._height;
    }

    setDisplaySize(width, height) {
        this.displayWidth = width;
        this.displayHeight = height;
        return this;
    }

    getCanvas(readOnly) {
        if (!readOnly) {
            this.dirty = true;
        }
        return this.canvas;
    }

    getContext(readOnly) {
        if (!readOnly) {
            this.dirty = true;
        }
        return this.context;
    }

    needRedraw() {
        this.dirty = true;
        return this;
    }

    resize(width, height) {
        this.setSize(width, height);
        return this;
    }
}

const Components = Phaser.GameObjects.Components;
Phaser.Class.mixin(Canvas,
    [
        Components.Alpha,
        Components.BlendMode,
        Components.Crop,
        Components.Depth,
        Components.Flip,
        Components.GetBounds,
        Components.Mask,
        Components.Origin,
        Components.Pipeline,
        Components.ScrollFactor,
        Components.Tint,
        Components.Transform,
        Components.Visible,
        Render$1,
        CanvasMethods,
        TextureMethods,
    ]
);

const Pad = Phaser.Utils.String.Pad;
var GetStyle = function (style, canvas, context) {
    if (style == null) {
        return style;
    }

    switch (typeof (style)) {
        case 'string': return style;
        case 'number': return `#${Pad(Math.floor(style).toString(16), 6, '0', 1)}`;
        case 'function': return style(canvas, context);
        case 'object':
            if (style.hasOwnProperty('r')) {
                if (style.hasOwnProperty('a')) {  // rgba
                    return `rgba(${style.r},${style.g},${style.b},${style.a})`;
                } else {  // rgb
                    return `rgb(${style.r},${style.g},${style.b})`;
                }
            } else if (style.hasOwnProperty('h')) {
                if (style.hasOwnProperty('a')) {  // hsla
                    return `hsla(${style.h},${style.s},${style.l},${style.a})`;
                } else {  // hsl
                    return `hsl(${style.h},${style.s},${style.l})`;
                }
            } else {
                return style; // Not a valid input
            }
        default: return style;
    }
};

const DegToRad$1 = Phaser.Math.DegToRad;
const Rad0 = DegToRad$1(0);
const Rad90 = DegToRad$1(90);
const Rad180 = DegToRad$1(180);
const Rad270 = DegToRad$1(270);

var AddRoundRectanglePath = function (context, x, y, width, height, radiusConfig, iteration) {
    var geom = new RoundRectangle(x, y, width, height, radiusConfig),
        minWidth = geom.minWidth,
        minHeight = geom.minHeight,
        scaleRX = (width >= minWidth) ? 1 : (width / minWidth),
        scaleRY = (height >= minHeight) ? 1 : (height / minHeight);

    var cornerRadius = geom.cornerRadius;
    var radius, radiusX, radiusY, centerX, centerY;

    context.save();
    context.beginPath();

    context.translate(x, y);

    // Bottom-right
    radius = cornerRadius.br;
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    centerX = width - radiusX;
    centerY = height - radiusY;
    context.moveTo(width, centerY);
    if ((radiusX > 0) && (radiusY > 0)) {
        ArcTo$1(context, centerX, centerY, radiusX, radiusY, Rad0, Rad90, iteration);
    } else {
        context.lineTo(width, height);
        context.lineTo(centerX, height);
    }

    // Bottom-left
    radius = cornerRadius.bl;
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    centerX = radiusX;
    centerY = height - radiusY;
    context.lineTo(radiusX, height);
    if ((radiusX > 0) && (radiusY > 0)) {
        ArcTo$1(context, centerX, centerY, radiusX, radiusY, Rad90, Rad180, iteration);
    } else {
        context.lineTo(0, height);
        context.lineTo(0, centerY);
    }

    // Top-left
    radius = cornerRadius.tl;
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    centerX = radiusX;
    centerY = radiusY;
    context.lineTo(0, centerY);
    if ((radiusX > 0) && (radiusY > 0)) {
        ArcTo$1(context, centerX, centerY, radiusX, radiusY, Rad180, Rad270, iteration);
    } else {
        context.lineTo(0, 0);
        context.lineTo(centerX, 0);
    }

    // Top-right
    radius = cornerRadius.tr;
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    centerX = width - radiusX;
    centerY = radiusY;
    context.lineTo(centerX, 0);
    if ((radiusX > 0) && (radiusY > 0)) {
        ArcTo$1(context, centerX, centerY, radiusX, radiusY, Rad270, Rad0, iteration);
    } else {
        context.lineTo(width, 0);
        context.lineTo(width, centerY);
    }

    context.closePath();
    context.restore();
};

var ArcTo$1 = function (context, centerX, centerY, radiusX, radiusY, startAngle, endAngle, iteration) {
    if (iteration == null) {  // undefined, or null
        context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle);
    } else {
        iteration += 1;
        var x, y, angle;
        var step = (endAngle - startAngle) / iteration;
        for (var i = 0; i <= iteration; i++) {
            angle = startAngle + (step * i);
            x = centerX + (radiusX * Math.cos(angle));
            y = centerY + (radiusY * Math.sin(angle));
            context.lineTo(x, y);
        }
    }
};

var DrawRoundRectangle = function (
    canvas, context,
    x, y,
    width, height, radiusConfig,
    fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient,
    iteration
) {

    AddRoundRectanglePath(context, x, y, width, height, radiusConfig, iteration);

    if (fillStyle != null) {
        if (fillColor2 != null) {
            var grd;
            if (isHorizontalGradient) {
                grd = context.createLinearGradient(0, 0, width, 0);
            } else {
                grd = context.createLinearGradient(0, 0, 0, height);
            }
            grd.addColorStop(0, fillStyle);
            grd.addColorStop(1, fillColor2);
            fillStyle = grd;
        }

        context.fillStyle = fillStyle;
        context.fill();
    }

    if ((strokeStyle != null) && (lineWidth > 0)) {
        context.strokeStyle = strokeStyle;
        context.lineWidth = lineWidth;
        context.stroke();
    }
};

var DrawRoundRectangleBackground = function (
    canvasObject,
    color,
    strokeColor, strokeLineWidth,
    radius,
    color2, isHorizontalGradient,
    iteration
) {

    if ((color == null) && (strokeColor == null)) {
        return;
    }

    var width = canvasObject.canvas.width,
        height = canvasObject.canvas.height;

    if (strokeColor == null) {
        strokeLineWidth = 0;
    }
    var x = strokeLineWidth / 2;
    width -= strokeLineWidth;
    height -= strokeLineWidth;
    DrawRoundRectangle(canvasObject.canvas, canvasObject.context,
        x, x,
        width, height,
        radius,
        color,
        strokeColor, strokeLineWidth,
        color2, isHorizontalGradient,
        iteration
    );
};

var DrawContent = function () {
    DrawRoundRectangleBackground(
        this,
        this.fillStyle,
        this.strokeStyle,
        this.lineWidth,
        this.radius,
        this.fillColor2,
        this.isHorizontalGradient,
        this.iteration
    );
};

const GetValue$4 = Phaser.Utils.Objects.GetValue;

class RoundRectangle$2 extends Canvas {
    constructor(scene, x, y, width, height, radiusConfig, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient) {
        super(scene, x, y, width, height);
        this.type = 'rexRoundRectangleCanvas';

        var radius = GetValue$4(radiusConfig, 'radius', radiusConfig);
        var iteration = GetValue$4(radiusConfig, 'iteration', undefined);
        this.setRadius(radius);
        this.setIteration(iteration);
        this.setFillStyle(fillStyle, fillColor2, isHorizontalGradient);
        this.setStrokeStyle(strokeStyle, lineWidth);
    }

    get radius() {
        return this._radius;
    }

    set radius(value) {
        this.dirty |= (this._radius != value);
        this._radius = value;
    }

    setRadius(radius) {
        this.radius = radius;
        return this;
    }

    get iteration() {
        return this._iteration;
    }

    set iteration(value) {
        this.dirty |= (this._iteration != value);
        this._iteration = value;
    }

    setIteration(iteration) {
        this.iteration = iteration;
        return this;
    }

    get fillStyle() {
        return this._fillStyle;
    }

    set fillStyle(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty |= (this._fillStyle != value);
        this._fillStyle = value;
    }

    get fillColor2() {
        return this._fillColor2;
    }

    set fillColor2(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty |= (this._fillColor2 != value);
        this._fillColor2 = value;
    }

    get isHorizontalGradient() {
        return this._fillStyle;
    }

    set isHorizontalGradient(value) {
        this.dirty |= (this._isHorizontalGradient != value);
        this._isHorizontalGradient = value;
    }

    setFillStyle(fillStyle, fillColor2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
            isHorizontalGradient = true;
        }
        this.fillStyle = fillStyle;
        this.fillColor2 = fillColor2;
        this.isHorizontalGradient = isHorizontalGradient;
        return this;
    }

    get strokeStyle() {
        return this._strokeStyle;
    }

    set strokeStyle(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty |= (this._strokeStyle != value);
        this._strokeStyle = value;
    }

    get lineWidth() {
        return this._lineWidth;
    }

    set lineWidth(value) {
        this.dirty |= (this._lineWidth != value);
        this._lineWidth = value;
    }

    setStrokeStyle(strokeStyle, lineWidth) {
        this.strokeStyle = strokeStyle;
        this.lineWidth = lineWidth;
        return this;
    }

    updateTexture() {
        this.clear();
        DrawContent.call(this);
        super.updateTexture();
        return this;
    }
}

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

var Utils$3 = Phaser.Renderer.WebGL.Utils;

/**
 * Renders this Game Object with the WebGL Renderer to the given Camera.
 * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
 * This method should not be called directly. It is a utility function of the Render module.
 *
 * @method Phaser.GameObjects.Text#renderWebGL
 * @since 3.0.0
 * @private
 *
 * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.
 * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.
 * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
 * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
 */
var TextWebGLRenderer = function (renderer, src, camera, parentMatrix) {
    if ((src.width === 0) || (src.height === 0)) {
        return;
    }

    camera.addToRenderList(src);

    var frame = src.frame;
    var width = frame.width;
    var height = frame.height;
    var getTint = Utils$3.getTintAppendFloatAlpha;
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);

    renderer.pipelines.preBatch(src);

    pipeline.batchTexture(
        src,
        frame.glTexture,
        width, height,
        src.x, src.y,
        width / src.style.resolution, height / src.style.resolution,
        src.scaleX, src.scaleY,
        src.rotation,
        src.flipX, src.flipY,
        src.scrollFactorX, src.scrollFactorY,
        src.displayOriginX, src.displayOriginY,
        0, 0, width, height,
        getTint(src.tintTopLeft, camera.alpha * src._alphaTL),
        getTint(src.tintTopRight, camera.alpha * src._alphaTR),
        getTint(src.tintBottomLeft, camera.alpha * src._alphaBL),
        getTint(src.tintBottomRight, camera.alpha * src._alphaBR),
        src.tintFill,
        0, 0,
        camera,
        parentMatrix,
        false,
        textureUnit
    );

    renderer.pipelines.postBatch(src);
};

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

/**
 * Renders this Game Object with the Canvas Renderer to the given Camera.
 * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
 * This method should not be called directly. It is a utility function of the Render module.
 *
 * @method Phaser.GameObjects.Text#renderCanvas
 * @since 3.0.0
 * @private
 *
 * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.
 * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.
 * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
 * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
 * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
 */
var TextCanvasRenderer = function (renderer, src, camera, parentMatrix) {
    if ((src.width === 0) || (src.height === 0)) {
        return;
    }

    camera.addToRenderList(src);

    renderer.batchSprite(src, src.frame, camera, parentMatrix);
};

var Render$2 = {
    renderWebGL: TextWebGLRenderer,
    renderCanvas: TextCanvasRenderer

};

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

const CanvasPool$1 = Phaser.Display.Canvas.CanvasPool;

/**
 * Calculates the ascent, descent and fontSize of a given font style.
 *
 * @function Phaser.GameObjects.MeasureText
 * @since 3.0.0
 *
 * @param {Phaser.GameObjects.Text.TextStyle} textStyle - The TextStyle object to measure.
 *
 * @return {object} An object containing the ascent, descent and fontSize of the TextStyle.
 */
var MeasureText = function (textStyle) {
    // @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
    var canvas = CanvasPool$1.create(this);

    // @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.
    var context = canvas.getContext('2d');

    textStyle.syncFont(canvas, context);

    var metrics = context.measureText(textStyle.testString);

    if ('actualBoundingBoxAscent' in metrics) {
        var ascent = metrics.actualBoundingBoxAscent;
        var descent = metrics.actualBoundingBoxDescent;

        var output = {
            ascent: ascent,
            descent: descent,
            fontSize: (ascent + descent)
        };

        CanvasPool$1.remove(canvas);

        return output;
    }

    var width = Math.ceil(metrics.width * textStyle.baselineX);
    var baseline = width;
    var height = 2 * baseline;

    baseline = baseline * textStyle.baselineY | 0;

    canvas.width = width;
    canvas.height = height;

    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);

    context.font = textStyle._font;

    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(textStyle.testString, 0, baseline);

    var output = {
        ascent: 0,
        descent: 0,
        fontSize: 0
    };

    if (!context.getImageData(0, 0, width, height)) {
        output.ascent = baseline;
        output.descent = baseline + 6;
        output.fontSize = output.ascent + output.descent;

        CanvasPool$1.remove(canvas);

        return output;
    }

    var imagedata = context.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i;
    var j;
    var idx = 0;
    var stop = false;

    // ascent. scan from top to bottom until we find a non red pixel
    for (i = 0; i < baseline; i++) {
        for (j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
                stop = true;
                break;
            }
        }

        if (!stop) {
            idx += line;
        }
        else {
            break;
        }
    }

    output.ascent = baseline - i;

    idx = pixels - line;
    stop = false;

    // descent. scan from bottom to top until we find a non red pixel
    for (i = height; i > baseline; i--) {
        for (j = 0; j < line; j += 4) {
            if (imagedata[idx + j] !== 255) {
                stop = true;
                break;
            }
        }

        if (!stop) {
            idx -= line;
        }
        else {
            break;
        }
    }

    output.descent = (i - baseline);
    output.fontSize = output.ascent + output.descent;

    CanvasPool$1.remove(canvas);

    return output;
};

var CONST = {
    // new line mode
    NO_NEWLINE: 0,
    RAW_NEWLINE: 1,
    WRAPPED_NEWLINE: 2,

    // wrap mode
    NO_WRAP: 0,
    WORD_WRAP: 1,
    CHAR_WRAP: 2,

    // split lines
    SPLITREGEXP: /(?:\r\n|\r|\n)/
};

const GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
const GetValue$5 = Phaser.Utils.Objects.GetValue;

//  Key: [ Object Key, Default Value, postCallback ]

var propertyMap = {
    // background
    backgroundColor: ['backgroundColor', null, GetStyle],
    backgroundColor2: ['backgroundColor2', null, GetStyle],
    backgroundHorizontalGradient: ['backgroundHorizontalGradient', true, null],
    backgroundStrokeColor: ['backgroundStrokeColor', null, GetStyle],
    backgroundStrokeLineWidth: ['backgroundStrokeLineWidth', 2, null],
    backgroundCornerRadius: ['backgroundCornerRadius', 0, null],
    backgroundCornerIteration: ['backgroundCornerIteration', null, null],

    // font
    fontFamily: ['fontFamily', 'Courier', null],
    fontSize: ['fontSize', '16px', null],
    fontStyle: ['fontStyle', '', null],
    color: ['color', '#fff', GetStyle],
    stroke: ['stroke', '#fff', GetStyle],
    strokeThickness: ['strokeThickness', 0, null],
    shadowOffsetX: ['shadow.offsetX', 0, null],
    shadowOffsetY: ['shadow.offsetY', 0, null],
    shadowColor: ['shadow.color', '#000', GetStyle],
    shadowBlur: ['shadow.blur', 0, null],
    shadowStroke: ['shadow.stroke', false, null],
    shadowFill: ['shadow.fill', false, null],

    // underline
    underlineColor: ['underline.color', '#000', GetStyle],
    underlineThickness: ['underline.thickness', 0, null],
    underlineOffset: ['underline.offset', 0, null],

    // align
    halign: ['halign', 'left', null],
    valign: ['valign', 'top', null],

    // size
    maxLines: ['maxLines', 0, null],
    fixedWidth: ['fixedWidth', 0, null],
    fixedHeight: ['fixedHeight', 0, null],
    resolution: ['resolution', 0, null],
    lineSpacing: ['lineSpacing', 0, null],
    xOffset: ['xOffset', 0, null],

    rtl: ['rtl', false, null],
    testString: ['testString', '|MÃ‰qgy', null],
    baselineX: ['baselineX', 1.2, null],
    baselineY: ['baselineY', 1.4, null],

    // wrap
    wrapMode: ['wrap.mode', 0, null],
    wrapWidth: ['wrap.width', 0, null],
    wrapCallback: ['wrap.callback', null],
    wrapCallbackScope: ['wrap.callbackScope', null],
};

class TextStyle {
    constructor(text, style) {
        this.parent = text;

        this.backgroundColor;
        this.backgroundColor2;
        this.backgroundHorizontalGradient;
        this.backgroundStrokeColor;
        this.backgroundStrokeLineWidth;
        this.backgroundCornerRadius;
        this.backgroundCornerIteration;

        this.fontFamily;
        this.fontSize;
        this.fontStyle;
        this.color;
        this.stroke;
        this.strokeThickness;
        this.shadowOffsetX;
        this.shadowOffsetY;
        this.shadowColor;
        this.shadowBlur;
        this.shadowStroke;
        this.shadowFill;

        this.underlineColor;
        this.underlineThickness;
        this.underlineOffset;

        this.halign;
        this.valign;

        this.maxLines;
        this.fixedWidth;
        this.fixedHeight;
        this.resolution;
        this.lineSpacing;
        this.xOffset;

        this.rtl;
        this.testString;

        this.baselineX;
        this.baselineY;

        this.wrapMode;
        this.wrapWidth;
        this.wrapCallback;
        this.wrapCallbackScope;

        this._font;

        //  Set to defaults + user style
        this.setStyle(style, false, true);

        var metrics = GetValue$5(style, 'metrics', false);

        //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning
        //  Doing this is reset if you then change the font of this TextStyle after creation
        if (metrics) {
            this.metrics = {
                ascent: GetValue$5(metrics, 'ascent', 0),
                descent: GetValue$5(metrics, 'descent', 0),
                fontSize: GetValue$5(metrics, 'fontSize', 0)
            };
        } else {
            this.metrics = MeasureText(this);
        }
    }

    get canvas() {
        return this.parent.canvasText.canvas;
    }

    get context() {
        return this.parent.canvasText.context;
    }

    get isWrapFitMode() {
        return (this.fixedWidth > 0) && (this.wrapMode !== CONST.NO_WRAP) && (this.wrapWidth === 0);
    }

    setStyle(style, updateText, setDefaults) {
        if (updateText === undefined) {
            updateText = true;
        }
        if (setDefaults === undefined) {
            setDefaults = false;
        }

        if (style && style.hasOwnProperty('wrap')) {
            var wrap = style.wrap;
            if (wrap.hasOwnProperty('mode')) {
                var mode = wrap.mode;
                if (typeof mode === 'string') {
                    wrap.mode = WRAPMODE[mode];
                }
            } else {
                if (wrap.hasOwnProperty('width')) {
                    wrap.mode = 1;
                }
            }
        }

        // default halign of RTL is 'right'
        if (style && style.rtl && setDefaults && (!style.hasOwnProperty('halign'))) {
            style.halign = 'right';
        }

        //  Avoid type mutation
        if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number') {
            style.fontSize = style.fontSize.toString() + 'px';
        }

        for (var key in propertyMap) {
            var prop = propertyMap[key];  // [ Object Key, Default Value, preCallback ]
            var objKey = prop[0];
            var defaultValue = (setDefaults) ? prop[1] : this[key];
            var postCallback = prop[2];


            if (key === 'wrapCallback' || key === 'wrapCallbackScope') {
                // Callback & scope should be set without processing the values
                this[key] = GetValue$5(style, objKey, defaultValue);
            } else {
                var value = GetAdvancedValue(style, objKey, defaultValue);
                if (postCallback) {
                    value = postCallback(value);
                }
                this[key] = value;
            }

        }

        //  Allow for 'font' override
        var font = GetValue$5(style, 'font', null);

        if (font === null) {
            this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;
        } else {
            this._font = font;
        }

        //  Allow for 'fill' to be used in place of 'color'
        var fill = GetValue$5(style, 'fill', null);

        if (fill !== null) {
            this.color = GetStyle(fill);
        }

        var imageData = GetValue$5(style, 'images', undefined);
        if (imageData) {
            this.parent.addImage(imageData);
        }

        if (updateText) {
            return this.update(true);
        } else {
            return this.parent;
        }
    }

    syncFont(canvas, context) {
        context.font = this._font;
    }

    syncStyle(canvas, context) {
        context.textBaseline = 'alphabetic';

        context.fillStyle = this.color;
        context.strokeStyle = this.stroke;

        context.lineWidth = this.strokeThickness;
        context.lineCap = 'round';
        context.lineJoin = 'round';
    }

    syncShadow(context, enabled) {
        if (enabled) {
            context.shadowOffsetX = this.shadowOffsetX;
            context.shadowOffsetY = this.shadowOffsetY;
            context.shadowColor = this.shadowColor;
            context.shadowBlur = this.shadowBlur;
        } else {
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.shadowColor = 0;
            context.shadowBlur = 0;
        }
    }

    update(recalculateMetrics) {
        if (recalculateMetrics) {
            this._font = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();

            this.metrics = MeasureText(this);
        }

        return this.parent.updateText(recalculateMetrics);
    }

    buildFont() {
        var newFont = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`.trim();
        if (newFont !== this._font) {
            this._font = newFont;
            //this.metrics = MeasureText(this);
        }
        return this;
    }

    setFont(font) {
        if (typeof font === 'string') {
            this.fontFamily = font;
            this.fontSize = '';
            this.fontStyle = '';
        } else {
            this.fontFamily = GetValue$5(font, 'fontFamily', 'Courier');
            this.fontSize = GetValue$5(font, 'fontSize', '16px');
            this.fontStyle = GetValue$5(font, 'fontStyle', '');
        }

        return this.update(true);
    }

    setFontFamily(family) {
        this.fontFamily = family;

        return this.update(true);
    }

    setFontStyle(style) {
        this.fontStyle = style;

        return this.update(true);
    }

    setFontSize(size) {
        if (typeof size === 'number') {
            size = size.toString() + 'px';
        }

        this.fontSize = size;

        return this.update(true);
    }

    setTestString(string) {
        this.testString = string;

        return this.update(true);
    }

    setFixedSize(width, height) {
        this.fixedWidth = width;
        this.fixedHeight = height;

        if (width) {
            this.parent.width = width;
        }

        if (height) {
            this.parent.height = height;
        }

        return this.update(this.isWrapFitMode);
    }

    setResolution(value) {
        this.resolution = value;

        return this.update(false);
    }

    setLineSpacing(value) {
        this.lineSpacing = value;

        return this.update(false);
    }

    setXOffset(value) {
        this.xOffset = value;

        return this.update(false);
    }

    setBackgroundColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
            isHorizontalGradient = true;
        }

        this.backgroundColor = GetStyle(color, this.canvas, this.context);
        this.backgroundColor2 = GetStyle(color2, this.canvas, this.context);
        this.backgroundHorizontalGradient = isHorizontalGradient;

        return this.update(false);
    }

    setBackgroundStrokeColor(color, lineWidth) {
        this.backgroundStrokeColor = GetStyle(color, this.canvas, this.context);
        this.backgroundStrokeLineWidth = lineWidth;

        return this.update(false);
    }

    setBackgroundCornerRadius(radius, iteration) {
        this.backgroundCornerRadius = radius;
        this.backgroundCornerIteration = iteration;

        return this.update(false);
    }

    setFill(color) {
        this.color = GetStyle(color, this.canvas, this.context);

        return this.update(false);
    }

    setColor(color) {
        this.color = GetStyle(color, this.canvas, this.context);

        return this.update(false);
    }

    setStroke(color, thickness) {
        if (color === undefined) {
            //  Reset the stroke to zero (disabling it)
            this.strokeThickness = 0;
        } else {
            if (thickness === undefined) {
                thickness = this.strokeThickness;
            }

            this.stroke = GetStyle(color, this.canvas, this.context);
            this.strokeThickness = thickness;
        }

        return this.update(true);
    }

    setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }
        if (color === undefined) {
            color = '#000';
        }
        if (blur === undefined) {
            blur = 0;
        }
        if (shadowStroke === undefined) {
            shadowStroke = false;
        }
        if (shadowFill === undefined) {
            shadowFill = true;
        }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;
        this.shadowColor = GetStyle(color, this.canvas, this.context);
        this.shadowBlur = blur;
        this.shadowStroke = shadowStroke;
        this.shadowFill = shadowFill;

        return this.update(false);
    }

    setShadowOffset(x, y) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = x;
        }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;

        return this.update(false);
    }

    setShadowColor(color) {
        if (color === undefined) {
            color = '#000';
        }

        this.shadowColor = GetStyle(color, this.canvas, this.context);

        return this.update(false);
    }

    setShadowBlur(blur) {
        if (blur === undefined) {
            blur = 0;
        }

        this.shadowBlur = blur;

        return this.update(false);
    }

    setShadowStroke(enabled) {
        this.shadowStroke = enabled;

        return this.update(false);
    }

    setShadowFill(enabled) {
        this.shadowFill = enabled;

        return this.update(false);
    }

    setUnderline(color, thickness, offset) {
        if (color === undefined) {
            color = '#000';
        }
        if (thickness === undefined) {
            thickness = 0;
        }
        if (offset === undefined) {
            offset = 0;
        }

        this.underlineColor = GetStyle(color, this.canvas, this.context);
        this.underlineThickness = thickness;
        this.underlineOffset = offset;

        return this.update(false);
    }

    setUnderlineColor(color) {
        if (color === undefined) {
            color = '#000';
        }

        this.underlineColor = GetStyle(color, this.canvas, this.context);
        return this.update(false);
    }

    setUnderlineThickness(thickness) {
        if (thickness === undefined) {
            thickness = 0;
        }

        this.underlineThickness = thickness;
        return this.update(false);
    }

    setUnderlineOffset(offset) {
        if (offset === undefined) {
            offset = 0;
        }

        this.underlineOffset = offset;
        return this.update(false);
    }

    setWrapMode(mode) {
        if (typeof mode === 'string') {
            mode = WRAPMODE[mode.toLowerCase()] || 0;
        }
        this.wrapMode = mode;
        return this.update(true);
    }

    setWrapWidth(width) {
        this.wrapWidth = width;
        return this.update(false);
    }

    setAlign(halign, valign) {
        if (halign === undefined) {
            halign = 'left';
        }
        if (valign === undefined) {
            valign = 'top';
        }
        this.halign = halign;
        this.valign = valign;

        return this.update(false);
    }

    setHAlign(halign) {
        if (halign === undefined) {
            halign = 'left';
        }
        this.halign = halign;

        return this.update(false);
    }

    setVAlign(valign) {
        if (valign === undefined) {
            valign = 'top';
        }
        this.valign = valign;

        return this.update(false);
    }

    setMaxLines(max) {
        if (max === undefined) {
            max = 0;
        }

        this.maxLines = max;

        return this.update(false);
    }

    getTextMetrics() {
        var metrics = this.metrics;

        return {
            ascent: metrics.ascent,
            descent: metrics.descent,
            fontSize: metrics.fontSize
        };
    }

    setTextMetrics(metrics, font) {
        this.metrics.ascent = metrics.ascent;
        this.metrics.descent = metrics.descent;
        this.metrics.fontSize = metrics.fontSize;

        if (typeof font === 'string') {
            this.fontFamily = font;
            this.fontSize = '';
            this.fontStyle = '';
        } else {
            this.fontFamily = GetValue$5(font, 'fontFamily', this.fontFamily);
            this.fontSize = GetValue$5(font, 'fontSize', this.fontSize);
            this.fontStyle = GetValue$5(font, 'fontStyle', this.fontStyle);
        }
        return this.parent.updateText(true);
    }

    get lineHeight() {
        return this.metrics.fontSize + this.strokeThickness + this.lineSpacing;
    }

    toJSON() {
        var output = {};

        for (var key in propertyMap) {
            output[key] = this[key];
        }

        output.metrics = this.getTextMetrics();

        return output;
    }

    destroy() {
        this.parent = undefined;
    }

}
const WRAPMODE = {
    none: CONST.NO_WRAP,
    word: CONST.WORD_WRAP,
    char: CONST.CHAR_WRAP,
    character: CONST.CHAR_WRAP
};

const CanvasPool$2 = Phaser.Display.Canvas.CanvasPool;

var MeasureTextMargins = function (textStyle, testString, out) {
    if (out === undefined) {
        out = {};
    }

    var canvas = CanvasPool$2.create(this);
    var context = canvas.getContext('2d');

    textStyle.syncFont(canvas, context);

    var metrics = context.measureText(testString);

    var width = Math.ceil(metrics.width * textStyle.baselineX);
    var baseline = width;
    var height = 2 * baseline;

    baseline = baseline * textStyle.baselineY | 0;

    canvas.width = width;
    canvas.height = height;

    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);

    context.font = textStyle._font;

    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(textStyle.testString, 0, baseline);

    out.left = 0;

    if ((width === 0) || (height === 0) || !context.getImageData(0, 0, width, height)) {
        CanvasPool$2.remove(canvas);
        return out;
    }

    var imagedata = context.getImageData(0, 0, width, height).data;
    var stop = false;
    for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
            var idx = (y * width + x) * 4;
            if (imagedata[idx] !== 255) {
                out.left = x;
                stop = true;
                break;
            }
        }
        if (stop) {
            break;
        }
    }

    CanvasPool$2.remove(canvas);
    return out;
};

var DrawMethods = {
    draw(startX, startY, textWidth, textHeight) {
        var penManager = this.penManager;
        this.hitAreaManager.clear();

        var context = this.context;
        context.save();

        var defaultStyle = this.defaultStyle;

        this.clear();
        DrawRoundRectangleBackground(
            this,
            defaultStyle.backgroundColor,
            defaultStyle.backgroundStrokeColor,
            defaultStyle.backgroundStrokeLineWidth,
            defaultStyle.backgroundCornerRadius,
            defaultStyle.backgroundColor2,
            defaultStyle.backgroundHorizontalGradient,
            defaultStyle.backgroundCornerIteration
        );

        // draw lines
        startX += this.startXOffset;
        startY += this.startYOffset;
        var defaultHalign = defaultStyle.halign,
            valign = defaultStyle.valign;

        var lineWidth, lineHeight = defaultStyle.lineHeight;
        var lines = penManager.lines;
        var totalLinesNum = lines.length,
            maxLines = defaultStyle.maxLines;
        var drawLinesNum, drawLineStartIdx, drawLineEndIdx;
        if ((maxLines > 0) && (totalLinesNum > maxLines)) {
            drawLinesNum = maxLines;
            if (valign === 'center') { // center
                drawLineStartIdx = Math.floor((totalLinesNum - drawLinesNum) / 2);
            } else if (valign === 'bottom') { // bottom
                drawLineStartIdx = totalLinesNum - drawLinesNum;
            } else {
                drawLineStartIdx = 0;
            }
        } else {
            drawLinesNum = totalLinesNum;
            drawLineStartIdx = 0;
        }
        drawLineEndIdx = drawLineStartIdx + drawLinesNum;

        var offsetX, offsetY;
        var rtl = this.rtl,
            rtlOffset = (rtl) ? this.parent.width : undefined;
        if (valign === 'center') { // center
            offsetY = Math.max((textHeight - (drawLinesNum * lineHeight)) / 2, 0);
        } else if (valign === 'bottom') { // bottom
            offsetY = Math.max(textHeight - (drawLinesNum * lineHeight) - 2, 0);
        } else {
            offsetY = 0;
        }
        offsetY += startY;
        for (var lineIdx = drawLineStartIdx; lineIdx < drawLineEndIdx; lineIdx++) {
            lineWidth = penManager.getLineWidth(lineIdx);
            if (lineWidth === 0) {
                continue;
            }

            var pens = lines[lineIdx],
                penCount = pens.length;
            var halign = defaultHalign;
            // Seek if there has algin tag
            for (var penIdx = 0; penIdx < penCount; penIdx++) {
                var penAlign = pens[penIdx].prop.align;
                if (penAlign) {
                    halign = penAlign;
                    break;
                }
            }

            if (halign === 'center') { // center
                offsetX = (textWidth - lineWidth) / 2;
            } else if (halign === 'right') { // right
                offsetX = (!rtl) ? (textWidth - lineWidth) : 0;
            } else {
                offsetX = (!rtl) ? 0 : (textWidth - lineWidth);
            }
            offsetX += startX;

            for (var penIdx = 0; penIdx < penCount; penIdx++) {
                this.drawPen(pens[penIdx], offsetX, offsetY, rtlOffset);
            }
        }

        context.restore();
    },

    drawPen(pen, offsetX, offsetY, rtlOffset) {
        offsetX += pen.x;
        offsetY += pen.y + (pen.prop.y || 0);

        if (rtlOffset !== undefined) {
            offsetX = rtlOffset - offsetX;
        }

        var canvas = this.canvas;
        var context = this.context;
        context.save();

        var curStyle = this.parser.propToContextStyle(
            this.defaultStyle,
            pen.prop
        );
        curStyle.buildFont();
        curStyle.syncFont(canvas, context);
        curStyle.syncStyle(canvas, context);

        // Underline
        if ((curStyle.underlineThickness > 0) && (pen.width > 0)) {
            this.drawUnderline(offsetX, offsetY, pen.width, curStyle);
        }

        // Text
        if (pen.isTextPen) {
            this.drawText(offsetX, offsetY, pen.text, curStyle);
        }

        // Image
        if (pen.isImagePen) {
            this.drawImage(offsetX, offsetY, pen.prop.img, curStyle);
        }

        context.restore();

        if (pen.hasAreaMarker && (pen.width > 0)) {
            this.hitAreaManager.add(
                pen.prop.area, // key
                offsetX, // x
                (offsetY - this.startYOffset), // y
                pen.width, // width
                this.defaultStyle.lineHeight // height
            );
        }
    },

    clear() {
        var canvas = this.canvas;
        this.context.clearRect(0, 0, canvas.width, canvas.height);
    },

    drawUnderline(x, y, width, style) {
        y += style.underlineOffset - (style.underlineThickness / 2);
        if (this.autoRound) {
            x = Math.round(x);
            y = Math.round(y);
        }

        var context = this.context;
        var savedLineCap = context.lineCap;
        context.lineCap = 'butt';
        context.strokeStyle = style.underlineColor;
        context.lineWidth = style.underlineThickness;
        context.beginPath();
        context.moveTo(x, y);
        context.lineTo((x + width), y);
        context.stroke();
        context.lineCap = savedLineCap;
    },

    drawText(x, y, text, style) {
        if (this.autoRound) {
            x = Math.round(x);
            y = Math.round(y);
        }

        var context = this.context;
        if (style.stroke && (style.stroke !== 'none') && (style.strokeThickness > 0)) {
            style.syncShadow(context, style.shadowStroke);
            context.strokeText(text, x, y);
        }

        if (style.color && (style.color !== 'none')) {
            style.syncShadow(context, style.shadowFill);
            context.fillText(text, x, y);
        }
    },

    drawImage(x, y, imgKey, style) {
        y -= this.startYOffset;
        this.parent.imageManager.draw(imgKey, this.context, x, y, this.autoRound);
    }

};

class Stack {
    constructor() {
        this.items = [];
    }

    destroy() {
        this.clear();
        this.items = undefined;
    }

    pop() {
        return (this.items.length > 0) ? this.items.pop() : null;
    }

    push(l) {
        this.items.push(l);
        return this;
    }

    pushMultiple(arr) {
        this.items.push.apply(this.items, arr);
        arr.length = 0;
        return this;
    }

    clear() {
        this.items.length = 0;
        return this;
    }
}

const GetValue$6 = Phaser.Utils.Objects.GetValue;
const NO_NEWLINE = CONST.NO_NEWLINE;
const RAW_NEWLINE = CONST.RAW_NEWLINE;

class Pen {
    constructor(config) {
        this.prop = {};
        this.resetFromJSON(config);
    }

    resetFromJSON(o) { // (txt, x, y, width, prop, newLineMode, startIndex)
        this.text = GetValue$6(o, 'text', '');
        this.x = GetValue$6(o, 'x', 0);
        this.y = GetValue$6(o, 'y', 0);
        this.width = GetValue$6(o, 'width', 0);

        var prop = GetValue$6(o, 'prop', null);
        if (prop === null) {
            prop = {};
        }
        this.prop = prop;
        this.newLineMode = GetValue$6(o, 'newLineMode', 0);
        this.startIndex = GetValue$6(o, 'startIndex', 0);
    }

    get plainText() {
        var txt = this.text;
        if (this.newLineMode === RAW_NEWLINE) {
            txt += "\n";
        }

        return txt;
    }

    get wrapText() {
        var txt = this.text;
        if (this.newLineMode !== NO_NEWLINE) {
            txt += "\n";
        }

        return txt;
    }

    get rawTextLength() {
        var len = this.text.length;
        if (this.newLineMode === RAW_NEWLINE) {
            len += 1;
        }
        return len;
    }

    get endIndex() {
        return this.startIndex + this.rawTextLength;
    }

    get lastX() {
        return this.x + this.width;
    }

    get isTextPen() {
        return (this.text !== '');
    }

    get isImagePen() {
        return !!this.prop.img;
    }

    get hasAreaMarker() {
        return !!this.prop.area;
    }
}

var Clear = function (obj) {
    if (Array.isArray(obj)) {
        obj.length = 0;
    } else {
        for (var key in obj) {
            delete obj[key];
        }
    }
};

/**
 * Shallow Object Clone. Will not out nested objects.
 * @param {object} obj JSON object
 * @param {object} ret JSON object to return, set null to return a new object
 * @returns {object} this object
 */
var Clone = function (obj, out) {
    var objIsArray = Array.isArray(obj);

    if (out === undefined) {
        out = (objIsArray) ? [] : {};
    } else {
        Clear(out);
    }

    if (objIsArray) {
        out.length = obj.length;
        for (var i = 0, cnt = obj.length; i < cnt; i++) {
            out[i] = obj[i];
        }
    } else {
        for (var key in obj) {
            out[key] = obj[key];
        }
    }

    return out;
};

var NOOP = function () {
    //  NOOP
};

const GetFastValue = Phaser.Utils.Objects.GetFastValue;
const NO_NEWLINE$1 = CONST.NO_NEWLINE;
const WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;

var PensPool = new Stack(); // default pens pool
var LinesPool = new Stack(); // default lines pool
class PenManager {
    constructor(config) {
        this.pens = []; // all pens
        this.lines = []; // pens in lines [ [],[],[],.. ]
        this.maxLinesWidth = undefined;

        this.PensPool = GetFastValue(config, 'pensPool', PensPool);
        this.LinesPool = GetFastValue(config, 'linesPool', LinesPool);
        this.tagToText = GetFastValue(config, 'tagToText', NOOP);
        this.tagToTextScope = GetFastValue(config, 'tagToTextScope', undefined);
    }

    destroy() {
        this.clear();
        this.tagToText = undefined;
        this.tagToTextScope = undefined;
    }

    clear() {
        for (var i = 0, len = this.lines.length; i < len; i++) {
            this.lines[i].length = 0;
        }

        this.PensPool.pushMultiple(this.pens);
        this.LinesPool.pushMultiple(this.lines);
        this.maxLinesWidth = undefined;
    }

    addTextPen(text, x, y, width, prop, newLineMode) {
        var pen = this.PensPool.pop();
        if (pen == null) {
            pen = new Pen();
        }
        PEN_CONFIG.text = text;
        PEN_CONFIG.x = x;
        PEN_CONFIG.y = y;
        PEN_CONFIG.width = width;
        PEN_CONFIG.prop = prop;
        PEN_CONFIG.newLineMode = newLineMode;
        pen.resetFromJSON(PEN_CONFIG);
        this.addPen(pen);
        return this;
    }

    addImagePen(x, y, width, prop) {
        this.addTextPen('', x, y, width, prop, NO_NEWLINE$1);
        return this;
    }

    addNewLinePen() {
        var previousPen = this.lastPen;
        var x = (previousPen) ? previousPen.lastX : 0;
        var y = (previousPen) ? previousPen.y : 0;
        var prop = (previousPen) ? Clone(previousPen.prop) : null;
        this.addTextPen('', x, y, 0, prop, WRAPPED_NEWLINE);
        return this;
    }

    addPen(pen) {
        var previousPen = this.lastPen;
        if (previousPen == null) {
            pen.startIndex = 0;
        } else {
            pen.startIndex = previousPen.endIndex;
        }
        this.pens.push(pen);

        // maintan lines
        var line = this.lastLine;
        if (line == null) {
            line = this.LinesPool.pop() || [];
            this.lines.push(line);
        }
        line.push(pen);

        // new line, add an empty line
        if (pen.newLineMode !== NO_NEWLINE$1) {
            line = this.LinesPool.pop() || [];
            this.lines.push(line);
        }
        this.maxLinesWidth = undefined;
    }

    clone(targetPenManager) {
        if (targetPenManager == null)
            targetPenManager = new PenManager();

        targetPenManager.clear();

        for (var li = 0, llen = this.lines.length; li < llen; li++) {
            var pens = this.lines[li];
            for (var pi = 0, plen = pens.length; pi < plen; pi++) {
                var pen = pens[pi];
                targetPenManager.addPen(
                    pen.text,
                    pen.x,
                    pen.y,
                    pen.width,
                    Clone(pen.prop),
                    pen.newLineMode
                );
            }
        }

        return targetPenManager;
    }

    get lastPen() {
        return this.pens[this.pens.length - 1];
    }

    get lastLine() {
        return this.lines[this.lines.length - 1];
    }

    getLineStartIndex(i) {
        if (i >= this.lines.length) {
            return this.getLineEndIndex(i);
        } else {
            var line = this.lines[i];
            return (line && line[0]) ? line[0].startIndex : 0;
        }
    }

    getLineEndIndex(i) {
        if (i >= this.lines.length) {
            i = this.lines.length - 1;
        }
        var li, hasLastPen = false,
            line;
        for (li = i; li >= 0; li--) {
            line = this.lines[li];
            hasLastPen = (line != null) && (line.length > 0);
            if (hasLastPen) {
                break;
            }
        }
        if (!hasLastPen) {
            return 0;
        }

        var lastPen = line[line.length - 1];
        return lastPen.endIndex;
    }

    getLineWidth(i) {
        var line = this.lines[i];
        if (!line) {
            return 0;
        }

        var lastPen = line[line.length - 1];
        if (lastPen == null) {
            return 0;
        }

        var lineWidth = lastPen.lastX; // start from 0
        return lineWidth;
    }

    getMaxLineWidth() {
        if (this.maxLinesWidth !== undefined) {
            return this.maxLinesWidth;
        }
        var w, maxW = 0;
        for (var i = 0, len = this.lines.length; i < len; i++) {
            w = this.getLineWidth(i);
            if (w > maxW) {
                maxW = w;
            }
        }
        this.maxLinesWidth = maxW;
        return maxW;
    }

    getLineWidths() {
        var result = [];
        for (var i = 0, len = this.lines.length; i < len; i++) {
            result.push(this.getLineWidth(i));
        }
        return result;
    }

    get linesCount() {
        return this.lines.length;
    }

    get plainText() {
        var txt = "",
            pens = this.pens;
        for (var i = 0, len = pens.length; i < len; i++) {
            txt += pens[i].plainText;
        }

        return txt;
    }

    get rawTextLength() {
        var l = 0,
            pens = this.pens;
        for (var i = 0, len = this.pens.length; i < len; i++) {
            l += pens[i].rawTextLength;
        }

        return l;
    }

    getSliceTagText(start, end, wrap) {
        if (start === undefined) {
            start = 0;
        }
        if (end === undefined) {
            var lastPen = this.lastPen;
            if (lastPen == null) {
                return "";
            }

            end = lastPen.endIndex;
        }
        if (wrap === undefined) {
            wrap = false;
        }

        var txt = "",
            pen, penTxt, penStartIdx, penEndIdx, isInRange;
        var currentProp, previousProp;
        for (var i = 0, len = this.pens.length; i < len; i++) {
            pen = this.pens[i];
            penEndIdx = pen.endIndex;
            if (penEndIdx <= start) {
                continue;
            }
            pen = this.pens[i];
            penTxt = (!wrap) ? pen.plainText : pen.wrapText;
            currentProp = pen.prop;
            penStartIdx = pen.startIndex;

            isInRange = (penStartIdx >= start) && (penEndIdx <= end);
            if (!isInRange) {
                penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);
            }

            if (this.tagToTextScope) {
                txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);
            } else {
                txt += this.tagToText(penTxt, currentProp, previousProp);
            }

            previousProp = currentProp;
            if (penEndIdx >= end) {
                break;
            }
        }

        return txt;
    }

    get length() {
        return this.lines.length;
    }

    set length(value) {
        // Only for set length to 0 (clear)
        this.clear();
    }
}
var PEN_CONFIG = {};

const Rectangle = Phaser.Geom.Rectangle;

var RectanglePool = new Stack();
class HitAreaManager {
    constructor() {
        this.hitAreas = [];
    }

    destroy() {
        this.clear();
    }

    clear() {
        RectanglePool.pushMultiple(this.hitAreas);
        return this;
    }

    add(key, x, y, width, height) {
        var rectangle = RectanglePool.pop();
        if (rectangle === null) {
            rectangle = new Rectangle(x, y, width, height);
        } else {
            rectangle.setTo(x, y, width, height);
        }
        rectangle.key = key;
        this.hitAreas.push(rectangle);
        return this;
    }

    getFirstHitArea(x, y) {
        var hitAreas = this.hitAreas, hitArea;
        for (var i = 0, cnt = hitAreas.length; i < cnt; i++) {
            hitArea = hitAreas[i];
            if (hitArea.contains(x, y)) {
                return hitArea;
            }
        }
        return null;
    }

    drawBounds(graphics, color, parent) {
        if (color === undefined) {
            color = 0xffffff;
        }

        if (parent) {
            graphics
                .save()
                .scaleCanvas(parent.scaleX, parent.scaleY)
                .rotateCanvas(parent.rotation)
                .translateCanvas(parent.x, parent.y);
        }

        var hitAreas = this.hitAreas, hitArea;
        for (var i = 0, cnt = hitAreas.length; i < cnt; i++) {
            hitArea = hitAreas[i];
            graphics.lineStyle(1, color).strokeRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
        }

        if (parent) {
            graphics
                .restore();
        }
        return this;
    }
}

var SetInteractive = function () {
    this.parent
        .on('pointerdown', function (pointer, localX, localY, event) {
            FireEvent.call(this, 'areadown', pointer, localX, localY);
        }, this)
        .on('pointerup', function (pointer, localX, localY, event) {
            FireEvent.call(this, 'areaup', pointer, localX, localY);
        }, this);
};

var FireEvent = function (eventName, pointer, localX, localY) {
    var area = this.hitAreaManager.getFirstHitArea(localX, localY);
    if (area === null) {
        return;
    }
    var key = area.key;
    this.parent.emit(`${eventName}-${key}`, pointer, localX, localY);
    this.parent.emit(eventName, key, pointer, localX, localY);
};

var LinesPool$1 = new Stack();

var FreeLine = function (line) {
    if (!line) {
        return;
    }
    LinesPool$1.push(line);
};

var FreeLines = function (lines) {
    if (!lines) {
        return;
    }
    LinesPool$1.pushMultiple(lines);
};

var GetLine = function (text, width, newLineMode) {
    var l = LinesPool$1.pop();
    if (l === null) {
        l = {};
    }
    l.text = text;
    l.width = width;
    l.newLineMode = newLineMode;
    return l;
};

const NO_NEWLINE$2 = CONST.NO_NEWLINE;
const RAW_NEWLINE$1 = CONST.RAW_NEWLINE;
const WRAPPED_NEWLINE$1 = CONST.WRAPPED_NEWLINE;
const NO_WRAP = CONST.NO_WRAP;
const WORD_WRAP = CONST.WORD_WRAP;
const CHAR_WRAP = CONST.CHAR_WRAP;
const splitRegExp = CONST.SPLITREGEXP;

var WrapText = function (text, getTextWidth, wrapMode, wrapWidth, offset) {
    if (wrapWidth <= 0) {
        wrapMode = NO_WRAP;
    }

    var retLines = [];
    if (!text || !text.length) {
        return retLines;
    }

    var isNoWrap = (wrapMode === NO_WRAP);
    var isWordWrap = (wrapMode === WORD_WRAP);

    var lines = text.split(splitRegExp),
        line, remainWidth, newLineMode;
    for (var i = 0, linesLen = lines.length; i < linesLen; i++) {
        line = lines[i];
        newLineMode = (i === (linesLen - 1)) ? NO_NEWLINE$2 : RAW_NEWLINE$1;

        if (isNoWrap) {
            var textWidth = getTextWidth(line);
            retLines.push(GetLine(line, textWidth, newLineMode));
            continue;
        }

        remainWidth = (i === 0) ? (wrapWidth - offset) : wrapWidth;

        // short string testing
        if (line.length <= 100) {
            var textWidth = getTextWidth(line);
            if (textWidth <= remainWidth) {
                retLines.push(GetLine(line, textWidth, newLineMode));
                continue;
            }
        }

        var tokenArray, isSpaceCharacterEnd;
        if (isWordWrap) {
            // word mode
            tokenArray = line.split(' ');
            isSpaceCharacterEnd = (tokenArray[tokenArray.length - 1] === '');
            if (isSpaceCharacterEnd) {
                tokenArray.length -= 1;
            }
        } else {
            tokenArray = line;
        }
        var token, tokenWidth, isLastToken;
        var lineText = '', lineWidth = 0;
        var currLineWidth;
        var whiteSpaceWidth = (isWordWrap) ? getTextWidth(' ') : undefined;
        for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
            token = tokenArray[j];
            tokenWidth = getTextWidth(token);

            isLastToken = (j === (tokenLen - 1));
            if (isWordWrap && (!isLastToken || isSpaceCharacterEnd)) {
                token += ' ';
                tokenWidth += whiteSpaceWidth;
            }

            // Text width of single token is larger than a line width
            if (isWordWrap && (tokenWidth > wrapWidth)) {
                if (lineText !== '') {
                    // Has pending lineText, flush it out
                    retLines.push(GetLine(lineText, lineWidth, WRAPPED_NEWLINE$1));

                } else if ((j === 0) && (offset > 0)) {
                    // No pending lineText, but has previous text. Append a newline
                    retLines.push(GetLine('', 0, WRAPPED_NEWLINE$1));

                }

                // Word break
                retLines.push(...WrapText(token, getTextWidth, CHAR_WRAP, wrapWidth, 0));
                // Continue at last-wordBreak-line
                var lastwordBreakLine = retLines.pop();
                lineText = lastwordBreakLine.text;
                lineWidth = lastwordBreakLine.width;                
                // Free this line
                FreeLine(lastwordBreakLine);

                // Special case : Start at a space character, discard it
                if (lineText === ' ') {
                    lineText = '';
                    lineWidth = 0;
                }
                continue;
            }

            currLineWidth = lineWidth + tokenWidth;
            if (currLineWidth > remainWidth) {
                // New line
                retLines.push(GetLine(lineText, lineWidth, WRAPPED_NEWLINE$1));
                lineText = token;
                lineWidth = tokenWidth;
                remainWidth = wrapWidth;

            } else {
                // Append token, continue
                lineText += token;
                lineWidth = currLineWidth;
            }

            if (isLastToken) {
                // Flush remain text
                retLines.push(GetLine(lineText, lineWidth, newLineMode));
            }
        } // for token in tokenArray

    } // for each line in lines

    return retLines;
};

const GetValue$7 = Phaser.Utils.Objects.GetValue;
const NO_WRAP$1 = CONST.NO_WRAP;
const NO_NEWLINE$3 = CONST.NO_NEWLINE;

class CanvasText {
    constructor(config) {
        this.parent = config.parent;
        this.context = GetValue$7(config, 'context', null);
        this.canvas = this.context.canvas;
        this.parser = GetValue$7(config, 'parser', null);
        this.defaultStyle = GetValue$7(config, 'style', null);
        this.autoRound = true;

        this.pensPool = GetValue$7(config, 'pensPool', null);
        this.penManager = this.newPenManager();
        this._tmpPenManager = null;

        this.hitAreaManager = new HitAreaManager();

        var context = this.context;
        this.getTextWidth = function (text) {
            return context.measureText(text).width;
        };
    }

    destroy() {
        this.context = undefined;
        this.canvas = undefined;
        this.parser = undefined;
        this.defaultStyle = undefined;

        if (this.penManager) {
            this.penManager.destroy();
            this.penManager = undefined;
        }
        if (this._tmpPenManager) {
            this._tmpPenManager.destroy();
            this._tmpPenManager = undefined;
        }
        if (this.hitAreaManager) {
            this.hitAreaManager.destroy();
            this.hitAreaManager = undefined;
        }
    }

    updatePenManager(text, wrapMode, wrapWidth, lineHeight, penManager) {
        if (penManager === undefined) {
            penManager = this.penManager;
        }
        penManager.clear();
        if (text === "") {
            return penManager;
        }

        var textStyle = this.parent.style;
        if (textStyle.isWrapFitMode) {
            var padding = this.parent.padding;
            wrapWidth = textStyle.fixedWidth - padding.left - padding.right;
        }

        var canvas = this.canvas;
        var context = this.context;

        var MeasureText = function (text) {
            return context.measureText(text).width;
        };

        var cursorX = 0,
            cursorY = 0;

        var customTextWrapCallback = textStyle.wrapCallback,
            customTextWrapCallbackScope = textStyle.wrapCallbackScope;
        var reuseLines = true;

        var plainText, curProp, curStyle;
        var match = this.parser.splitText(text),
            result, wrapLines;
        for (var i = 0, len = match.length; i < len; i++) {
            result = this.parser.tagTextToProp(match[i], curProp);
            plainText = result.plainText;
            curProp = result.prop;

            if (curProp.img) { // Image tag                
                var imgWidth = this.imageManager.getOuterWidth(curProp.img);
                if ((wrapWidth > 0) && (wrapMode !== NO_WRAP$1)) {  // Wrap mode
                    if (wrapWidth < (cursorX + imgWidth)) {
                        penManager.addNewLinePen();
                        cursorY += lineHeight;
                        cursorX = 0;
                    }
                }
                penManager.addImagePen(cursorX, cursorY, imgWidth, Clone(curProp));
                cursorX += imgWidth;

            } else if (plainText !== '') {
                // wrap text to lines
                // Save the current context.
                context.save();
                curStyle = this.parser.propToContextStyle(
                    this.defaultStyle,
                    curProp
                );
                curStyle.buildFont();
                curStyle.syncFont(canvas, context);
                curStyle.syncStyle(canvas, context);

                if (!customTextWrapCallback) {
                    wrapLines = WrapText(
                        plainText,
                        MeasureText,
                        wrapMode, wrapWidth,
                        cursorX
                    );
                } else { // customTextWrapCallback
                    wrapLines = customTextWrapCallback.call(customTextWrapCallbackScope,
                        plainText,
                        MeasureText,
                        wrapWidth,
                        cursorX
                    );
                    if (typeof (wrapLines) === 'string') {
                        wrapLines = wrapLines.split('\n');
                    }
                    var n;
                    for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
                        n = wrapLines[j];
                        if (typeof (n) === 'string') {
                            wrapLines[j] = GetLine(n, MeasureText(n), (j < (jLen - 1)) ? 2 : 0);
                        } else {
                            reuseLines = false;
                        }
                    }
                }  // customTextWrapCallback

                // add pens
                var n;
                for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
                    n = wrapLines[j];
                    penManager.addTextPen(n.text, cursorX, cursorY, n.width, Clone(curProp), n.newLineMode);

                    if (n.newLineMode !== NO_NEWLINE$3) {
                        cursorX = 0;
                        cursorY += lineHeight;
                    } else {
                        cursorX += n.width;
                    }

                }

                if (reuseLines) {
                    FreeLines(wrapLines);
                }
                wrapLines = null;

                context.restore();

            }

        }

        return penManager;
    }

    get startXOffset() {
        var defaultStyle = this.defaultStyle;
        return (defaultStyle.strokeThickness / 2) + defaultStyle.xOffset;
    }

    get startYOffset() {
        var defaultStyle = this.defaultStyle;
        return (defaultStyle.strokeThickness / 2) + defaultStyle.metrics.ascent;
    }

    get lines() {
        return this.penManager.lines;
    }

    get desplayLinesCount() {
        var linesCount = this.penManager.linesCount,
            maxLines = this.defaultStyle.maxLines;
        if ((maxLines > 0) && (linesCount > maxLines)) {
            linesCount = maxLines;
        }
        return linesCount;
    }

    get linesWidth() {
        return this.penManager.getMaxLineWidth();
    }

    get linesHeight() {
        var linesCount = this.desplayLinesCount;
        var linesHeight = (this.defaultStyle.lineHeight * linesCount);
        if (linesCount > 0) {
            linesHeight -= this.defaultStyle.lineSpacing;
        }
        return linesHeight;
    }

    get imageManager() {
        return this.parent.imageManager;
    }

    get rtl() {
        return this.parent.style.rtl;
    }

    newPenManager() {
        return new PenManager({
            pensPool: this.pensPool,
            tagToText: this.parser.propToTagText,
            tagToTextScope: this.parser
        });
    }

    get tmpPenManager() {
        if (this._tmpPenManager === null) {
            this._tmpPenManager = this.newPenManager();
        }
        return this._tmpPenManager;
    }

    getPlainText(text, start, end) {
        var plainText;
        if (text == null) {
            plainText = this.penManager.plainText;
        } else {
            var match = this.parser.splitText(text, 1); // PLAINTEXTONLY_MODE
            plainText = "";
            for (var i = 0, len = match.length; i < len; i++) {
                plainText += match[i];
            }
        }

        if ((start != null) || (end != null)) {
            if (start == null) {
                start = 0;
            }
            if (end == null) {
                end = plainText.length;
            }
            plainText = plainText.substring(start, end);
        }

        return plainText;
    }

    getPenManager(text, retPenManager) {
        if (text === undefined) {
            return this.copyPenManager(retPenManager, this.penManager);
        }

        if (retPenManager === undefined) {
            retPenManager = this.newPenManager();
        }

        var defaultStyle = this.defaultStyle;
        this.updatePenManager(
            text,
            defaultStyle.wrapMode,
            defaultStyle.wrapWidth,
            defaultStyle.lineHeight,
            retPenManager
        );
        return retPenManager;
    }

    getText(text, start, end, wrap) {
        if (text == null) {
            return this.penManager.getSliceTagText(start, end, wrap);
        }

        var penManager = this.tmpPenManager;
        var defaultStyle = this.defaultStyle;
        this.updatePenManager(
            text,
            defaultStyle.wrapMode,
            defaultStyle.wrapWidth,
            defaultStyle.lineHeight,
            penManager
        );

        return penManager.getSliceTagText(start, end, wrap);
    }

    copyPenManager(ret, src) {
        if (src === undefined) {
            src = this.penManager;
        }
        return src.copy(ret);
    }

    getTextWidth(penManager) {
        if (penManager === undefined) {
            penManager = this.penManager;
        }

        return penManager.getMaxLineWidth();
    }

    getLastPen(penManager) {
        if (penManager === undefined) {
            penManager = this.penManager;
        }

        return penManager.lastPen;
    }
}
var methods = {
    setInteractive: SetInteractive,
};

Object.assign(
    CanvasText.prototype,
    DrawMethods,
    methods
);

const GetValue$8 = Phaser.Utils.Objects.GetValue;

var AddImage = function (key, config) {
    if (config === undefined) {
        config = {
            key: key
        };
    }

    if (!config.hasOwnProperty('key')) {
        config.key = key;
    }

    var textureKey = config.key, frameKey = config.frame;
    var width = config.width, height = config.height;

    if ((width === undefined) || (height === undefined)) {
        var frame = this.textureManager.getFrame(textureKey, frameKey);
        var frameWidth = (frame) ? frame.cutWidth : 0;
        var frameHeight = (frame) ? frame.cutHeight : 0;
        if ((width === undefined) && (height === undefined)) {
            width = frameWidth;
            height = frameHeight;
        } else if (width === undefined) {
            width = frameWidth * (height / frameHeight);
        } else if (height === undefined) {
            height = frameHeight * (width / frameWidth);
        }
    }

    this.images[key] = {
        key: textureKey,
        frame: frameKey,
        width: width,
        height: height,
        y: GetValue$8(config, 'y', 0),
        left: GetValue$8(config, 'left', 0),
        right: GetValue$8(config, 'right', 0)
    };
};

var DrawImage = function (key, context, x, y, autoRound) {
    var imgData = this.get(key);

    x += imgData.left;
    y += imgData.y;
    if (autoRound) {
        x = Math.round(x);
        y = Math.round(y);
    }

    var frame = this.textureManager.getFrame(imgData.key, imgData.frame);

    context.drawImage(
        frame.source.image,
        frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight,
        x, y, imgData.width, imgData.height
    );
};

class ImageManager {
    constructor(scene) {
        this.textureManager = scene.textures;
        this.images = {};
    }

    destroy() {
        this.textureManager = undefined;
        this.images = undefined;
    }

    add(key, config) {
        if (typeof (key) === 'string') {
            AddImage.call(this, key, config);
        } else if (Array.isArray(key)) {
            var data = key;
            for (var i = 0, cnt = data.length; i < cnt; i++) {
                AddImage.call(this, data[i]);
            }
        } else {
            var data = key;
            for (var key in data) {
                AddImage.call(this, key, data[key]);
            }
        }
        return this;
    }

    has(key) {
        return this.images.hasOwnProperty(key);
    }

    remove(key) {
        if (this.has(key)) {
            delete this.images[key];
        }
        return this;
    }

    get(key) {
        if (!this.has(key)) {
            if (this.textureManager.exists(key)) {
                this.add(key);
            }
        }
        return this.images[key];
    }

    getOuterWidth(key) {
        var data = this.get(key);
        return (data) ? (data.width + data.left + data.right) : 0;
    }

    getFrame(key) {
        var data = this.get(key);
        return (data) ? this.textureManager.getFrame(data.key, data.frame) : undefined;
    }

    hasTexture(key) {
        return !!this.getFrame(key);
    }
}

var methods$1 = {
    draw: DrawImage
};

Object.assign(
    ImageManager.prototype,
    methods$1
);

const IsPlainObject$2 = Phaser.Utils.Objects.IsPlainObject;
const AddToDOM = Phaser.DOM.AddToDOM;
const CanvasPool$3 = Phaser.Display.Canvas.CanvasPool;
const GameObject$1 = Phaser.GameObjects.GameObject;
const GetValue$9 = Phaser.Utils.Objects.GetValue;
const RemoveFromDOM = Phaser.DOM.RemoveFromDOM;
const SPLITREGEXP = CONST.SPLITREGEXP;

var PensPools = {};

class Text extends GameObject$1 {
    constructor(scene, x, y, text, style, type, parser) {
        if (IsPlainObject$2(x)) {
            var config = x;
            x = GetValue$9(config, 'x', 0);
            y = GetValue$9(config, 'y', 0);
            text = GetValue$9(config, 'text', '');
            style = GetValue$9(config, 'style', '');
        }
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }

        super(scene, type);

        this.renderer = scene.sys.game.renderer;

        this.setPosition(x, y);
        this.setOrigin(0, 0);
        this.initPipeline();

        this.canvas = CanvasPool$3.create(this);

        this.context = this.canvas.getContext('2d');

        this._imageManager = undefined;

        if (style) {
            // Override align
            if (style.hasOwnProperty('align')) {
                var halign = style.align;
                delete style.align;
                style.halign = halign;
            }
            // Has Stroke color but stroke thinkness, set stroke thinkness to 1
            if (style.hasOwnProperty('stroke') && !style.hasOwnProperty('strokeThickness')) {
                style.strokeThickness = 1;
            }
        }
        this.style = new TextStyle(this, style);

        this.autoRound = true;

        this._text = undefined;

        this.padding = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
        };

        this.width = 1;

        this.height = 1;

        this.dirty = false;

        //  If resolution wasn't set, force it to 1
        if (this.style.resolution === 0) {
            this.style.resolution = 1;
        }

        this._crop = this.resetCropObject();

        //  Create a Texture for this Text object
        this.texture = scene.sys.textures.addCanvas(null, this.canvas, true);

        //  Get the frame
        this.frame = this.texture.get();

        //  Set the resolution
        this.frame.source.resolution = this.style.resolution;

        if (this.renderer.gl) {
            //  Clear the default 1x1 glTexture, as we override it later

            this.renderer.deleteTexture(this.frame.source.glTexture);

            this.frame.source.glTexture = null;
        }

        if (!PensPools.hasOwnProperty(type)) {
            PensPools[type] = new Stack();
        }
        this.canvasText = new CanvasText({
            parent: this,
            context: this.context,
            parser: parser,
            style: this.style,
            pensPool: PensPools[type]
        });

        this.initRTL();

        if (style && style.padding) {
            this.setPadding(style.padding);
        }

        this.setText(text);

        scene.sys.game.events.on('contextrestored', this.onContextRestored, this);
    }

    onContextRestored() {
        this.dirty = true;
    }

    preDestroy() {
        if (this.style.rtl) {
            RemoveFromDOM(this.canvas);
        }

        this.scene.sys.game.events.off('contextrestored', this.onContextRestored, this);

        this.canvasText.destroy();
        this.canvasText = undefined;

        if (this._imageManager) {
            this._imageManager.destroy();
            this._imageManager = undefined;
        }

        CanvasPool$3.remove(this.canvas);

        this.texture.destroy();
    }

    set text(value) {
        this.setText(value);
    }
    get text() {
        return this._text;
    }

    initRTL() {
        if (!this.style.rtl) {
            return;
        }

        //  Here is where the crazy starts.
        //
        //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas
        //  that is not part of the DOM. It just completely ignores the direction property.

        this.canvas.dir = 'rtl';

        //  Experimental atm, but one day ...
        this.context.direction = 'rtl';

        //  Add it to the DOM, but hidden within the parent canvas.
        this.canvas.style.display = 'none';

        AddToDOM(this.canvas, this.scene.sys.canvas);

        //  And finally we set the x origin
        this.originX = 1;
    }

    setText(value) {
        if (value == null) {
            value = '';
        }

        if (Array.isArray(value)) {
            value = value.join('\n');
        }

        if (value !== this._text) {
            this._text = value.toString();

            this.updateText();
        }

        return this;
    }

    appendText(value) {
        if (value == null) {
            return this;
        }
        if (Array.isArray(value)) {
            value = value.join('\n');
        }

        this.setText(this.text + value.toString());
        return this;
    }

    setStyle(style) {
        return this.style.setStyle(style);
    }

    setFont(font) {
        return this.style.setFont(font);
    }

    setFontFamily(family) {
        return this.style.setFontFamily(family);
    }

    setFontSize(size) {
        return this.style.setFontSize(size);
    }

    setFontStyle(style) {
        return this.style.setFontStyle(style);
    }

    setTestString(string) {
        return this.style.setTestString(string);
    }

    setFixedSize(width, height) {
        return this.style.setFixedSize(width, height);
    }

    setBackgroundColor(color, color2, isHorizontalGradient) {
        return this.style.setBackgroundColor(color, color2, isHorizontalGradient);
    }

    setBackgroundStrokeColor(color, lineWidth) {
        return this.style.setBackgroundStrokeColor(color, lineWidth);
    }

    setBackgroundCornerRadius(radius, iteration) {
        return this.style.setBackgroundCornerRadius(radius, iteration);
    }

    setFill(color) {
        return this.style.setFill(color);
    }

    setColor(color) {
        return this.style.setColor(color);
    }

    setStroke(color, thickness) {
        return this.style.setStroke(color, thickness);
    }

    setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
    }

    setShadowOffset(x, y) {
        return this.style.setShadowOffset(x, y);
    }

    setShadowColor(color) {
        return this.style.setShadowColor(color);
    }

    setShadowBlur(blur) {
        return this.style.setShadowBlur(blur);
    }

    setShadowStroke(enabled) {
        return this.style.setShadowStroke(enabled);
    }

    setShadowFill(enabled) {
        return this.style.setShadowFill(enabled);
    }

    setWrapMode(mode) {
        return this.style.setWrapMode(mode);
    }

    setWrapWidth(width) {
        return this.style.setWrapWidth(width);
    }

    setAlign(align) {
        return this.style.setHAlign(align);
    }
    setHAlign(align) {
        return this.style.setHAlign(align);
    }
    setVAlign(align) {
        return this.style.setVAlign(align);
    }

    setLineSpacing(value) {
        return this.style.setLineSpacing(value);
    }

    setXOffset(value) {
        return this.style.setXOffset(value);
    }


    setPadding(left, top, right, bottom) {
        if (typeof left === 'object') {
            var config = left;

            //  If they specify x and/or y this applies to all
            var x = GetValue$9(config, 'x', null);

            if (x !== null) {
                left = x;
                right = x;
            } else {
                left = GetValue$9(config, 'left', 0);
                right = GetValue$9(config, 'right', left);
            }

            var y = GetValue$9(config, 'y', null);

            if (y !== null) {
                top = y;
                bottom = y;
            } else {
                top = GetValue$9(config, 'top', 0);
                bottom = GetValue$9(config, 'bottom', top);
            }
        } else {
            if (left === undefined) {
                left = 0;
            }
            if (top === undefined) {
                top = left;
            }
            if (right === undefined) {
                right = left;
            }
            if (bottom === undefined) {
                bottom = top;
            }
        }

        this.padding.left = left;
        this.padding.top = top;
        this.padding.right = right;
        this.padding.bottom = bottom;

        return this.updateText(false);
    }

    setMaxLines(max) {
        return this.style.setMaxLines(max);
    }

    setResolution(value) {
        return this.style.setResolution(value);
    }

    updateText(runWrap) {
        if (runWrap === undefined) {
            runWrap = true;
        }
        var canvasText = this.canvasText;

        // wrap text to pens
        var style = this.style;
        if (runWrap) {
            canvasText.updatePenManager(
                this._text,
                style.wrapMode,
                style.wrapWidth,
                style.lineHeight
            );
        }

        // resize
        var padding = this.padding;
        var textWidth, textHeight;
        if (style.fixedWidth === 0) {
            this.width = canvasText.linesWidth + padding.left + padding.right;
            textWidth = canvasText.linesWidth;
        }
        else {
            this.width = style.fixedWidth;
            textWidth = this.width - padding.left - padding.right;
            if (textWidth < canvasText.linesWidth) {
                textWidth = canvasText.linesWidth;
            }
        }
        if (style.fixedHeight === 0) {
            this.height = canvasText.linesHeight + padding.top + padding.bottom;
            textHeight = canvasText.linesHeight;
        }
        else {
            this.height = style.fixedHeight;
            textHeight = this.height - padding.top - padding.bottom;
            if (textHeight < canvasText.linesHeight) {
                textHeight = canvasText.linesHeight;
            }
        }

        var w = this.width;
        var h = this.height;

        this.updateDisplayOrigin();

        var resolution = style.resolution;
        w *= resolution;
        h *= resolution;

        w = Math.max(Math.ceil(w), 1);
        h = Math.max(Math.ceil(h), 1);

        var canvas = this.canvas;
        var context = this.context;
        if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            this.frame.setSize(w, h);
        } else {
            context.clearRect(0, 0, w, h);
        }

        context.save();
        context.scale(resolution, resolution);

        // draw
        var startX = (!this.style.rtl) ? padding.left : padding.right;
        var startY = padding.top;
        canvasText.draw(
            startX,
            startY,
            textWidth,
            textHeight,
        );

        context.restore();

        if (this.renderer && this.renderer.gl) {
            this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
            this.frame.glTexture = this.frame.source.glTexture;
        }

        this.dirty = true;

        var input = this.input;

        if (input && !input.customHitArea) {
            input.hitArea.width = this.width;
            input.hitArea.height = this.height;
        }

        return this;
    }

    getTextMetrics() {
        return this.style.getTextMetrics();
    }

    setTextMetrics(metrics, font) {
        return this.style.setTextMetrics(metrics, font);
    }

    toJSON() {
        var out = Components$1.ToJSON(this);

        //  Extra Text data is added here

        var data = {
            autoRound: this.autoRound,
            text: this._text,
            style: this.style.toJSON(),
            resolution: this.resolution,
            padding: {
                left: this.padding.left,
                right: this.padding.right,
                top: this.padding.top,
                bottom: this.padding.bottom
            }
        };

        out.data = data;

        return out;
    }

    setInteractive(shape, callback, dropZone) {
        GameObject$1.prototype.setInteractive.call(this, shape, callback, dropZone);
        this.canvasText.setInteractive();
        return this;
    }

    getWrappedText(text, start, end) {
        text = this.canvasText.getText(text, start, end, true);
        return text.split(SPLITREGEXP);
    }

    getPlainText(text, start, end) {
        return this.canvasText.getPlainText(text, start, end);
    }

    getText(text, start, end, wrap) {
        if (wrap === undefined) {
            wrap = false;
        }
        return this.canvasText.getText(text, start, end, wrap);
    }

    getSubString(text, start, end) {
        return this.getText(text, start, end);
    }

    copyPenManager(penManager) {
        return this.canvasText.copyPenManager(penManager);
    }

    getPenManager(text, penManager) {
        return this.canvasText.getPenManager(text, penManager);
    }

    setSize(width, height) {
        return this.setFixedSize(width, height);
    }

    resize(width, height) {
        return this.setFixedSize(width, height);
    }

    set lineSpacing(value) {
        this.setLineSpacing(value);
    }
    get lineSpacing() {
        return this.style.lineSpacing;
    }

    get imageManager() {
        if (!this._imageManager) {
            this._imageManager = new ImageManager(this.scene);
        }
        return this._imageManager;
    }

    addImage(key, config) {
        this.imageManager.add(key, config);
        return this;
    }

    drawAreaBounds(graphics, color) {
        this.canvasText.hitAreaManager.drawBounds(graphics, color, this);
        return this;
    }

    measureTextMargins(testString, out) {
        return MeasureTextMargins(this.style, testString, out);
    }

    generateTexture(key, x, y, width, height) {
        var srcCanvas = this.canvas;
        if (width === undefined) {
            width = srcCanvas.width;
        } else {
            width *= this.resolution;
        }
        if (height === undefined) {
            height = srcCanvas.height;
        } else {
            height *= this.resolution;
        }

        CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);
        return this;
    }
}

const Components$1 = Phaser.GameObjects.Components;
Phaser.Class.mixin(Text,
    [
        Components$1.Alpha,
        Components$1.BlendMode,
        Components$1.ComputedSize,
        Components$1.Crop,
        Components$1.Depth,
        Components$1.Flip,
        Components$1.GetBounds,
        Components$1.Mask,
        Components$1.Origin,
        Components$1.Pipeline,
        Components$1.ScrollFactor,
        Components$1.Tint,
        Components$1.Transform,
        Components$1.Visible,
        Render$2
    ]
);

var GETPROP_RESULT = {
    plainText: null,
    prevProp: null
};

var STYLE_RESULT = new TextStyle();
var EMPTYPROP = {};

var parser = {
    splitText: function (text, mode) {
        var result = [];
        var charIdx = 0;
        while (true) {
            var regexResult = RE_SPLITTEXT.exec(text);
            if (!regexResult) {
                var totalLen = text.length;
                if (charIdx < totalLen) { // Push remainder string
                    result.push(text.substring(charIdx, totalLen));
                }
                return result; // [text,...]
            }

            var match = regexResult[0];
            var matchStart = RE_SPLITTEXT.lastIndex - match.length;

            if (charIdx < matchStart) {
                result.push(text.substring(charIdx, matchStart));
            }

            if (mode === undefined) {
                result.push(match);
            }

            charIdx = RE_SPLITTEXT.lastIndex;
        }
    },

    tagTextToProp: function (text, prevProp) {
        var plainText, innerMatch;

        if (prevProp == null) {
            prevProp = {};
        }

        // close image tag
        if (prevProp.img) {
            UpdateProp(prevProp, PROP_REMOVE, 'img');
        }
        // Check if current fragment is a class tag
        if (RE_BLOD_OPEN.test(text)) {
            UpdateProp(prevProp, PROP_ADD, 'b', true);
            plainText = '';
        } else if (RE_BLOD_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'b');
            plainText = '';
        } else if (RE_ITALICS_OPEN.test(text)) {
            UpdateProp(prevProp, PROP_ADD, 'i', true);
            plainText = '';
        } else if (RE_ITALICS_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'i');
            plainText = '';
        } else if (RE_SIZE_OPEN.test(text)) {
            innerMatch = text.match(RE_SIZE_OPEN);
            UpdateProp(prevProp, PROP_ADD, 'size', `${innerMatch[1]}px`);
            plainText = '';
        } else if (RE_SIZE_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'size');
            plainText = '';
        } else if (RE_COLOR_OPEN.test(text)) {
            innerMatch = text.match(RE_COLOR_OPEN);
            UpdateProp(prevProp, PROP_ADD, 'color', innerMatch[1]);
            plainText = '';
        } else if (RE_COLOR_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'color');
            plainText = '';
        } else if (RE_UNDERLINE_OPEN.test(text)) {
            innerMatch = text.match(RE_UNDERLINE_OPEN);
            UpdateProp(prevProp, PROP_ADD, 'u', true);
            plainText = '';
        } else if (RE_UNDERLINE_OPENC.test(text)) {
            innerMatch = text.match(RE_UNDERLINE_OPENC);
            UpdateProp(prevProp, PROP_ADD, 'u', innerMatch[1]);
            plainText = '';
        } else if (RE_UNDERLINE_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'u');
            plainText = '';
        } else if (RE_SHADOW_OPEN.test(text)) {
            UpdateProp(prevProp, PROP_ADD, 'shadow', true);
            plainText = '';
        } else if (RE_SHADOW_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'shadow');
            plainText = '';
        } else if (RE_STROKE_OPEN.test(text)) {
            UpdateProp(prevProp, PROP_ADD, 'stroke', true);
            plainText = '';
        } else if (RE_STROKE_OPENC.test(text)) {
            innerMatch = text.match(RE_STROKE_OPENC);
            UpdateProp(prevProp, PROP_ADD, 'stroke', innerMatch[1]);
            plainText = '';
        } else if (RE_STROKE_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'stroke');
            plainText = '';
        } else if (RE_OFFSETY_OPEN.test(text)) {
            innerMatch = text.match(RE_OFFSETY_OPEN);
            UpdateProp(prevProp, PROP_ADD, 'y', parseFloat(innerMatch[1]));
            plainText = '';
        } else if (RE_OFFSETY_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'y');
            plainText = '';
        } else if (RE_IMAGE_OPEN.test(text)) {
            innerMatch = text.match(RE_IMAGE_OPEN);
            UpdateProp(prevProp, PROP_ADD, 'img', innerMatch[1]);
            plainText = '';
        } else if (RE_IMAGE_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'img');
            plainText = '';
        } else if (RE_AREA_OPEN.test(text)) {
            innerMatch = text.match(RE_AREA_OPEN);
            UpdateProp(prevProp, PROP_ADD, 'area', innerMatch[1]);
            plainText = '';
        } else if (RE_AREA_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'area');
            plainText = '';
        } else if (RE_ALIGN_OPEN.test(text)) {
            innerMatch = text.match(RE_ALIGN_OPEN);
            UpdateProp(prevProp, PROP_ADD, 'align', innerMatch[1]);
            plainText = '';
        } else if (RE_ALIGN_CLOSE.test(text)) {
            UpdateProp(prevProp, PROP_REMOVE, 'align');
            plainText = '';
        } else {
            plainText = text;
        }

        var result = GETPROP_RESULT;
        result.plainText = plainText;
        result.prop = prevProp;
        return result;
    },

    propToContextStyle: function (defaultStyle, prop) {
        var result = STYLE_RESULT;
        if (!prop.hasOwnProperty('img')) {
            result.image = null;

            if (prop.hasOwnProperty('family')) {
                result.fontFamily = prop.family;
            } else {
                result.fontFamily = defaultStyle.fontFamily;
            }

            if (prop.hasOwnProperty('size')) {
                var size = prop.size;
                if (typeof (size) === 'number') {
                    size = `${size}px`;
                }
                result.fontSize = size;
            } else {
                result.fontSize = defaultStyle.fontSize;
            }
            result.fontStyle = GetFontStyle(prop.b, prop.i);

            if (prop.hasOwnProperty('color')) {
                result.color = prop.color;
            } else {
                result.color = defaultStyle.color;
            }

            if (prop.hasOwnProperty('stroke')) {
                if (prop.stroke === true) {
                    result.stroke = defaultStyle.stroke;
                    result.strokeThickness = defaultStyle.strokeThickness;
                } else {
                    result.stroke = prop.stroke;
                    result.strokeThickness = defaultStyle.strokeThickness;
                }
            } else {
                result.stroke = defaultStyle.stroke;
                result.strokeThickness = 0;
            }
        } else {
            result.image = prop.img;
        }

        if (prop.hasOwnProperty('shadow')) {
            if (prop.shadow === true) {
                result.shadowColor = defaultStyle.shadowColor;
                result.shadowOffsetX = defaultStyle.shadowOffsetX;
                result.shadowOffsetY = defaultStyle.shadowOffsetY;
                result.shadowBlur = defaultStyle.shadowBlur;
                result.shadowStroke = true;
                result.shadowFill = true;
            } else {
                result.shadowColor = prop.shadow;
                result.shadowOffsetX = defaultStyle.shadowOffsetX;
                result.shadowOffsetY = defaultStyle.shadowOffsetY;
                result.shadowBlur = defaultStyle.shadowBlur;
                result.shadowStroke = true;
                result.shadowFill = true;
            }
        } else {
            result.shadowColor = '#000';
            result.shadowOffsetX = 0;
            result.shadowOffsetY = 0;
            result.shadowBlur = 0;
            result.shadowStroke = false;
            result.shadowFill = false;
        }

        if (prop.hasOwnProperty('u')) {
            if (prop.u === true) {
                result.underlineColor = defaultStyle.underlineColor;
                result.underlineThickness = defaultStyle.underlineThickness;
                result.underlineOffset = defaultStyle.underlineOffset;
            } else {
                result.underlineColor = prop.u;
                result.underlineThickness = defaultStyle.underlineThickness;
                result.underlineOffset = defaultStyle.underlineOffset;
            }
        } else {
            result.underlineColor = '#000';
            result.underlineThickness = 0;
            result.underlineOffset = 0;
        }

        return result;
    },

    propToTagText: function (text, prop, prevProp) {
        if (prevProp == null) {
            prevProp = EMPTYPROP;
        }

        var headers = [];

        for (var k in prevProp) {
            if (!prop.hasOwnProperty(k)) {
                headers.push(`[/${k}]`);
            }
        }


        for (var k in prop) {
            var value = prop[k];

            if (prevProp[k] === value) {
                continue;
            }

            switch (k) {
                case 'size':
                    headers.push(`[size=${value.replace('px', '')}]`);
                    break;

                case 'color':
                case 'stroke':
                case 'y':
                case 'img':
                case 'area':
                case 'align':
                    headers.push(`[${k}=${value}]`);
                    break;

                case 'u':
                    if (value === true) {
                        headers.push('[u]');
                    } else {
                        headers.push(`[u=${value}]`);
                    }
                    break;

                default:
                    headers.push(`[${k}]`);
                    break;
            }
        }

        headers.push(text);

        return headers.join('');
    }
};

var UpdateProp = function (prop, op, key, value) {
    if (op === PROP_ADD) {
        // PROP_ADD     
        prop[key] = value;
    } else {
        // PROP_REMOVE        
        if (prop.hasOwnProperty(key)) {
            delete prop[key];
        }
    }

    return prop;
};

var GetFontStyle = function (isBold, isItalic) {
    if (isBold && isItalic) {
        return 'bold italic';
    } else if (isBold) {
        return 'bold';
    } else if (isItalic) {
        return 'italic';
    } else {
        return '';
    }
};

var RE_SPLITTEXT = /\[b\]|\[\/b\]|\[i\]|\[\/i\]|\[size=(\d+)\]|\[\/size\]|\[color=([a-z]+|#[0-9abcdef]+)\]|\[\/color\]|\[u\]|\[u=([a-z]+|#[0-9abcdef]+)\]|\[\/u\]|\[shadow\]|\[\/shadow\]|\[stroke\]|\[stroke=([a-z]+|#[0-9abcdef]+)\]|\[\/stroke\]|\[y=([-.0-9]+)\]|\[\/y\]|\[img=([^\]]+)\]|\[\/img\]|\[area=([^\]]+)\]|\[\/area\]|\[align=([^\]]+)\]|\[\/align\]/ig;

var RE_BLOD_OPEN = /\[b\]/i;
var RE_BLOD_CLOSE = /\[\/b\]/i;
var RE_ITALICS_OPEN = /\[i\]/i;
var RE_ITALICS_CLOSE = /\[\/i\]/i;
var RE_SIZE_OPEN = /\[size=(\d+)\]/i;
var RE_SIZE_CLOSE = /\[\/size\]/i;
var RE_COLOR_OPEN = /\[color=([a-z]+|#[0-9abcdef]+)\]/i;
var RE_COLOR_CLOSE = /\[\/color\]/i;
var RE_UNDERLINE_OPEN = /\[u\]/i;
var RE_UNDERLINE_OPENC = /\[u=([a-z]+|#[0-9abcdef]+)\]/i;
var RE_UNDERLINE_CLOSE = /\[\/u\]/i;
var RE_SHADOW_OPEN = /\[shadow\]/i;
var RE_SHADOW_CLOSE = /\[\/shadow\]/i;
var RE_STROKE_OPEN = /\[stroke\]/i;
var RE_STROKE_OPENC = /\[stroke=([a-z]+|#[0-9abcdef]+)\]/i;
var RE_STROKE_CLOSE = /\[\/stroke\]/i;
var RE_OFFSETY_OPEN = /\[y=([-.0-9]+)\]/i;
var RE_OFFSETY_CLOSE = /\[\/y\]/i;
var RE_IMAGE_OPEN = /\[img=([^\]]+)\]/i;
var RE_IMAGE_CLOSE = /\[\/img\]/i;
var RE_AREA_OPEN = /\[area=([^\]]+)\]/i;
var RE_AREA_CLOSE = /\[\/area\]/i;
var RE_ALIGN_OPEN = /\[align=([^\]]+)\]/i;
var RE_ALIGN_CLOSE = /\[\/align\]/i;
const PROP_REMOVE = false;
const PROP_ADD = true;

class BBCodeText extends Text {
    constructor(scene, x, y, text, style) {
        super(scene, x, y, text, style, 'rexBBCodeText', parser);
    }
}

var GETPROP_RESULT$1 = {
    plainText: null,
    prevProp: null
};

var STYLE_RESULT$1 = new TextStyle();

class parser$1 {
    constructor(tags) {
        if (tags === undefined) {
            tags = {};
        }
        this.tags = tags;
    }

    addTag(name, prop) {
        this.tags[name] = prop;
    }

    splitText(text, mode) {
        var result = [];
        var charIdx = 0;
        while (true) {
            var regexResult = RE_SPLITTEXT$1.exec(text);
            if (!regexResult) {
                var totalLen = text.length;
                if (charIdx < totalLen) {  // Push remainder string
                    result.push(text.substring(charIdx, totalLen));
                }
                return result; // [text,...]
            }

            var match = regexResult[0];
            var matchStart = RE_SPLITTEXT$1.lastIndex - match.length;

            if (charIdx < matchStart) {
                result.push(text.substring(charIdx, matchStart));
            }
            if (mode === undefined) {
                result.push(match);
            } else if (mode === 1) { // RAWTEXTONLY_MODE
                if (RE_CLASS_HEADER.test(match)) {
                    var innerMatch = match.match(RE_CLASS);
                    result.push(innerMatch[2]);
                } else if (RE_STYLE_HEADER.test(match)) {
                    var innerMatch = match.match(RE_STYLE);
                    result.push(innerMatch[2]);
                }
            }

            charIdx = RE_SPLITTEXT$1.lastIndex;
        }
    }

    tagTextToProp(text, prevProp) {
        var plainText, propOut;
        if (RE_CLASS_HEADER.test(text)) {
            var innerMatch = text.match(RE_CLASS);
            if (innerMatch != null) {
                var name = innerMatch[1];
                var tags = this.tags;
                if (tags.hasOwnProperty(name)) {
                    propOut = tags[name];
                } else {
                    propOut = {};
                }
                propOut._class = name;
                plainText = innerMatch[2];
            }
        } else if (RE_STYLE_HEADER.test(text)) {
            var innerMatch = text.match(RE_STYLE);
            if (innerMatch != null) {
                var style = innerMatch[1];
                propOut = StyleToProp(style);
                propOut._style = style;
                plainText = innerMatch[2];
            }
        }

        if (plainText == null) {
            plainText = text;
        }

        if (propOut == null) {
            propOut = {};
        }

        var result = GETPROP_RESULT$1;
        result.plainText = plainText;
        result.prop = propOut;
        return result;
    }

    propToContextStyle(defaultStyle, prop) {
        var result = STYLE_RESULT$1;
        if (!prop.hasOwnProperty('img')) {
            result.image = null;

            if (prop.hasOwnProperty('family') || prop.hasOwnProperty('fontFamily') || prop.hasOwnProperty('font-family')) {
                var family = (prop.hasOwnProperty('family')) ? prop.family :
                    (prop.hasOwnProperty('fontFamily')) ? prop.fontFamily :
                        prop['font-family'];
                result.fontFamily = family;
            } else {
                result.fontFamily = defaultStyle.fontFamily;
            }

            if (prop.hasOwnProperty('size') || prop.hasOwnProperty('fontSize') || prop.hasOwnProperty('font-size')) {
                var size = (prop.hasOwnProperty('size')) ? prop.size :
                    (prop.hasOwnProperty('fontSize')) ? prop.fontSize :
                        prop['font-size'];
                if (typeof (size) === 'number') {
                    size = `${size}px`;
                }
                result.fontSize = size;
            } else {
                result.fontSize = defaultStyle.fontSize;
            }

            if (prop.hasOwnProperty('style') || prop.hasOwnProperty('fontStyle') || prop.hasOwnProperty('font-style')) {
                var fontStyle = (prop.hasOwnProperty('style')) ? prop.style :
                    (prop.hasOwnProperty('fontStyle')) ? prop.fontStyle :
                        prop['font-style'];
                result.fontStyle = fontStyle;
            } else {
                result.fontStyle = defaultStyle.fontStyle;
            }

            if (prop.hasOwnProperty('color') || prop.hasOwnProperty('font-color')) {
                var color = (prop.hasOwnProperty('color')) ? prop.color : prop['font-color'];
                result.color = color;
            } else {
                result.color = defaultStyle.color;
            }

            if (prop.hasOwnProperty('stroke')) {
                var stroke = prop.stroke; // {color, thinkness}
                result.stroke = (stroke.hasOwnProperty('color')) ? stroke.color : defaultStyle.stroke;
                result.strokeThickness = (stroke.hasOwnProperty('thinkness')) ? stroke.thinkness : defaultStyle.strokeThickness;
            } else {
                result.stroke = defaultStyle.stroke;
                result.strokeThickness = defaultStyle.strokeThickness;
            }
        } else {
            result.image = prop.img;
        }

        if (prop.hasOwnProperty('shadow')) {
            var shadow = prop.shadow; // {color, offsetX, offsetY, blur}
            result.shadowColor = (shadow.hasOwnProperty('color')) ? shadow.color : defaultStyle.shadowColor;
            result.shadowOffsetX = (shadow.hasOwnProperty('offsetX')) ? shadow.offsetX : defaultStyle.shadowOffsetX;
            result.shadowOffsetY = (shadow.hasOwnProperty('offsetY')) ? shadow.offsetY : defaultStyle.shadowOffsetY;
            result.shadowBlur = (shadow.hasOwnProperty('blur')) ? shadow.blur : defaultStyle.shadowBlur;
            result.shadowStroke = true;
            result.shadowFill = true;
        } else {
            result.shadowColor = defaultStyle.shadowColor;
            result.shadowOffsetX = defaultStyle.shadowOffsetX;
            result.shadowOffsetY = defaultStyle.shadowOffsetY;
            result.shadowBlur = defaultStyle.shadowBlur;
            result.shadowStroke = defaultStyle.shadowStroke;
            result.shadowFill = defaultStyle.shadowFill;
        }

        if (prop.hasOwnProperty('u') || prop.hasOwnProperty('underline')) {
            var u = (prop.hasOwnProperty('u')) ? prop.u : prop.underline; // {color, thinkness, offset}
            result.underlineColor = (u.hasOwnProperty('color')) ? u.color : defaultStyle.underlineColor;
            result.underlineThickness = (u.hasOwnProperty('thinkness')) ? u.thinkness : defaultStyle.underlineThickness;
            result.underlineOffset = (u.hasOwnProperty('offset')) ? u.offset : defaultStyle.underlineOffset;
        } else {
            result.underlineColor = defaultStyle.underlineColor;
            result.underlineThickness = defaultStyle.underlineThickness;
            result.underlineOffset = defaultStyle.underlineOffset;
        }

        return result;
    }

    propToTagText(text, prop, prevProp) {
        if (prop.hasOwnProperty('_class')) { // class mode
            if (text === '') {
                if (this.isTextTag(prop._class)) {
                    return '';
                }
            }
            return `<class='${prop._class}'>${text}</class>`;
        } else if (prop.hasOwnProperty('_style')) { // class mode
            return `<style='${prop._style}'>${text}</style>`;
        } else {
            return text;
        }
    }

    destroy() {
        this.tags = undefined;
    }

    isTextTag(tagName) {
        var tag = this.tags[tagName];
        if (tag) {
            return (tag.img == null);
        } else { // tag not found
            return false;
        }
    }
}
var StyleToProp = function (s) {
    s = s.split(";");

    var result = {},
        prop, k, v;
    for (var i = 0, slen = s.length; i < slen; i++) {
        prop = s[i].split(":");
        k = prop[0], v = prop[1];
        if (isEmpty(k) || isEmpty(v)) {
            continue;
        }

        switch (k) {
            case 'stroke':
                var stroke = v.split(' '); // stroke:blue 1px
                var len = stroke.length;
                v = {};
                if (len >= 1) {
                    v.color = stroke[0];
                }
                if (len >= 2) {
                    v.thinkness = parseInt(stroke[1].replace('px', ''));
                }
                break;

            case 'shadow':
                var shadow = v.split(' '); // shadow:blue 2px 2px 2px
                var len = shadow.length;
                v = {};
                if (len >= 1) {
                    v.color = shadow[0];
                }
                if (len >= 2) {
                    v.offsetX = parseInt(shadow[1].replace('px', ''));
                }
                if (len >= 3) {
                    v.offsetY = parseInt(shadow[2].replace('px', ''));
                }
                if (len >= 4) {
                    v.blur = parseInt(shadow[3].replace('px', ''));
                }
                break;

            case 'u':
            case 'underline': // underline:blue 3px -1px
                var u = v.split(' ');
                var len = u.length;
                v = {};
                if (len >= 1) {
                    v.color = u[0];
                }
                if (len >= 2) {
                    v.thinkness = parseInt(u[1].replace('px', ''));
                }
                if (len >= 3) {
                    v.offset = parseInt(u[2].replace('px', ''));
                }
                break;

            case 'y':
                v = parseFloat(v);
                break;
        }
        result[k] = v;
    }
    return result;
};

var isEmpty = function (s) {
    // Remove white spaces.
    s = s.replace(RE_SPACE, '');
    return (s.length === 0);
};

var RE_SPLITTEXT$1 = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>|<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/g;
var RE_CLASS_HEADER = /<\s*class=/i;
var RE_CLASS = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>/;
var RE_STYLE_HEADER = /<\s*style=/i;
var RE_STYLE = /<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/;
var RE_SPACE = /^\s+|\s+$/;

const GetValue$a = Phaser.Utils.Objects.GetValue;

class TagText extends Text {
    constructor(scene, x, y, text, style) {
        var tags = GetValue$a(style, 'tags', undefined);
        var parser = new parser$1(tags);
        super(scene, x, y, text, style, 'rexTagText', parser);
        this.parser = parser;
    }

    addTag(name, prop) {
        this.parser.addTag(name, prop);
        return this.updateText(true);
    }

    addTags(tags) {
        for(var name in tags){
            this.parser.addTag(name, tags[name]);
        }
        return this.updateText(true);
    }

    preDestroy() {
        super.preDestroy();
        this.parser.destroy();
        this.parser = undefined;
    }
}

const Zone = Phaser.GameObjects.Zone;
const AddItem = Phaser.Utils.Array.Add;
const RemoveItem = Phaser.Utils.Array.Remove;

class Base extends Zone {
    constructor(scene, x, y, width, height) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }
        if (width === undefined) {
            width = 1;
        }
        if (height === undefined) {
            height = 1;
        }
        super(scene, x, y, width, height);
        this.children = [];
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        if (fromScene) {
            // Stop scene
            var child;
            for (var i = this.children.length - 1; i >= 0; i--) {
                child = this.children[i];
                if (!child.parentContainer &&  // Not in container
                    !child.displayList         // Not in scene, neither in layer
                ) {
                    // Destroy child which is not in scene, container, or layer manually
                    child.destroy(fromScene);
                }
            }
        }

        // Destroy/remove children
        this.clear(!fromScene);
        super.destroy(fromScene);
    }

    contains(gameObject) {
        return (this.children.indexOf(gameObject) !== -1);
    }

    add(gameObjects) {
        var parent = this;
        AddItem(this.children, gameObjects, 0,
            // Callback of item added
            function (gameObject) {
                gameObject.once('destroy', parent.onChildDestroy, parent);
            }, this);
        return this;
    }

    remove(gameObjects, destroyChild) {
        var parent = this;
        RemoveItem(this.children, gameObjects,
            // Callback of item removed
            function (gameObject) {
                gameObject.off('destroy', parent.onChildDestroy, parent);
                if (destroyChild) {
                    gameObject.destroy();
                }
            }
        );
        return this;
    }

    onChildDestroy(child, fromScene) {
        // Only remove reference
        this.remove(child, false);
    }

    clear(destroyChild) {
        var parent = this;
        var gameObject;
        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
            gameObject = this.children[i];
            gameObject.off('destroy', parent.onChildDestroy, parent);
            if (destroyChild) {
                gameObject.destroy();
            }
        }
        this.children.length = 0;
        return this;
    }
}

const Components$2 = Phaser.GameObjects.Components;
Phaser.Class.mixin(Base,
    [
        Components$2.Alpha,
        Components$2.Flip
    ]
);

var GetParent = function (gameObject) {
    var parent;
    if (gameObject.hasOwnProperty('rexContainer')) {
        parent = gameObject.rexContainer.parent;
    }
    return parent;
};

var GetTopmostParent = function (gameObject) {
    var parent = GetParent(gameObject);
    while (parent) {
        gameObject = parent;
        parent = GetParent(parent);
    }
    return gameObject;
};

const DegToRad$2 = Phaser.Math.DegToRad;
const RadToDeg = Phaser.Math.RadToDeg;

var GetLocalState = function (gameObject) {
    if (!gameObject.hasOwnProperty('rexContainer')) {
        var rexContainer = {
            parent: null, self: null,
            x: 0, y: 0,
            rotation: 0,
            scaleX: 0, scaleY: 0,
            alpha: 0,
            visible: true,
            active: true,
        };

        Object.defineProperty(rexContainer, 'angle', {
            get: function () {
                return RadToDeg(this.rotation);
            },
            set: function (value) {
                this.rotation = DegToRad$2(value);
            }
        });
        Object.defineProperty(rexContainer, 'displayWidth', {
            get: function () {
                return gameObject.width * this.scaleX;
            },
            set: function (width) {
                this.scaleX = width / gameObject.width;
            }
        });
        Object.defineProperty(rexContainer, 'displayHeight', {
            get: function () {
                return gameObject.height * this.scaleY;
            },
            set: function (height) {
                this.scaleY = height / gameObject.height;
            }
        });

        gameObject.rexContainer = rexContainer;
    }
    return gameObject.rexContainer;
};

var Parent = {
    setParent(gameObject, parent) {
        if (parent === undefined) {
            parent = this;
        }
        var localState = GetLocalState(gameObject);
        if (parent) { // Add to parent
            localState.parent = parent;
            localState.self = gameObject;
        } else { // Remove from parent
            localState.parent = null;
            localState.self = null;
        }
        return this;
    },

    getParent(gameObject) {
        if (gameObject === undefined) {
            gameObject = this;
        }
        return GetParent(gameObject);
    },

    getTopmostParent(gameObject) {
        if (gameObject === undefined) {
            gameObject = this;
        }
        return GetTopmostParent(gameObject);
    }
};

const BaseAdd = Base.prototype.add;

var Add = function (gameObject) {
    this.setParent(gameObject);
    this
        .resetChildState(gameObject)           // Reset local state of child
        .updateChildVisible(gameObject)        // Apply parent's visible to child
        .updateChildActive(gameObject)         // Apply parent's active to child
        .updateChildScrollFactor(gameObject)   // Apply parent's scroll factor to child
        .updateChildMask(gameObject);          // Apply parent's mask to child

    BaseAdd.call(this, gameObject);
    return this;
};

var AddLocal = function (gameObject) {
    this.setParent(gameObject);

    // Set local state from child directly
    var state = GetLocalState(gameObject);
    // Position
    state.x = gameObject.x;
    state.y = gameObject.y;
    state.rotation = gameObject.rotation;
    state.scaleX = gameObject.scaleX;
    state.scaleY = gameObject.scaleY;
    // Alpha
    state.alpha = gameObject.alpha;
    // Visible
    state.visible = gameObject.visible;
    // Active
    state.active = gameObject.active;

    this
        .updateChildPosition(gameObject)
        .updateChildAlpha(gameObject)
        .updateChildVisible(gameObject)        // Apply parent's visible to child
        .updateChildActive(gameObject)         // Apply parent's active to child
        .updateChildScrollFactor(gameObject)   // Apply parent's scroll factor to child
        .updateChildMask(gameObject);          // Apply parent's mask to child

    BaseAdd.call(this, gameObject);
    return this;
};

var AddChild = {
    add(gameObject) {
        if (Array.isArray(gameObject)) {
            this.addMultiple(gameObject);
        } else {
            Add.call(this, gameObject);
        }
        return this;
    },

    addMultiple(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            Add.call(this, gameObjects[i]);
        }
        return this;
    },

    addLocal(gameObject) {
        if (Array.isArray(gameObject)) {
            this.addMultiple(gameObject);
        } else {
            AddLocal.call(this, gameObject);
        }
        return this;
    },

    addLocalMultiple(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            AddLocal.call(this, gameObjects[i]);
        }
        return this;
    }
};

const BaseRemove = Base.prototype.remove;
const BaseClear = Base.prototype.clear;

var RemoveChild = {
    remove(gameObject, destroyChild) {
        if (GetParent(gameObject) !== this) {
            return this;
        }
        this.setParent(gameObject, null);
        BaseRemove.call(this, gameObject, destroyChild);
        return this;
    },

    clear(destroyChild) {
        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
            this.setParent(this.children[i], null);
        }
        BaseClear.call(this, destroyChild);
        return this;
    },
};

var ChildState = {
    getLocalState(gameObject) {
        return GetLocalState(gameObject);
    },

    resetChildState(gameObject) {
        this
            .resetChildPositionState(gameObject)
            .resetChildVisibleState(gameObject)
            .resetChildAlphaState(gameObject)
            .resetChildActiveState(gameObject);
        return this;
    },

    resetChildrenState(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            this.resetChildState(gameObjects[i]);
        }
        return this;
    },

    syncProperties() {
        this
            .syncPosition()
            .syncVisible()
            .syncAlpha()
            .syncActive()
            .syncScrollFactor()
            .syncMask();
        return this;
    }
};

const RotateAround = Phaser.Math.RotateAround;

var Transform = {
    worldToLocal(point) {
        // Transform
        point.x -= this.x;
        point.y -= this.y;
        // Rotate
        RotateAround(point, 0, 0, -this.rotation);
        // Scale
        point.x /= this.scaleX;
        point.y /= this.scaleY;
        return point;
    },

    localToWorld(point) {
        // Scale
        point.x *= this.scaleX;
        point.y *= this.scaleY;
        // Rotate
        RotateAround(point, 0, 0, this.rotation);
        // Transform
        point.x += this.x;
        point.y += this.y;
        return point;
    }
};

var GetScale = function (a, b) {
    if (a === b) {
        return 1;
    } else {
        return a / b;
    }
};

var Position = {
    updateChildPosition(child) {
        if (child.isRexContainerLite) {
            child.syncChildrenEnable = false;
        }
        var state = GetLocalState(child);
        var parent = state.parent;
        child.x = state.x;
        child.y = state.y;
        parent.localToWorld(child);

        child.scaleX = state.scaleX * parent.scaleX;
        child.scaleY = state.scaleY * parent.scaleY;

        child.rotation = state.rotation + parent.rotation;

        if (child.isRexContainerLite) {
            child.syncChildrenEnable = true;
            child.syncPosition();
        }
        return this;
    },

    syncPosition() {
        if (this.syncChildrenEnable) {
            this.children.forEach(this.updateChildPosition, this);
        }
        return this;
    },

    resetChildPositionState(child) {
        var state = GetLocalState(child);
        var parent = state.parent;
        state.x = child.x;
        state.y = child.y;
        parent.worldToLocal(state);

        state.scaleX = GetScale(child.scaleX, parent.scaleX);
        state.scaleY = GetScale(child.scaleY, parent.scaleY);

        state.rotation = child.rotation - parent.rotation;
        return this;
    },

    setChildPosition(child, x, y) {
        child.x = x;
        child.y = y;
        this.resetChildPositionState(child);
        return this;
    },

    setChildLocalPosition(child, x, y) {
        var state = GetLocalState(child);
        state.x = x;
        state.y = y;
        this.updateChildPosition(child);
        return this;
    },

    resetLocalPositionState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
            parent.resetChildPositionState(this);
        }
        return this;
    }
};

var Rotation = {
    updateChildRotation(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        child.rotation = parent.rotation + localState.rotation;
        return this;
    },

    syncRotation() {
        if (this.syncChildrenEnable) {
            this.children.forEach(this.updateChildRotation, this);
        }
        return this;
    },

    resetChildRotationState(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        localState.rotation = child.rotation - parent.rotation;
        return this;
    },

    setChildRotation(child, rotation) {
        child.rotation = rotation;
        this.resetChildRotationState(child);
        return this;
    },

    setChildAngle(child, angle) {
        child.angle = angle;
        this.resetChildRotationState(child);
        return this;
    },

    setChildLocalRotation(child, rotation) {
        var localState = GetLocalState(child);
        localState.rotation = rotation;
        this.updateChildRotation(child);
        return this;
    },

    resetLocalRotationState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
            parent.resetChildRotationState(this);
        }
        return this;
    },
};

var Scale = {
    updateChildScale(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        child.scaleX = parent.scaleX * localState.scaleX;
        child.scaleY = parent.scaleY * localState.scaleY;
        return this;
    },

    syncScale() {
        if (this.syncChildrenEnable) {
            this.children.forEach(this.updateChildScale, this);
        }
        return this;
    },

    resetChildScaleState(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        localState.scaleX = GetScale(child.scaleX, parent.scaleX);
        localState.scaleY = GetScale(child.scaleY, parent.scaleY);
        return this;
    },

    setChildScale(child, scaleX, scaleY) {
        if (scaleY === undefined) {
            scaleY = scaleX;
        }
        child.scaleX = scaleX;
        child.scaleY = scaleY;
        this.resetChildScaleState(child);
        return this;
    },

    setChildLocalScale(child, scaleX, scaleY) {
        if (scaleY === undefined) {
            scaleY = scaleX;
        }
        var localState = GetLocalState(child);
        localState.scaleX = scaleX;
        localState.scaleY = scaleY;
        this.updateChildScale(child);
        return this;
    },

    setChildDisplaySize(child, width, height) {
        child.setDisplaySize(width, height);
        this.resetChildScaleState(child);
        return this;
    },

    resetLocalScaleState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
            parent.resetChildScaleState(this);
        }
        return this;
    },
};

/*

Visible in localState:

  - visible: original visible of child
  - maskVisible: invisible by parent mask, see MaskChildren.js
      - undefined (not in masking) : Equal to mask visible
      - true (mask visible) : Inside, or across parent's visible area
      - false (maske invisible) : Out of parent's visible area

Visible result of child = (parent visible) && (child visible) && (mask visible)
*/

var Visible = {
    updateChildVisible(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        var maskVisible = (localState.hasOwnProperty('maskVisible')) ? localState.maskVisible : true;
        child.visible = parent.visible && localState.visible && maskVisible;
        return this;
    },

    syncVisible() {
        if (this.syncChildrenEnable) {
            this.children.forEach(this.updateChildVisible, this);
        }
        return this;
    },

    resetChildVisibleState(child) {
        var localState = GetLocalState(child);
        // Delete maskVisible property
        if (localState.hasOwnProperty('maskVisible')) {
            delete localState.maskVisible;
        }
        localState.visible = child.visible;
        return this;
    },

    setChildVisible(child, visible) {
        // Visible of child will be affect by parent's visible, and mask visible
        this.setChildLocalVisible(child, visible);
        return this;
    },

    // Internal method
    setChildLocalVisible(child, visible) {
        if (visible === undefined) {
            visible = true;
        }
        var localState = GetLocalState(child);
        localState.visible = visible;
        this.updateChildVisible(child);
        return this;
    },

    // Internal method
    setChildMaskVisible(child, visible) {
        if (visible === undefined) {
            visible = true;
        }
        var localState = GetLocalState(child);
        localState.maskVisible = visible;
        this.updateChildVisible(child);
        return this;
    },

    resetLocalVisibleState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
            parent.resetChildVisibleState(this);
        }
        return this;
    }
};

var Alpha = {
    updateChildAlpha(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        child.alpha = parent.alpha * localState.alpha;
        return this;
    },

    syncAlpha() {
        if (this.syncChildrenEnable) {
            this.children.forEach(this.updateChildAlpha, this);
        }
        return this;
    },

    resetChildAlphaState(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        localState.alpha = GetScale(child.alpha, parent.alpha);
        return this;
    },

    setChildAlpha(child, alpha) {
        child.alpha = alpha;
        this.resetChildAlphaState(child);
        return this;
    },

    setChildLocalAlpha(child, alpha) {
        var localState = GetLocalState(child);
        localState.alpha = alpha;
        this.updateChildAlpha(child);
        return this;
    },

    resetLocalAlphaState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
            parent.resetChildAlphaState(this);
        }
        return this;
    }
};

var Active = {
    updateChildActive(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        child.active = parent.active && localState.active;
        return this;
    },

    syncActive() {
        if (this.syncChildrenEnable) {
            this.children.forEach(this.updateChildActive, this);
        }
        return this;
    },
    
    resetChildActiveState(child) {
        var localState = GetLocalState(child);
        localState.active = child.active;
        return this;
    },

    setChildActive(child, active) {
        child.active = active;
        this.resetChildActiveState(child);
        return this;
    },

    setChildLocalActive(child, active) {
        if (active === undefined) {
            active = true;
        }
        var localState = GetLocalState(child);
        localState.active = active;
        this.updateChildActive(child);
        return this;
    },

    resetLocalActiveState() {
        var parent = GetLocalState(this).parent;
        if (parent) {
            parent.resetChildActiveState(this);
        }
        return this;
    }
};

var ScrollFactor = {
    updateChildScrollFactor(child) {
        var localState = GetLocalState(child);
        var parent = localState.parent;
        child.setScrollFactor(parent.scrollFactorX, parent.scrollFactorY);
        return this;
    },

    syncScrollFactor() {
        if (this.syncChildrenEnable) {
            this.children.forEach(this.updateChildScrollFactor, this);
        }
        return this;
    },

};

var Mask = {
    updateChildMask(child) {
        // Don't propagate null mask to clear children's mask
        if (this.mask == null) {
            return this;
        }

        var maskGameObject = (this.mask.hasOwnProperty('geometryMask')) ? this.mask.geometryMask : this.mask.bitmapMask;
        if (maskGameObject !== child) {
            child.mask = this.mask;
        }
        return this;
    },

    syncMask() {
        if (this.syncChildrenEnable) {
            this.children.forEach(this.updateChildMask, this);
        }
        return this;
    },

    setMask(mask) {
        this.mask = mask;
        return this;
    },

    clearMask(destroyMask) {
        if (destroyMask === undefined) {
            destroyMask = false;
        }

        if (destroyMask && this.mask) {
            this.mask.destroy();
        }
        this.mask = null;
        return this;
    },
};

var SortGameObjectsByDepth = function (gameObjects, descending) {
    if (gameObjects.length === 0) {
        return gameObjects;
    }

    if (descending === undefined) {
        descending = false;
    }

    var scene = gameObjects[0].scene;
    var displayList = scene.sys.displayList;
    displayList.depthSort();

    if (descending) {
        gameObjects.sort(function (childA, childB) {
            return displayList.getIndex(childB) - displayList.getIndex(childA);
        });
    } else {
        gameObjects.sort(function (childA, childB) {
            return displayList.getIndex(childA) - displayList.getIndex(childB);
        });
    }

    return gameObjects;
};

var Depth = {
    setDepth(value, containerOnly) {
        this.depth = value;
        if (!containerOnly && this.children) {
            var children = this.getAllChildren();
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].depth = value;
            }
        }
        return this;
    },

    swapDepth(containerB) {
        var depthA = this.depth;
        var depthB = containerB.depth;
        this.setDepth(depthB);
        containerB.setDepth(depthA);
        return this;
    },

    incDepth(inc) {
        this.depth += inc;
        if (this.children) {
            var children = this.getAllChildren();
            for (var i = 0, cnt = children.length; i < cnt; i++) {
                children[i].depth += inc;
            }
        }
        return this;
    },

    moveDepthBelow(gameObject) {
        var displayList = gameObject.scene.children;
        var children = this.getAllChildren([this]);
        SortGameObjectsByDepth(children);
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (displayList.exists(child)) {
                displayList.moveBelow(gameObject, child);
                break;
            }
        }
        return this;
    },

    moveDepthAbove(gameObject) {
        var displayList = gameObject.scene.children;
        var children = this.getAllChildren([this]);
        SortGameObjectsByDepth(children, true);
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];
            if (displayList.exists(child)) {
                displayList.moveAbove(gameObject, child);
                break;
            }
        }
        return this;
    },
};

const ArrayUtils = Phaser.Utils.Array;

var Children = {
    getChildren(out) {
        if (!out) {
            out = this.children; // Return internal children array
        } else {
            for (var i = 0, cnt = this.children.length; i < cnt; i++) {
                out.push(this.children[i]);
            }
            // Copy children
        }
        return out;
    },

    getAllChildren(out) {
        if (out === undefined) {
            out = [];
        }
        var children = this.children,
            child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            out.push(child);

            if (child.hasOwnProperty('isRexContainerLite')) {
                out.push(...child.getAllChildren());
            }
        }

        return out;
    },

    getAllVisibleChildren(out) {
        if (out === undefined) {
            out = [];
        }
        var children = this.children,
            child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (!child.visible) {
                continue;
            }
            out.push(child);

            if (child.hasOwnProperty('isRexContainerLite')) {
                out.push(...child.getAllVisibleChildren());
            }
        }

        return out;
    },

    contains(gameObject) { // Override Base.contains method
        var parent = GetParent(gameObject);
        if (!parent) {
            return false;
        } else if (parent === this) {
            return true;
        } else {
            return this.contains(parent);
        }
    },

    getByName(name, recursive) {
        if (!recursive) {
            return ArrayUtils.GetFirst(this.children, 'name', name); // object, or null if not found

        } else { // recursive
            // Breadth-first search
            var queue = [this];
            var parent, child;
            while (queue.length) {
                parent = queue.shift();

                for (var i = 0, cnt = parent.children.length; i < cnt; i++) {
                    child = parent.children[i];
                    if (child.name === name) {
                        return child;
                    } else if (child.isRexContainerLite) {
                        queue.push(child);
                    }
                }
            }
            return null;

        }

    },

    getRandom(startIndex, length) {
        return ArrayUtils.GetRandom(this.children, startIndex, length);
    },

    getFirst(property, value, startIndex, endIndex) {
        return ArrayUtils.GetFirstElement(this.children, property, value, startIndex, endIndex);
    },

    getAll(property, value, startIndex, endIndex) {
        return ArrayUtils.GetAll(this.children, property, value, startIndex, endIndex);
    },

    count(property, value, startIndex, endIndex) {
        return ArrayUtils.CountAllMatching(this.children, property, value, startIndex, endIndex);
    },

    swap(child1, child2) {
        ArrayUtils.Swap(this.children, child1, child2);
        return this;
    },

    setAll(property, value, startIndex, endIndex) {
        ArrayUtils.SetAll(this.children, property, value, startIndex, endIndex);
        return this;
    },
};

var IsArray = function(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
};

var Tween = {
    tweenChild(tweenConfig) {
        var targets = tweenConfig.targets;
        if (!IsArray(targets)) {
            targets = [targets];
        }

        var scene, localTargets = [];
        var child;
        for (var i = 0, cnt = targets.length; i < cnt; i++) {
            child = targets[i];
            if (!child.hasOwnProperty('rexContainer')) {
                continue;
            }
            scene = child.scene;
            localTargets.push(child.rexContainer);
        }

        if (!scene) {
            return;
        }

        tweenConfig.targets = localTargets;
        var tween = scene.tweens.add(tweenConfig);
        var tweenUpdateListener = function (tween, key, target) {
            if (!target.parent) {
                // target object was removed, so remove this tween too to avoid crashing
                scene.tweens.remove(tween);
                return;
            }
            var parent = target.parent;
            var child = target.self;
            switch (key) {
                case 'x':
                case 'y':
                    parent.updateChildPosition(child);
                    break;
                case 'angle':
                case 'rotation':
                    parent.updateChildRotation(child);
                    break;
                case 'scaleX':
                case 'scaleY':
                case 'displayWidth':
                case 'displayHeight':
                    parent.updateChildScale(child);
                    break;
                case 'alpha':
                    parent.updateChildAlpha(child);
                    break;
            }
        };
        tween.on('update', tweenUpdateListener);

        return tween;
    },

    tween(tweenConfig) {
        var scene = this.scene;
        if (!tweenConfig.targets) {
            tweenConfig.targets = this;
        }
        return scene.tweens.add(tweenConfig);
    }
};

var AddToLayer = function (layer) {
    var gameObjects = this.getAllChildren([this]);
    SortGameObjectsByDepth(gameObjects);
    layer.add(gameObjects);
    return this;
};

var AddToContainer = {
    addToLayer: AddToLayer,
    addToContainer: AddToLayer,
};

const RotateAround$1 = Phaser.Math.RotateAround;

var ChangeOrigin = function (gameObject, originX, originY) {
    if (originY === undefined) {
        originY = originX;
    }

    var deltaXY = {
        x: (originX - gameObject.originX) * gameObject.displayWidth,
        y: (originY - gameObject.originY) * gameObject.displayHeight
    };
    RotateAround$1(deltaXY, 0, 0, gameObject.rotation);

    gameObject.originX = originX;
    gameObject.originY = originY;
    gameObject.x = gameObject.x + deltaXY.x;
    gameObject.y = gameObject.y + deltaXY.y;

    return gameObject;
};

var ChangeOrigin$1 = function (originX, originY) {
    this.syncChildrenEnable = false;
    ChangeOrigin(this, originX, originY);
    this.syncChildrenEnable = true;

    var children = this.getAllChildren();
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        this.resetChildPositionState(children[i]);
    }
    return this;
};

var methods$2 = {
    changeOrigin: ChangeOrigin$1,
};

Object.assign(
    methods$2,
    Parent,
    AddChild,
    RemoveChild,
    ChildState,
    Transform,
    Position,
    Rotation,
    Scale,
    Visible,
    Alpha,
    Active,
    ScrollFactor,
    Mask,
    Depth,
    Children,
    Tween,
    AddToContainer
);

class ContainerLite extends Base {
    constructor(scene, x, y, width, height, children) {
        super(scene, x, y, width, height);
        this.type = 'rexContainerLite';
        this.isRexContainerLite = true;
        this.syncChildrenEnable = true;

        this._active = true;
        this._mask = null;
        this._scrollFactorX = 1;
        this._scrollFactorY = 1;

        if (children) {
            this.add(children);
        }
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        this.syncChildrenEnable = false; // Don't sync properties changing anymore
        super.destroy(fromScene);
    }

    resize(width, height) {
        this.setSize(width, height);
        return this;
    }

    get x() {
        return this._x;
    }

    set x(value) {
        if (this._x === value) {
            return;
        }
        this._x = value;

        this.syncPosition();
    }

    get y() {
        return this._y;
    }

    set y(value) {
        if (this._y === value) {
            return;
        }
        this._y = value;

        this.syncPosition();
    }

    // Override
    get rotation() {
        return super.rotation;
    }

    set rotation(value) {
        if (this.rotation === value) {
            return;
        }
        super.rotation = value;

        this.syncPosition();
    }

    // Override
    get scaleX() {
        return super.scaleX;
    }

    set scaleX(value) {
        if (this.scaleX === value) {
            return;
        }
        super.scaleX = value;

        this.syncPosition();
    }

    // Override
    get scaleY() {
        return super.scaleY;
    }

    set scaleY(value) {
        if (this.scaleY === value) {
            return;
        }
        super.scaleY = value;

        this.syncPosition();
    }

    // Override
    get visible() {
        return super.visible;
    }

    set visible(value) {
        if (super.visible === value) {
            return;
        }
        super.visible = value;

        this.syncVisible();
    }

    // Override
    get alpha() {
        return super.alpha;
    }

    set alpha(value) {
        if (super.alpha === value) {
            return;
        }
        super.alpha = value;

        this.syncAlpha();
    }

    // Override
    get active() {
        return this._active;
    }

    set active(value) {
        if (this._active === value) {
            return;
        }
        this._active = value;

        this.syncActive();
    }

    // Override
    get mask() {
        return this._mask;
    }
    set mask(mask) {
        if (this._mask === mask) {
            return;
        }
        this._mask = mask;

        this.syncMask();
    }

    // Override
    get scrollFactorX() {
        return this._scrollFactorX;
    }

    set scrollFactorX(value) {
        if (this._scrollFactorX === value) {
            return;
        }

        this._scrollFactorX = value;
        this.syncScrollFactor();
    }
    get scrollFactorY() {
        return this._scrollFactorY;
    }

    set scrollFactorY(value) {
        if (this._scrollFactorY === value) {
            return;
        }

        this._scrollFactorY = value;
        this.syncScrollFactor();
    }

    // Compatiable with container plugin
    get list() {
        return this.children;
    }

    static GetParent(child) {
        return GetParent(child);
    }
}

Object.assign(
    ContainerLite.prototype,
    methods$2
);

const GetValue$b = Phaser.Utils.Objects.GetValue;

class CircleMaskImage extends Canvas {
    constructor(scene, x, y, key, frame, config) {
        super(scene, x, y);

        this.type = 'rexCircleMaskImage';
        this.setTexture(key, frame, config);
    }

    setTexture(key, frame, config) {
        if (typeof (frame) === 'object') {
            config = frame;
            frame = undefined;
        }

        var maskType, backgroundColor;
        if (typeof (config) === 'string') {
            maskType = config;
            backgroundColor = undefined;
        } else {
            maskType = GetValue$b(config, 'maskType', 0);
            backgroundColor = GetValue$b(config, 'backgroundColor', undefined);
        }

        if (maskType === undefined) {
            maskType = 0;
        } else if (typeof (maskType) === 'string') {
            maskType = MASKTYPE[maskType];
        }

        this._textureKey = key;
        this._frameName = frame;

        if (maskType === null) {
            this.loadTexture(key, frame);
            this.dirty = true;
            return this;
        }

        var hasBackgroundColor = (backgroundColor != null);
        if (!hasBackgroundColor) { // No background color -- draw image first
            this.loadTexture(key, frame);
        }

        // Draw mask
        var canvas = this.canvas,
            ctx = this.context;
        var width = canvas.width,
            height = canvas.height;

        ctx.save();
        ctx.globalCompositeOperation = (hasBackgroundColor) ? 'source-over' : 'destination-in';
        ctx.beginPath();

        // Draw circle, ellipse, or roundRectangle
        switch (maskType) {
            case 2:
                var radiusConfig = GetValue$b(config, 'radius', 0);
                var iteration = GetValue$b(config, 'iteration', undefined);
                AddRoundRectanglePath(ctx, 0, 0, width, height, radiusConfig, iteration);
                break;

            default: // circle, ellipse
                var centerX = Math.floor(width / 2);
                var centerY = Math.floor(height / 2);
                if (maskType === 0) {
                    ctx.arc(centerX, centerY, Math.min(centerX, centerY), 0, (2 * Math.PI));
                } else {
                    ctx.ellipse(centerX, centerY, centerX, centerY, 0, 0, (2 * Math.PI));
                }
                break;
        }

        if (hasBackgroundColor) {
            ctx.fillStyle = backgroundColor;
        }
        ctx.fill();
        ctx.restore();

        if (hasBackgroundColor) {  // Has background color -- draw image last
            ctx.save();
            ctx.globalCompositeOperation = 'destination-atop';
            this.loadTexture(key, frame);
            ctx.restore();
        }

        this.dirty = true;
        return this;
    }
}

const MASKTYPE = {
    circle: 0,
    ellipse: 1,
    roundRectangle: 2
};

/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2019 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */

//  Source object
//  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
//  The default value to use if the key doesn't exist

/**
 * Retrieves a value from an object.
 *
 * @function Phaser.Utils.Objects.GetValue
 * @since 3.0.0
 *
 * @param {object} source - The object to retrieve the value from.
 * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.
 * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.
 *
 * @return {*} The value of the requested key.
 */
var GetValue$c = function (source, key, defaultValue)
{
    if (!source || typeof source === 'number')
    {
        return defaultValue;
    }
    else if (source.hasOwnProperty(key))
    {
        return source[key];
    }
    else if (key.indexOf('.') !== -1)
    {
        var keys = key.split('.');
        var parent = source;
        var value = defaultValue;

        //  Use for loop here so we can break early
        for (var i = 0; i < keys.length; i++)
        {
            if (parent.hasOwnProperty(keys[i]))
            {
                //  Yes it has a key property, let's carry on down
                value = parent[keys[i]];

                parent = parent[keys[i]];
            }
            else
            {
                //  Can't go any further, so reset to default
                value = defaultValue;
                break;
            }
        }

        return value;
    }
    else
    {
        return defaultValue;
    }
};

var DataMethods = {
    enableData() {
        if (this.data === undefined) {
            this.data = {};
        }
        return this;
    },

    getData(key, defaultValue) {
        this.enableData();
        return (key === undefined) ? this.data : GetValue$c(this.data, key, defaultValue);
    },

    setData(key, value) {
        this.enableData();
        if (arguments.length === 1) {
            var data = key;
            for (key in data) {
                this.data[key] = data[key];
            }
        } else {
            this.data[key] = value;
        }
        return this;
    },

    incData(key, inc, defaultValue) {
        if (defaultValue === undefined) {
            defaultValue = 0;
        }
        this.enableData();
        this.setData(key, this.getData(key, defaultValue) + inc);
        return this;
    },

    mulData(key, mul, defaultValue) {
        if (defaultValue === undefined) {
            defaultValue = 0;
        }
        this.enableData();
        this.setData(key, this.getData(key, defaultValue) * mul);
        return this;
    },

    clearData() {
        if (this.data) {
            Clear(this.data);
        }
        return this;
    },

    resetData(data) {
        this.clearData();

        if (data) {
            this.enableData();
            for (var key in data) {
                this.data[key] = data[key];
            }
        }
        return this;
    },

    cloneData() {
        if (this.data) {
            return Clone(this.data);
        } else {
            return {};
        }
    }
};

const DegToRad$3 = Phaser.Math.DegToRad;
const RadToDeg$1 = Phaser.Math.RadToDeg;
const GetValue$d = Phaser.Utils.Objects.GetValue;

class Base$1 {
    constructor(parent, type) {
        this.setParent(parent);
        this.type = type;

        this
            .setActive()
            .setVisible()
            .setAlpha(1)
            .setPosition(0, 0)
            .setRotation(0)
            .setScale(1, 1)
            .setLeftSpace(0)
            .setRightSpace(0)
            .setOrigin(0)
            .setDrawBelowCallback()
            .setDrawAboveCallback();

        this.originX = 0;
        this.offsetX = 0;  // Override
        this.offsetY = 0;  // Override
    }

    setParent(parent) {
        this.parent = parent;
        return this;
    }

    get scene() {
        return this.parent.scene;
    }

    get canvas() {
        return (this.parent) ? this.parent.canvas : null;
    }

    get context() {
        return (this.parent) ? this.parent.context : null;
    }

    setDirty(dirty) {
        if (dirty && this.parent) {
            this.parent.dirty = true;
        }
        return this;
    }

    get active() {
        return this._active;
    }

    set active(value) {
        this.setDirty(this._active != value);
        this._active = value;
    }

    setActive(active) {
        if (active === undefined) {
            active = true;
        }
        this.active = active;
        return this;
    }

    get visible() {
        return this._visible;
    }

    set visible(value) {
        this.setDirty(this._visible != value);
        this._visible = value;
    }

    setVisible(visible) {
        if (visible === undefined) {
            visible = true;
        }

        this.visible = visible;
        return this;
    }

    get alpha() {
        return this._alpha;
    }

    set alpha(value) {
        this.setDirty(this._alpha != value);
        this._alpha = value;
    }

    setAlpha(alpha) {
        this.alpha = alpha;
        return this;
    }

    get x() {
        return this._x;
    }

    set x(value) {
        this.setDirty(this._x != value);
        this._x = value;
    }

    setX(x) {
        this.x = x;
        return this;
    }

    get y() {
        return this._y;
    }

    set y(value) {
        this.setDirty(this._y != value);
        this._y = value;
    }

    setY(y) {
        this.y = y;
        return this;
    }

    setPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }

    get rotation() {
        return this._rotation;
    }

    set rotation(value) {
        this.setDirty(this._rotation != value);
        this._rotation = value;
    }

    setRotation(rotation) {
        this.rotation = rotation;
        return this;
    }

    get angle() {
        return RadToDeg$1(this._rotation);
    }

    set angle(value) {
        this.rotation = DegToRad$3(value);
    }

    setAngle(angle) {
        this.angle = angle;
        return this;
    }

    get scaleX() {
        return this._scaleX;
    }

    set scaleX(value) {
        this.setDirty(this._scaleX !== value);
        this._scaleX = value;
    }

    setScaleX(scaleX) {
        this.scaleX = scaleX;
        return this;
    }

    // Override
    get width() {
        return 0;
    }

    // Override
    set width(value) { }

    setWidth(width, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
        }
        this.width = width;

        if (keepAspectRatio) {
            this.scaleY = this.scaleX;
        }
        return this;
    }

    get leftSpace() {
        return this._leftSpace;
    }

    set leftSpace(value) {
        this.setDirty(this._leftSpace !== value);
        this._leftSpace = value;
    }

    setLeftSpace(value) {
        this.leftSpace = value;
        return this;
    }

    get rightSpace() {
        return this._rightSpace;
    }

    set rightSpace(value) {
        this.setDirty(this._rightSpace !== value);
        this._rightSpace = value;
    }

    setRightSpace(value) {
        this.rightSpace = value;
        return this;
    }

    get outerWidth() {
        return this.width + this.leftSpace + this.rightSpace;
    }

    get scaleY() {
        return this._scaleY;
    }

    set scaleY(value) {
        this.setDirty(this._scaleY !== value);
        this._scaleY = value;
    }

    setScaleY(scaleY) {
        this.scaleY = scaleY;
        return this;
    }

    // Override
    get height() {
        return 0;
    }

    // Override
    set height(value) { }

    setHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
        }
        this.height = height;

        if (keepAspectRatio) {
            this.scaleX = this.scaleY;
        }
        return this;
    }

    setScale(scaleX, scaleY) {
        if (scaleY === undefined) {
            scaleY = scaleX;
        }

        this.scaleX = scaleX;
        this.scaleY = scaleY;
        return this;
    }

    modifyPorperties(o) {
        if (!o) {
            return this;
        }

        if (o.hasOwnProperty('x')) {
            this.setX(o.x);
        }
        if (o.hasOwnProperty('y')) {
            this.setY(o.y);
        }

        if (o.hasOwnProperty('rotation')) {
            this.setRotation(o.rotation);
        } else if (o.hasOwnProperty('angle')) {
            this.setAngle(o.angle);
        }

        if (o.hasOwnProperty('alpha')) {
            this.setAlpha(o.alpha);
        }

        // ScaleX, ScaleY
        var width = GetValue$d(o, 'width', undefined);
        var height = GetValue$d(o, 'height', undefined);
        var scaleX = GetValue$d(o, 'scaleX', undefined);
        var scaleY = GetValue$d(o, 'scaleY', undefined);

        if (width !== undefined) {
            if ((height === undefined) && (scaleY === undefined)) {
                this.setWidth(width, true);
            } else {
                this.setWidth(width);
            }
        }
        if (height !== undefined) {
            if ((width === undefined) && (scaleX === undefined)) {
                this.setHeight(height, true);
            } else {
                this.setHeight(height);
            }
        }
        if ((scaleX !== undefined) && (width === undefined)) {
            this.setScaleX(scaleX);
        }
        if ((scaleY !== undefined) && (height === undefined)) {
            this.setScaleY(scaleY);
        }

        if (o.hasOwnProperty('leftSpace')) {
            this.setLeftSpace(o.leftSpace);
        }
        if (o.hasOwnProperty('rightSpace')) {
            this.setLeftSpace(o.rightSpace);
        }
        return this;
    }

    setOrigin(x) {
        this.originX = x;
        return this;
    }

    setDrawBelowCallback(callback) {
        this.drawBelowCallback = callback;
        return this;
    }

    setDrawAboveCallback(callback) {
        this.drawAboveCallback = callback;
        return this;
    }

    // Override
    onFree() {
        this
            .setParent()
            .setVisible()
            .setAlpha(1)
            .setPosition(0, 0)
            .setRotation(0)
            .setScale(1, 1)
            .setLeftSpace(0)
            .setRightSpace(0)
            .setOrigin(0)
            .setDrawBelowCallback()
            .setDrawAboveCallback();
    }

    // Override
    drawContent() { }

    // Override
    draw() {
        var context = this.context;
        context.save();

        var x = this.x + this.leftSpace + this.offsetX - (this.originX * this.width),
            y = this.y + this.offsetY;
        if (this.autoRound) {
            x = Math.round(x);
            y = Math.round(y);
        }

        context.translate(x, y);
        context.globalAlpha = this.alpha;
        context.scale(this.scaleX, this.scaleY);
        context.rotate(this.rotation);

        if (this.drawBelowCallback) {
            this.drawBelowCallback.call(this);
        }

        this.drawContent();

        if (this.drawAboveCallback) {
            this.drawAboveCallback.call(this);
        }

        context.restore();
    }
}

Object.assign(
    Base$1.prototype,
    DataMethods
);

const GetValue$e = Phaser.Utils.Objects.GetValue;

class Background extends Base$1 {
    constructor(parent, config) {
        super(parent, 'background');

        this.setColor(
            GetValue$e(config, 'color', null),
            GetValue$e(config, 'color2', null),
            GetValue$e(config, 'horizontalGradient', true)
        );

        this.setStroke(
            GetValue$e(config, 'stroke', null),
            GetValue$e(config, 'strokeThickness', 2)
        );

        this.setCornerRadius(
            GetValue$e(config, 'cornerRadius', 0),
            GetValue$e(config, 'cornerIteration', null)
        );
    }

    set color(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color != value);
        this._color = value;
    }

    get color() {
        return this._color;
    }

    set color2(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color2 != value);
        this._color2 = value;
    }

    get color2() {
        return this._color2;
    }

    set horizontalGradient(value) {
        this.setDirty(this._horizontalGradient != value);
        this._horizontalGradient = value;
    }

    get horizontalGradient() {
        return this._horizontalGradient;
    }

    setColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
            isHorizontalGradient = true;
        }

        this.color = color;
        this.color2 = color2;
        this.horizontalGradient = isHorizontalGradient;
        return this;
    }

    set stroke(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._stroke != value);
        this._stroke = value;
    }

    get stroke() {
        return this._stroke;
    }

    set strokeThickness(value) {
        this.setDirty(this._strokeThickness != value);
        this._strokeThickness = value;
    }

    get strokeThickness() {
        return this._strokeThickness;
    }

    setStroke(color, lineWidth) {
        this.stroke = color;
        this.strokeThickness = lineWidth;
        return this;
    }

    set cornerRadius(value) {
        this.setDirty(this._cornerRadius != value);
        this._cornerRadius = value;
    }

    get cornerRadius() {
        return this._cornerRadius;
    }

    set cornerIteration(value) {
        this.setDirty(this._cornerIteration != value);
        this._cornerIteration = value;
    }

    get cornerIteration() {
        return this._cornerIteration;
    }

    setCornerRadius(radius, iteration) {
        this.cornerRadius = radius;
        this.cornerIteration = iteration;
        return this;
    }

    drawContent() {
        DrawRoundRectangleBackground(
            this.parent,
            this.color,
            this.stroke,
            this.strokeThickness,
            this.cornerRadius,
            this.color2,
            this.horizontalGradient,
            this.cornerIteration
        );
    }
}

const GetValue$f = Phaser.Utils.Objects.GetValue;

class InnerBounds extends Base$1 {
    constructor(parent, config) {
        super(parent, 'background');

        this.setColor(
            GetValue$f(config, 'color', null),
            GetValue$f(config, 'color2', null),
            GetValue$f(config, 'horizontalGradient', true)
        );

        this.setStroke(
            GetValue$f(config, 'stroke', null),
            GetValue$f(config, 'strokeThickness', 2)
        );
    }

    set color(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color != value);
        this._color = value;
    }

    get color() {
        return this._color;
    }

    set color2(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color2 != value);
        this._color2 = value;
    }

    get color2() {
        return this._color2;
    }

    set horizontalGradient(value) {
        this.setDirty(this._horizontalGradient != value);
        this._horizontalGradient = value;
    }

    get horizontalGradient() {
        return this._horizontalGradient;
    }

    setColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
            isHorizontalGradient = true;
        }

        this.color = color;
        this.color2 = color2;
        this.horizontalGradient = isHorizontalGradient;
        return this;
    }

    set stroke(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._stroke != value);
        this._stroke = value;
    }

    get stroke() {
        return this._stroke;
    }

    set strokeThickness(value) {
        this.setDirty(this._strokeThickness != value);
        this._strokeThickness = value;
    }

    get strokeThickness() {
        return this._strokeThickness;
    }

    setStroke(color, lineWidth) {
        this.stroke = color;
        this.strokeThickness = lineWidth;
        return this;
    }

    drawContent() {
        var padding = this.parent.padding;
        var x = padding.left,
            y = padding.top,
            width = this.parent.width - padding.left - padding.right,
            height = this.parent.height - padding.top - padding.bottom;
        var context = this.context;
        if (this.color != null) {
            var fillStyle;
            if (this.color2 != null) {
                var grd;
                if (this.horizontalGradient) {
                    grd = context.createLinearGradient(0, 0, width, 0);
                } else {
                    grd = context.createLinearGradient(0, 0, 0, height);
                }
                grd.addColorStop(0, this.color);
                grd.addColorStop(1, this.color2);
                fillStyle = grd;
            } else {
                fillStyle = this.color;
            }

            context.fillStyle = fillStyle;
            context.fillRect(x, y, width, height);
        }

        if ((this.stroke != null) && (this.strokeThickness > 0)) {
            context.strokeStyle = this.stroke;
            context.lineWidth = this.strokeThickness;
            context.strokeRect(x, y, width, height);
        }
    }
}

var GetProperty = function (name, config, defaultConfig) {
    if (config.hasOwnProperty(name)) {
        return config[name];
    } else {
        return defaultConfig[name];
    }
};

const GetValue$g = Phaser.Utils.Objects.GetValue;

class TextStyle$1 {
    constructor(config) {
        this.set(config);
    }

    toJSON() {
        return {
            bold: this.bold,
            italic: this.italic,
            fontSize: this.fontSize,
            fontFamily: this.fontFamily,
            color: this.color,
            stroke: this.stroke,
            strokeThickness: this.strokeThickness,
            shaodwColor: this.shadowColor,
            shadowBlur: this.shadowBlur,
            shadowOffsetX: this.shadowOffsetX,
            shadowOffsetY: this.shadowOffsetY,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
        }
    }

    set(o) {
        this.setBold(GetValue$g(o, 'bold', false));
        this.setItalic(GetValue$g(o, 'italic', false));
        this.setFontSize(GetValue$g(o, 'fontSize', '16px'));
        this.setFontFamily(GetValue$g(o, 'fontFamily', 'Courier'));
        this.setColor(GetValue$g(o, 'color', '#fff'));
        this.setStrokeStyle(
            GetValue$g(o, 'stroke', null),
            GetValue$g(o, 'strokeThickness', 0)
        );
        this.setShadow(
            GetValue$g(o, 'shadowColor', null),
            GetValue$g(o, 'shadowOffsetX', 0),
            GetValue$g(o, 'shadowOffsetY', 0),
            GetValue$g(o, 'shadowBlur', 0)
        );
        this.setOffset(
            GetValue$g(o, 'offsetX', 0),
            GetValue$g(o, 'offsetY', 0)
        );
    }

    modify(o) {
        if (o.hasOwnProperty('bold')) {
            this.setBold(o.bold);
        }
        if (o.hasOwnProperty('italic')) {
            this.setItalic(o.italic);
        }
        if (o.hasOwnProperty('fontSize')) {
            this.setFontSize(o.fontSize);
        }
        if (o.hasOwnProperty('fontFamily')) {
            this.setFontFamily(o.fontFamily);
        }
        if (o.hasOwnProperty('color')) {
            this.setColor(o.color);
        }
        if (o.hasOwnProperty('stroke') || o.hasOwnProperty('strokeThickness')) {
            this.setStrokeStyle(
                GetProperty('stroke', o, this),
                GetProperty('strokeThickness', o, this)
            );
        }

        if (o.hasOwnProperty('shadowColor')) {
            this.setShadowColor(o.shadowColor);
        }

        if (o.hasOwnProperty('shadowOffsetX') || o.hasOwnProperty('shadowOffsetY')) {
            this.setShadowOffset(
                GetProperty('shadowOffsetX', o, this),
                GetProperty('shadowOffsetY', o, this),
            );
        }

        if (o.hasOwnProperty('shadowBlur')) {
            this.setShadowBlur(o.shaodwBlur);
        }

        if (o.hasOwnProperty('offsetX')) {
            this.setOffsetX(o.offsetX);
        }
        if (o.hasOwnProperty('offsetY')) {
            this.setOffsetY(o.offsetY);
        }

        return this;
    }

    setBold(value) {
        if (value === undefined) {
            value = true;
        }
        this.bold = value;
        return this;
    }

    setItalic(value) {
        if (value === undefined) {
            value = true;
        }
        this.italic = value;
        return this;
    }

    get fontStyle() {
        if (this.bold && this.italic) {
            return 'bold italic';
        } else if (this.bold) {
            return 'bold';
        } else if (this.italic) {
            return 'italic';
        } else {
            return '';
        }
    }

    setFontSize(fontSize) {
        if (typeof (fontSize) === 'number') {
            fontSize = `${fontSize}px`;
        }
        this.fontSize = fontSize;
        return this;
    }

    setFontFamily(fontFamily) {
        this.fontFamily = fontFamily;
        return this;
    }

    get font() {
        return `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`;
    }

    setColor(color) {
        this.color = GetStyle(color);
        return this;
    }

    get hasFill() {
        return this.color != null;
    }

    setStrokeStyle(stroke, strokeThickness) {
        this.stroke = GetStyle(stroke);
        if (strokeThickness !== undefined) {
            this.strokeThickness = strokeThickness;
        }
        return this;
    }

    setStrokeThickness(strokeThickness) {
        this.strokeThickness = strokeThickness;
        return this;
    }

    get hasStroke() {
        return (this.stroke != null) && (this.strokeThickness > 0);
    }

    setShadowColor(color) {
        this.shadowColor = GetStyle(color);
        return this;
    }

    setShadowOffset(offsetX, offsetY) {
        if (offsetX === undefined) {
            offsetX = 0;
        }
        if (offsetY === undefined) {
            offsetY = 0;
        }

        this.shadowOffsetX = offsetX;
        this.shadowOffsetY = offsetY;
        return this;
    }

    setShadowBlur(blur) {
        if (blur === undefined) {
            blur = 0;
        }

        this.shaodwBlur = blur;
        return this;
    }

    setShadow(color, offsetX, offsetY, blur) {
        this
            .setShadowColor(color)
            .setShadowOffset(offsetX, offsetY)
            .setShadowBlur(blur);
        return this;
    }

    setOffsetX(offsetX) {
        if (offsetX === undefined) {
            offsetX = 0;
        }

        this.offsetX = offsetX;
        return this;
    }

    setOffsetY(offsetY) {
        if (offsetY === undefined) {
            offsetY = 0;
        }

        this.offsetY = offsetY;
        return this;
    }

    setOffset(offsetX, offsetY) {
        this
            .setOffsetX(offsetX)
            .setOffsetY(offsetY);
        return this;
    }

    syncFont(context) {
        context.font = this.font;
        return this;
    }

    syncStyle(context) {
        context.textBaseline = 'alphabetic';

        var hasFill = this.hasFill;
        var hasStroke = this.hasStroke;
        context.fillStyle = (hasFill) ? this.color : '#000';

        context.strokeStyle = (hasStroke) ? this.stroke : '#000';
        context.lineWidth = (hasStroke) ? this.strokeThickness : 0;
        context.lineCap = 'round';
        context.lineJoin = 'round';

        return this;
    }

    syncShadow(context) {
        if (context.shadowColor != null) {
            context.shadowColor = this.shadowColor;
            context.shadowOffsetX = this.shadowOffsetX;
            context.shadowOffsetY = this.shadowOffsetY;
            context.shadowBlur = this.shadowBlur;
        } else {
            context.shadowColor = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
            context.shadowBlur = 0;
        }
    }

    getTextMetrics(context, text) {
        this.syncFont(context).syncStyle(context);
        return context.measureText(text);
    }

}

const GetValue$h = Phaser.Utils.Objects.GetValue;

var GetPadding = function (padding, key) {
    if (key === undefined) {
        return padding;
    }
    return padding[key];
};

var SetPadding = function (padding, key, value) {
    var keyType = typeof (key);
    if (keyType === 'string') {
        padding[key] = value;
    } else if (keyType === 'number') {
        padding.left = key;
        padding.right = key;
        padding.top = key;
        padding.bottom = key;
    } else {
        padding.left = GetValue$h(key, 'left', 0);
        padding.right = GetValue$h(key, 'right', 0);
        padding.top = GetValue$h(key, 'top', 0);
        padding.bottom = GetValue$h(key, 'bottom', 0);
    }
};

var SetPadding$1 = function (key, value) {
    var padding = this.padding;
    var paddingLeft = padding.left,
        paddingRight = padding.right,
        paddingTop = padding.top,
        paddingBottom = padding.bottom;

    SetPadding(this.padding, key, value);

    this.dirty = this.dirty ||
        (paddingLeft != this.padding.left) ||
        (paddingRight != this.padding.right) ||
        (paddingTop != this.padding.top) ||
        (paddingBottom != this.padding.bottom)
        ;
    return this;
};

var GetPadding$1 = function (key) {
    return GetPadding(this.padding, key);
};

var ModifyTextStyle = function (style) {
    this.textStyle.modify(style);
    return this;
};

var RemoveChildren = function () {
    this.poolManager.freeMultiple(this.children);
    this.children.length = 0;
    this.lastAppendedChildren.length = 0;
    this.dirty = true;
    return this;
};

var ClearContent = function() {
    this.setText();
    return this;
};

const CharTypeName = 'text';
const ImageTypeName = 'image';
const CmdTypeName = 'command';

var IsTypeable = function (bob) {
    var bobType = bob.type;
    return (bobType === CharTypeName) || (bobType === ImageTypeName);
};

var IsNewLineChar = function (bob) {
    return (bob.type === CharTypeName) && (bob.text === '\n');
};

var IsCommand = function (bob) {
    return bob.type === CmdTypeName;
};

class CharData extends Base$1 {
    constructor(
        parent,
        text,
        style
    ) {
        super(parent, CharTypeName);
        this.style = new TextStyle$1(style);
        this.setText(text);
    }

    get autoRound() {
        return this.parent.autoRound;
    }

    get offsetX() {
        return this.style.offsetX;
    }

    set offsetX(value) { }

    get offsetY() {
        return this.style.offsetY;
    }

    set offsetY(value) { }

    modifyStyle(style) {
        this.setDirty(true);
        this.style.modify(style);
        return this;
    }

    modifyPorperties(o) {
        if (!o) {
            return this;
        }

        this.modifyStyle(o);
        super.modifyPorperties(o);
        return this;
    }

    setText(text) {
        this.setDirty(this.text != text);
        this.text = text;

        this.updateTextSize();

        return this;
    }

    updateTextSize() {
        if ((this.text === '\n') || (this.text === '')) {
            this.textWidth = 0;
            this.textHeight = 0;
        } else {
            var metrics = this.style.getTextMetrics(this.context, this.text);
            this.textWidth = metrics.width;

            var ascent, descent;
            if (metrics.hasOwnProperty('actualBoundingBoxAscent')) {
                ascent = metrics.actualBoundingBoxAscent;
                descent = metrics.actualBoundingBoxDescent;
            } else {
                ascent = 0;
                descent = 0;
            }
            this.textHeight = ascent + descent;
        }
        return this;
    }

    get width() {
        return this.textWidth * this.scaleX;
    }

    set width(value) {
        if (this.textWidth > 0) {
            this.scaleX = value / this.textWidth;
        } else {
            this.scaleX = 1;
        }
    }

    get height() {
        return this.textHeight * this.scaleY;
    }

    set height(value) {
        if (this.textHeight > 0) {
            this.scaleY = value / this.textHeight;
        } else {
            this.scaleY = 1;
        }
    }

    drawContent() {
        var textStyle = this.style;
        var hasFill = textStyle.hasFill,
            hasStroke = textStyle.hasStroke;

        if (!hasFill && !hasStroke) {
            return;
        }

        var context = this.context;
        textStyle.syncFont(context).syncStyle(context);

        if (hasStroke) {
            textStyle.syncShadow(context);
            context.strokeText(this.text, 0, 0);
        }

        if (hasFill) {
            textStyle.syncShadow(context);
            context.fillText(this.text, 0, 0);
        }
    }

    draw() {
        if (!this.visible || (this.text === '') || (this.text === '\n')) {
            return this;
        }

        super.draw();
    }
}

var AppendText = function (text, style) {
    if (style) {
        this.textStyle.modify(style);
    }

    this.lastAppendedChildren.length = 0;
    for (var i = 0, cnt = text.length; i < cnt; i++) {
        var char = text.charAt(i);
        var bob = this.poolManager.allocate(CharTypeName);
        if (bob === null) {
            bob = new CharData(
                this,               // parent
                char,               // text
                this.textStyle,     // style
            );
        } else {
            bob
                .setParent(this)
                .setActive()
                .modifyStyle(this.textStyle)
                .setText(char);
        }
        // bob.modifyPorperties(properties);  // Warning: Will modify text-style twice

        this.children.push(bob);
        this.lastAppendedChildren.push(bob);
    }
    return this;
};

var SetText = function (text, style) {
    if (text === undefined) {
        text = '';
    }

    this.removeChildren();
    AppendText.call(this, text, style);  // this.appendText might be override

    this.dirty = true;
    return this;
};

class ImageData extends Base$1 {
    constructor(
        parent,
        key, frame
    ) {
        super(parent, ImageTypeName);
        this.setTexture(key, frame);
    }

    get frameWidth() {
        return (this.frameObj) ? this.frameObj.cutWidth : 0;
    }

    get frameHeight() {
        return (this.frameObj) ? this.frameObj.cutHeight : 0;
    }

    get offsetY() {
        return -this.height;
    }

    set offsetY(value) { }

    get key() {
        return this._key;
    }

    set key(value) {
        this.setDirty(this._key != value);
        this._key = value;
    }

    get frame() {
        return this._frame;
    }

    set frame(value) {
        this.setDirty(this._frame != value);
        this._frame = value;
    }

    setTexture(key, frame) {
        this.key = key;
        this.frame = frame;

        this.frameObj = this.scene.textures.getFrame(key, frame);
        return this;
    }

    get width() {
        return this.frameWidth * this.scaleX;
    }

    set width(value) {
        this.setDirty(this.width !== value);
        this.scaleX = value / this.frameWidth;
    }

    get height() {
        return this.frameHeight * this.scaleY;
    }

    set height(value) {
        this.setDirty(this.height !== value);
        this.scaleY = value / this.frameHeight;
    }

    setHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
            keepAspectRatio = false;
        }
        this.height = height;

        if (keepAspectRatio) {
            this.scaleX = this.scaleY;
        }
        return this;
    }

    drawContent() {
        var context = this.context;
        var frame = this.frameObj;

        context.drawImage(
            frame.source.image,              // image
            frame.cutX, frame.cutY,          // sx, sy
            frame.cutWidth, frame.cutHeight, // sWidth, sHeight
        );
    }

    draw() {
        if (!this.visible) {
            return this;
        }

        super.draw();
    }

}

var AppendImage = function (key, frame, properties) {
    var bob = this.poolManager.allocate(ImageTypeName);
    if (bob === null) {
        bob = new ImageData(
            this,               // parent
            key,
            frame
        );
    } else {
        bob
            .setParent(this)
            .setActive()
            .setTexture(key, frame);
    }
    bob.modifyPorperties(properties);

    this.lastAppendedChildren.length = 0;
    this.children.push(bob);
    this.lastAppendedChildren.push(bob);
    return this;
};

class Command extends Base$1 {
    constructor(parent, name, callback, param, scope) {
        super(parent, CmdTypeName);

        this
            .setName(name)
            .setParameter(param)
            .setCallback(callback, scope);
    }

    setName(name) {
        this.name = name;
        return this;
    }

    setParameter(param) {
        this.param = param;
        return this;
    }

    setCallback(callback, scope) {
        this.callback = callback;
        this.scope = scope;
        return this;
    }

    exec() {
        var result;
        if (this.scope) {
            result = this.callback.call(this.scope, this.param, this.name);
        } else {
            result = this.callback(this.param, this.name);
        }
        return result;
    }

    draw() { }

    onFree() {
        super.onFree();
        this
            .setName()
            .setCallback()
            .setParameter();
    }
}

var AppendCommand = function (name, callback, param, scope) {
    var bob = this.poolManager.allocate(CmdTypeName);
    if (bob === null) {
        bob = new Command(
            this,               // parent
            name,
            callback, param, scope, 
        );
    } else {
        bob
            .setParent(this)
            .setActive()
            .setName(name)
            .setCallback(callback, scope)
            .setParameter(param);

    }

    this.lastAppendedChildren.length = 0;
    this.children.push(bob);
    this.lastAppendedChildren.push(bob);
    return this;
};

var SetWrapConfig = function (config) {
    this.wrapConfig = config;
    return this;
};

var MergeConfig = function (config, defaultConfig) {
    if (!defaultConfig) {
        return config;
    }
    if (config == null) {
        config = {};
    }

    for (var key in defaultConfig) {
        if (!config.hasOwnProperty(key)) {
            config[key] = defaultConfig[key];
        }
    }
    return config;
};

var GetWord = function (children, startIndex, charMode, result) {
    if (result === undefined) {
        result = { word: [], width: 0 };
    }

    result.word.length = 0;

    var endIndex = children.length;
    var currentIndex = startIndex;
    var word = result.word, wordWidth = 0;
    while (currentIndex < endIndex) {
        var child = children[currentIndex];
        if ((child.type === CharTypeName) && (child.text !== ' ') && (child.text !== '\n')) {
            word.push(child);
            wordWidth += child.outerWidth;
            currentIndex++;
            // Continue
        } else {  // Get non-text child, a space, or a new-line
            if (currentIndex === startIndex) { // Single child
                word.push(child);
                wordWidth += child.outerWidth;
            }
            break;
        }

        if (charMode) {  // Word only contains 1 character
            break;
        }
    }

    result.width = wordWidth;
    return result;
};

const HAlign = {
    left: 0,
    center: 1,
    right: 2
};

const VAlign = {
    top: 0,
    center: 1,
    bottom: 2
};

var AlignLines = function (result, width, height) {
    var hAlign = result.hAlign,
        vAlign = result.vAlign;

    if (typeof (hAlign) === 'string') {
        hAlign = HAlign[hAlign];
        result.hAlign = hAlign;
    }
    if (typeof (vAlign) === 'string') {
        vAlign = VAlign[vAlign];
        result.vAlign = vAlign;
    }

    if (hAlign !== 0) {  // left align does not have offset
        var lines = result.lines;
        for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
            var line = lines[li];
            var lineWidth = line.width,
                children = line.children;

            var xOffset;
            switch (hAlign) {
                case 1:  // center
                    xOffset = (width - lineWidth) / 2;
                    break;
                case 2:  // right
                    xOffset = width - lineWidth;
                    break;
            }

            for (var ci = 0, ccnt = children.length; ci < ccnt; ci++) {
                var child = children[ci];
                child.x += xOffset;
            }
        }
    }

    if (vAlign !== 0) { // top align does not have offset
        var linesHeight = result.linesHeight;
        var yOffset;
        switch (vAlign) {
            case 1: // center
                yOffset = (height - linesHeight) / 2;
                break;
            case 2: // bottom
                yOffset = height - linesHeight;
                break;
        }

        var children = result.children;
        for (var ci = 0, ccnt = children.length; ci < ccnt; ci++) {
            var child = children[ci];
            child.y += yOffset;
        }
    }
};

const GetValue$i = Phaser.Utils.Objects.GetValue;

var RunWordWrap = function (config) {
    // Parse parameters
    var startIndex = GetValue$i(config, 'start', 0);

    var extraTopPadding = GetValue$i(config, 'padding.top', 0);
    var extraBottomPadding = GetValue$i(config, 'padding.bottom', 0);  // Add extra space below last line

    // Get lineHeight, maxLines
    var lineHeight = GetValue$i(config, 'lineHeight', undefined);
    var maxLines;
    if (lineHeight === undefined) {
        // Calculate lineHeight via maxLines, in fixedHeight mode
        maxLines = GetValue$i(config, 'maxLines', 0);
        if (this.fixedHeight > 0) {
            var innerHeight = this.fixedHeight - this.padding.top - this.padding.bottom - extraTopPadding - extraBottomPadding;
            lineHeight = innerHeight / maxLines;
        } else {
            lineHeight = 0;
        }
    } else {
        if (this.fixedHeight > 0) {
            // Calculate maxLines via lineHeight, in fixedHeight mode
            maxLines = GetValue$i(config, 'maxLines', undefined);
            if (maxLines === undefined) {
                var innerHeight = this.fixedHeight - this.padding.top - this.padding.bottom - extraTopPadding - extraBottomPadding;
                maxLines = Math.floor(innerHeight / lineHeight);
            }
        } else {
            maxLines = GetValue$i(config, 'maxLines', 0); // Default is show all lines
        }

    }
    var showAllLines = (maxLines === 0);

    // Get wrapWidth
    var wrapWidth = GetValue$i(config, 'wrapWidth', undefined);
    if (wrapWidth === undefined) {
        if (this.fixedWidth > 0) {
            wrapWidth = this.fixedWidth - this.padding.left - this.padding.right;
        } else {
            wrapWidth = Infinity; // No word-wrap
        }
    }

    var letterSpacing = GetValue$i(config, 'letterSpacing', 0);

    var hAlign = GetValue$i(config, 'hAlign', 0);
    var vAlign = GetValue$i(config, 'vAlign', 0);

    var charWrap = GetValue$i(config, 'charWrap', false);

    var result = {
        start: startIndex,  // Next start index
        isLastPage: false,  // Is last page
        padding: {
            top: extraTopPadding,
            bottom: extraBottomPadding
        },
        lineHeight: lineHeight,
        maxLines: maxLines,
        wrapWidth: wrapWidth,
        letterSpacing: letterSpacing,
        hAlign: hAlign,
        vAlign: vAlign,
        charWrap: charWrap,
        children: [],       // Word-wrap result
        lines: [],          // Word-wrap result in lines
        maxLineWidth: 0,
        linesHeight: 0
    };

    // Set all children to active
    var children = this.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].setActive(false);
    }

    // Layout children
    wrapWidth += letterSpacing;
    var startX = this.padding.left,
        startY = this.padding.top + lineHeight + extraTopPadding,  // Start(baseline) from 1st lineHeight, not 0
        x = startX,
        y = startY;
    var remainderWidth = wrapWidth,
        childIndex = startIndex,
        lastChildIndex = children.length;
    var resultChildren = result.children;
    var resultLines = result.lines,
        lastLine = [], lastLineWidth = 0, maxLineWidth = 0;
    var wordResult;
    while (childIndex < lastChildIndex) {
        // Append non-typeable child directly
        var child = children[childIndex];
        if (!IsTypeable(child)) {
            childIndex++;
            child.setActive();
            resultChildren.push(child);
            lastLine.push(child);
            continue;
        }

        wordResult = GetWord(children, childIndex, charWrap, wordResult);
        var word = wordResult.word;
        var charCnt = word.length;
        var wordWidth = wordResult.width + (charCnt * letterSpacing);

        childIndex += charCnt;
        // Next line
        var isNewLineChar = IsNewLineChar(word[0]);
        if ((remainderWidth < wordWidth) || isNewLineChar) {
            // Add to result
            if (isNewLineChar) {
                var char = word[0];
                char.setActive().setPosition(x, y);
                resultChildren.push(char);
                lastLine.push(char);
            }

            // Move cursor
            x = startX;
            y += lineHeight;
            remainderWidth = wrapWidth;
            resultLines.push({ children: lastLine, width: lastLineWidth });
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);

            lastLineWidth = 0;
            lastLine = [];

            if (!showAllLines && (resultLines.length === maxLines)) {  // Exceed maxLines
                break;
            } else if (isNewLineChar) {  // Already add to result                
                continue;
            }
        }
        remainderWidth -= wordWidth;
        lastLineWidth += wordWidth;

        for (var i = 0, cnt = word.length; i < cnt; i++) {
            var char = word[i];
            char.setActive().setPosition(x, y);
            resultChildren.push(char);
            lastLine.push(char);
            x += (char.outerWidth + letterSpacing);
        }
    }

    if (lastLine.length > 0) {
        resultLines.push({ children: lastLine, width: lastLineWidth });
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
    }

    result.start += resultChildren.length;
    result.isLastPage = (result.start === lastChildIndex);
    result.maxLineWidth = maxLineWidth;
    result.linesHeight = (resultLines.length * lineHeight) + extraTopPadding + extraBottomPadding;

    // Calculate size of game object
    var width = (this.fixedWidth > 0) ? this.fixedWidth : (result.maxLineWidth + this.padding.left + this.padding.right);
    var height = (this.fixedHeight > 0) ? this.fixedHeight : (result.linesHeight + this.padding.top + this.padding.bottom);

    // Size might be changed after wrapping
    var innerWidth = width - this.padding.left - this.padding.right;
    var innerHeight = height - this.padding.top - this.padding.bottom - extraTopPadding - extraBottomPadding;
    AlignLines(result, innerWidth, innerHeight);

    // Resize
    this.setSize(width, height);

    return result;
};

var RunWordWrap$1 = function (config) {
    config = MergeConfig(config, this.wrapConfig);
    return RunWordWrap.call(this, config);
};

var AlignLines$1 = function (result, width, height) {
    var hAlign = result.hAlign,
        vAlign = result.vAlign;

    if (typeof (hAlign) === 'string') {
        hAlign = HAlign[hAlign];
        result.hAlign = hAlign;
    }
    if (typeof (vAlign) === 'string') {
        vAlign = VAlign[vAlign];
        result.vAlign = vAlign;
    }

    var rtl = result.rtl;
    var lines = result.lines,
        lineWidth = result.lineWidth,
        linesWidth = result.linesWidth;
    var xOffset;
    switch (hAlign) {
        case 0:  // left
            xOffset = 0;
            break;
        case 1:  // center
            xOffset = (width - linesWidth) / 2;
            break;
        case 2:  // right
            xOffset = width - linesWidth;
            break;
    }
    if (rtl) {
        xOffset += lineWidth;
    }
    for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
        var line = lines[(rtl) ? (lcnt - li - 1) : li];
        var children = line.children;
        var lineHeight = line.height;

        var yOffset;
        switch (vAlign) {
            case 0: // top
                yOffset = 0;
                break;
            case 1: // center
                yOffset = (height - lineHeight) / 2;
                break;
            case 2: // bottom
                yOffset = height - lineHeight;
                break;
        }

        for (var ci = 0, ccnt = children.length; ci < ccnt; ci++) {
            var child = children[ci];
            child.x += xOffset;
            child.y += yOffset;
        }

        xOffset += lineWidth;
    }
};

const GetValue$j = Phaser.Utils.Objects.GetValue;

var RunVerticalWrap = function (config) {
    // Parse parameters
    var startIndex = GetValue$j(config, 'start', 0);

    var extraTopPadding = GetValue$j(config, 'padding.top', 0);
    var extraBottomPadding = GetValue$j(config, 'padding.bottom', 0);  // Add extra space below last character
    var extraLeftPadding = GetValue$j(config, 'padding.left', 0);
    var extraRightPadding = GetValue$j(config, 'padding.right', 0);

    var lineWidth = GetValue$j(config, 'lineWidth', undefined);
    var maxLines;
    if (lineWidth === undefined) {
        // Calculate lineWidth via maxLines, in fixedWidth mode
        maxLines = GetValue$j(config, 'maxLines', 0);
        if (this.fixedWidth > 0) {
            var innerWidth = this.fixedWidth - this.padding.left - this.padding.right - extraLeftPadding - extraRightPadding;
            lineWidth = innerWidth / maxLines;
        } else {
            lineWidth = 0;
        }
    } else {
        if (this.fixedWidth > 0) {
            // Calculate maxLines via lineWidth, in fixedWidth mode
            maxLines = GetValue$j(config, 'maxLines', undefined);
            if (maxLines === undefined) {
                var innerWidth = this.fixedWidth - this.padding.left - this.padding.right;
                maxLines = Math.floor(innerWidth / lineWidth);
            }
        } else {
            maxLines = GetValue$j(config, 'maxLines', 0); // Default is show all lines
        }

    }
    var showAllLines = (maxLines === 0);

    // Get fixedChildHeight
    var fixedChildHeight = GetValue$j(config, 'fixedChildHeight', undefined);
    if (fixedChildHeight === undefined) {
        var charPerLine = GetValue$j(config, 'charPerLine', undefined);
        if (charPerLine !== undefined) {
            var innerHeight = this.fixedHeight - this.padding.top - this.padding.bottom - extraTopPadding - extraBottomPadding;
            fixedChildHeight = Math.floor(innerHeight / charPerLine);
        }
    }

    // Get wrapHeight
    var wrapHeight = GetValue$j(config, 'wrapHeight', undefined);
    if (wrapHeight === undefined) {
        if (this.fixedHeight > 0) {
            wrapHeight = this.fixedHeight - this.padding.top - this.padding.bottom;
        } else {
            wrapHeight = Infinity; // No word-wrap
        }
    }

    var letterSpacing = GetValue$j(config, 'letterSpacing', 0);

    var rtl = GetValue$j(config, 'rtl', true);
    var hAlign = GetValue$j(config, 'hAlign', rtl ? 2 : 0);
    var vAlign = GetValue$j(config, 'vAlign', 0);

    var result = {
        start: startIndex,  // Next start index
        isLastPage: false,  // Is last page
        padding: {
            top: extraTopPadding,
            bottom: extraBottomPadding,
            left: extraLeftPadding,
            right: extraRightPadding
        },
        lineWidth: lineWidth,
        maxLines: maxLines,
        fixedChildHeight: fixedChildHeight,
        wrapHeight: wrapHeight,
        letterSpacing: letterSpacing,
        hAlign: hAlign,
        vAlign: vAlign,
        rtl: rtl,
        children: [],       // Word-wrap result
        lines: [],          // Word-wrap result in lines
        maxLineHeight: 0,
        linesWidth: 0
    };

    // Set all children to active
    var children = this.children;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].setActive(false);
    }

    // Layout children
    wrapHeight += letterSpacing;
    var startX = this.padding.left + extraLeftPadding,  // Reset x of each character in AlignLines method
        startY = this.padding.top + extraTopPadding,
        x = startX,
        y = startY;
    var remainderHeight = wrapHeight,
        childIndex = startIndex,
        lastChildIndex = children.length;
    var resultChildren = result.children;
    var resultLines = result.lines,
        lastLine = [], lastLineHeight = 0, maxLineHeight = 0;
    while (childIndex < lastChildIndex) {
        // Append non-typeable child directly
        var char = children[childIndex];
        childIndex++;
        if (!IsTypeable(char)) {
            char.setActive();
            resultChildren.push(char);
            lastLine.push(char);
            continue;
        }

        var childHeight = ((fixedChildHeight !== undefined) ? fixedChildHeight : char.height) + letterSpacing;
        // Next line
        var isNewLineChar = IsNewLineChar(char);
        if ((remainderHeight < childHeight) || isNewLineChar) {
            // Add to result
            if (isNewLineChar) {
                char.setActive().setPosition(x, y).setOrigin(0.5);
                resultChildren.push(char);
                lastLine.push(char);
            }

            // Move cursor
            x = startX;
            y = startY;
            remainderHeight = wrapHeight;
            resultLines.push({ children: lastLine, height: lastLineHeight });
            maxLineHeight = Math.max(maxLineHeight, lastLineHeight);

            lastLineHeight = 0;
            lastLine = [];

            if (!showAllLines && (resultLines.length === maxLines)) {  // Exceed maxLines
                break;
            } else if (isNewLineChar) {  // Already add to result                
                continue;
            }
        }
        remainderHeight -= childHeight;
        lastLineHeight += childHeight;

        char.setActive().setPosition(x, y).setOrigin(0.5);
        resultChildren.push(char);
        lastLine.push(char);
        y += childHeight;
    }

    if (lastLine.length > 0) {
        resultLines.push({ children: lastLine, height: lastLineHeight });
        maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
    }

    result.start += resultChildren.length;
    result.isLastPage = (result.start === lastChildIndex);
    result.maxLineHeight = maxLineHeight;
    result.linesWidth = (resultLines.length * lineWidth) + extraLeftPadding + extraRightPadding;

    // Calculate size of game object
    var width = (this.fixedWidth > 0) ? this.fixedWidth : (result.linesWidth + this.padding.left + this.padding.right);
    var height = (this.fixedHeight > 0) ? this.fixedHeight : (result.maxLineHeight + this.padding.top + this.padding.bottom);

    // Size might be changed after wrapping
    var innerWidth = width - this.padding.left - this.padding.right - extraLeftPadding - extraRightPadding;
    var innerHeight = height - this.padding.top - this.padding.bottom - extraTopPadding - extraBottomPadding;
    AlignLines$1(result, innerWidth, innerHeight);

    // Resize
    this.setSize(width, height);

    return result;
};

var RunVerticalWrap$1 = function (config) {
    config = MergeConfig(config, this.wrapConfig);
    return RunVerticalWrap.call(this, config);
};

var DrawContent$1 = function () {
    var width = (this.fixedWidth > 0)? this.fixedWidth : this.width;
    var height = (this.fixedHeight > 0)? this.fixedHeight : this.height;
    this.setSize(width, height);

    if (this.background.active) {
        this.background.draw();
    }

    var child;
    for (var i = 0, cnt = this.children.length; i < cnt; i++) {
        child = this.children[i];
        if (child.active) {
            child.draw();
        }
    }

    if (this.innerBounds.active) {
        this.innerBounds.draw();
    }
};

var GetChildren = function () {
    return this.children;
};

var GetLastAppendedChildren = function () {
    return this.lastAppendedChildren;
};

const GetAll = Phaser.Utils.Array.GetAll;

var GetActiveChildren = function () {
    return GetAll(this.children, 'active', true);
};

var Methods$1 = {
    setPadding: SetPadding$1,
    getPadding: GetPadding$1,
    modifyTextStyle: ModifyTextStyle,
    removeChildren: RemoveChildren,
    clearContent: ClearContent,
    setText: SetText,
    appendText: AppendText,
    appendImage: AppendImage,
    appendCommand: AppendCommand,
    setWrapConfig: SetWrapConfig,
    runWordWrap: RunWordWrap$1,
    runVerticalWrap: RunVerticalWrap$1,
    drawContent: DrawContent$1,

    getChildren: GetChildren,
    getLastAppendedChildren: GetLastAppendedChildren,
    getActiveChildren: GetActiveChildren,
};

const GetFastValue$1 = Phaser.Utils.Objects.GetFastValue;

var Pools = {};
class PoolManager {
    constructor(config) {
        this.pools = GetFastValue$1(config, 'pools', Pools);
    }

    free(bob) {
        if (!this.pools) {
            return this;
        }

        var bobType = bob.type;
        if (!this.pools.hasOwnProperty(bobType)) {
            this.pools[bobType] = new Stack();
        }
        this.pools[bobType].push(bob);
        bob.onFree();
        return this;
    }

    freeMultiple(arr) {
        if (!this.pools) {
            return this;
        }

        for (var i = 0, cnt = arr.length; i < cnt; i++) {
            this.free(arr[i]);
        }
        return this;
    }

    allocate(bobType) {
        if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
            return null;
        }
        return this.pools[bobType].pop();
    }
}

const IsPlainObject$3 = Phaser.Utils.Objects.IsPlainObject;
const GetValue$k = Phaser.Utils.Objects.GetValue;

class DynamicText extends Canvas {
    constructor(scene, x, y, fixedWidth, fixedHeight, config) {
        if (IsPlainObject$3(x)) {
            config = x;
            x = GetValue$k(config, 'x', 0);
            y = GetValue$k(config, 'y', 0);
            fixedWidth = GetValue$k(config, 'width', 0);
            fixedHeight = GetValue$k(config, 'height', 0);
        } else if (IsPlainObject$3(fixedWidth)) {
            config = fixedWidth;
            fixedWidth = GetValue$k(config, 'width', 0);
            fixedHeight = GetValue$k(config, 'height', 0);
        }

        var width = (fixedWidth === 0) ? 1 : fixedWidth;
        var height = (fixedHeight === 0) ? 1 : fixedHeight;
        super(scene, x, y, width, height);
        this.type = 'rexDynamicText';
        this.autoRound = true;
        this.padding = {};
        this.textStyle = new TextStyle$1(GetValue$k(config, 'style', undefined));
        this.background = new Background(this, GetValue$k(config, 'background', undefined));
        this.innerBounds = new InnerBounds(this, GetValue$k(config, 'innerBounds', undefined));
        this.children = [];
        this.lastAppendedChildren = [];
        this.poolManager = new PoolManager(config);

        this.setFixedSize(fixedWidth, fixedHeight);
        this.setPadding(GetValue$k(config, 'padding', 0));
        this.setWrapConfig(GetValue$k(config, 'wrap', undefined));

        var text = GetValue$k(config, 'text', undefined);
        if (text) {
            this.setText(text);
        }
    }

    setFixedSize(width, height) {
        if (width === undefined) {
            width = 0;
        }
        if (height === undefined) {
            height = 0;
        }

        if ((width > 0) && (height > 0)) {
            if ((this.fixedWidth !== width) || (this.fixedHeight !== height)) {
                this.dirty = true;
            }
        } else {
            this.dirty = true;
        }

        this.fixedWidth = width;
        this.fixedHeight = height;

        return this;
    }

    updateTexture() {
        this.clear();
        this.drawContent();
        super.updateTexture();
        return this;
    }
}

Object.assign(
    DynamicText.prototype,
    Methods$1
);

var EventEmitterMethods = {
    setEventEmitter(eventEmitter, EventEmitterClass) {
        if (EventEmitterClass === undefined) {
            EventEmitterClass = Phaser.Events.EventEmitter; // Use built-in EventEmitter class by default
        }
        this._privateEE = (eventEmitter === true) || (eventEmitter === undefined);
        this._eventEmitter = (this._privateEE) ? (new EventEmitterClass()) : eventEmitter;
        return this;
    },

    destroyEventEmitter() {
        if (this._eventEmitter && this._privateEE) {
            this._eventEmitter.shutdown();
        }
        return this;
    },

    getEventEmitter() {
        return this._eventEmitter;
    },

    on: function () {
        if (this._eventEmitter) {
            this._eventEmitter.on.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    once: function () {
        if (this._eventEmitter) {
            this._eventEmitter.once.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    off: function () {
        if (this._eventEmitter) {
            this._eventEmitter.off.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    emit: function (event) {
        if (this._eventEmitter && event) {
            this._eventEmitter.emit.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    addListener: function () {
        if (this._eventEmitter) {
            this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    removeListener: function () {
        if (this._eventEmitter) {
            this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    removeAllListeners: function () {
        if (this._eventEmitter) {
            this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
        }
        return this;
    },

    listenerCount: function () {
        if (this._eventEmitter) {
            return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
        }
        return 0;
    },

    listeners: function () {
        if (this._eventEmitter) {
            return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
        }
        return [];
    },

    eventNames: function() {
        if (this._eventEmitter) {
            return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
        }
        return [];
    }
};

// https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js

var EscapeRegex = function (s) {
    return s
        .replace(re0, '\\$&')
        .replace(re1, '\\x2d');
};

var re0 = /[|\\{}()[\]^$+*?.]/g;
var re1 = /-/g;

var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
var convert = function (s) {
    if (typeof (s) !== 'string') {
        return s;
    }

    if (s === '') {
        s = null;
    } else if (FLOAT.test(s)) {
        s = parseFloat(s);
    } else {        
        if (s === 'false') {
            s = false;
        } else if (s === 'true') {
            s = true;
        }
    }

    return s;
};

var ParseValue = function (text, valueConverter) {
    if (text == null) {
        return [];
    }
    var values = text.split(',');
    for (var i = 0, cnt = values.length; i < cnt; i++) {
        values[i] = valueConverter(values[i]);
    }
    return values;
};

const DefaultTagExpression = `[a-z0-9-_.]+`;
const DefaultValueExpression = `[ #a-z-_.0-9,|&]+`;
const BypassValueConverter = function (s) { return s; };

class BracketParser {
    constructor(config) {
        // Event emitter
        this.setEventEmitter(GetValue$c(config, 'eventEmitter', undefined));

        // Parameters for regex
        this.setTagExpression(GetValue$c(config, 'regex.tag', DefaultTagExpression));
        this.setValueExpression(GetValue$c(config, 'regex.value', DefaultValueExpression));
        // Value convert
        this.setValueConverter(GetValue$c(config, 'valueConvert', true));
        // Brackets and generate regex
        var delimiters = GetValue$c(config, 'delimiters', '<>');
        this.setDelimiters(delimiters[0], delimiters[1]);

        this.isRunning = false;
        this.isPaused = false;
        this.skipEventFlag = false;
        this.lastTagStart = null;
        this.lastTagEnd = null;
        this.lastContent = null;
    }

    shutdown() {
        this.destroyEventEmitter();
    }

    destroy() {
        this.shutdown();
    }

    setTagExpression(express) {
        this.tagExpression = express;
        return this;
    }

    setValueExpression(express) {
        this.valueExpression = express;
        return this;
    }

    setValueConverter(converter) {
        if (converter === true) {
            converter = convert;
        } else if (!converter) {
            converter = BypassValueConverter;
        }
        this.valueConverter = converter;
        return this;
    }

    setDelimiters(delimiterLeft, delimiterRight) {
        if (delimiterRight === undefined) {
            delimiterRight = delimiterLeft[1];
            delimiterLeft = delimiterLeft[0];
        }
        this.delimiterLeft = delimiterLeft;
        this.delimiterRight = delimiterRight;

        delimiterLeft = EscapeRegex(delimiterLeft);
        delimiterRight = EscapeRegex(delimiterRight);
        var tagOn = `${delimiterLeft}(${this.tagExpression})(=(${this.valueExpression}))?${delimiterRight}`;
        var tagOff = `${delimiterLeft}\/(${this.tagExpression})${delimiterRight}`;

        this.reTagOn = RegExp(tagOn, 'i');
        this.reTagOff = RegExp(tagOff, 'i');
        this.reSplit = RegExp(`${tagOn}|${tagOff}`, 'gi');
        return this;
    }

    setSource(source) {
        this.source = source;
        return this;
    }

    resetIndex(index) {
        if (index === undefined) {
            index = 0;
        }
        this.progressIndex = index;
        this.reSplit.lastIndex = index;
        this.lastTagStart = null;
        this.lastTagEnd = null;
        this.lastContent = null;
        return this;
    }

    start(source) {
        this
            .setSource(source)
            .restart();
        return this;
    }

    restart() {
        this
            .resetIndex()
            .next();
    }

    next() {
        if (this.isPaused) {
            this.onResume();
        }

        var text = this.source,
            lastIndex = text.length;

        if (this.reSplit.lastIndex === 0) {
            this.onStart();
        }
        while (!this.isPaused) {
            var regexResult = this.reSplit.exec(text);
            if (!regexResult) {
                if (this.progressIndex < lastIndex) {
                    this.onContent(text.substring(this.progressIndex, lastIndex));
                }
                this.onComplete();
                return;
            }

            var match = regexResult[0];
            var matchStart = this.reSplit.lastIndex - match.length;

            if (this.progressIndex < matchStart) {
                this.onContent(text.substring(this.progressIndex, matchStart));
            }

            if (this.reTagOff.test(match)) {
                this.onTagEnd(match);
            } else {
                this.onTagStart(match);
            }

            this.progressIndex = this.reSplit.lastIndex;
        }

    }

    skipEvent() {
        this.skipEventFlag = true;
        return this;
    }

    pause() {
        if (!this.isPaused) {
            this.onPause();
        }
        return this;
    }

    onContent(content) {
        this.emit('content', content);
        this.lastContent = content;
    }

    onTagStart(tagContent) {
        var regexResult = tagContent.match(this.reTagOn);
        var tag = regexResult[1];
        var values = ParseValue(regexResult[3], this.valueConverter);

        this.skipEventFlag = false;
        this.emit(`+${tag}`, ...values);
        if (!this.skipEventFlag) {
            this.emit('+', tag, ...values);
        }

        this.lastTagStart = tag;
    }

    onTagEnd(tagContent) {
        var tag = tagContent.match(this.reTagOff)[1];

        this.skipEventFlag = false;
        this.emit(`-${tag}`);
        if (!this.skipEventFlag) {
            this.emit('-', tag);
        }

        this.lastTagEnd = tag;
    }

    onStart() {
        this.isRunning = true;
        this.emit('start', this);
    }

    onComplete() {
        this.isRunning = false;
        this.emit('complete', this);
        this.resetIndex();
    }

    onPause() {
        this.isPaused = true;
        this.emit('pause', this);
    }

    onResume() {
        this.isPaused = false;
        this.emit('resume', this);
    }
}


Object.assign(
    BracketParser.prototype,
    EventEmitterMethods
);

const GetValue$l = Phaser.Utils.Objects.GetValue;

var OnParseColorTag = function (textPlayer, parser, config) {
    var tagName = GetValue$l(config, 'tags.color', 'color');
    var defaultColor;
    parser
        .on('start', function () {
            defaultColor = textPlayer.textStyle.color;
        })
        .on(`+${tagName}`, function (color) {
            textPlayer.textStyle.setColor(color);
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            textPlayer.textStyle.setColor(defaultColor);
            parser.skipEvent();
        })
        .on('complete', function () {
            textPlayer.textStyle.setColor(defaultColor);
        });
};

const GetValue$m = Phaser.Utils.Objects.GetValue;

var OnParseStrokeColorTag = function (textPlayer, parser, config) {
    var tagName = GetValue$m(config, 'tags.stroke', 'stroke');
    var defaultStroke;
    parser
        .on('start', function () {
            defaultStroke = textPlayer.textStyle.stroke;
            textPlayer.textStyle.setStrokeStyle(null);
        })
        .on(`+${tagName}`, function (color) {
            if (color === undefined) {
                color = defaultStroke;
            }
            textPlayer.textStyle.setStrokeStyle(color);
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            textPlayer.textStyle.setStrokeStyle(null);
            parser.skipEvent();
        })
        .on('complete', function () {
            textPlayer.textStyle.setStrokeStyle(defaultStroke);
        });
};

const GetValue$n = Phaser.Utils.Objects.GetValue;

var OnParseBoldTag = function (textPlayer, parser, config) {
    var tagName = GetValue$n(config, 'tags.b', 'b');
    parser
        .on('start', function () {
            textPlayer.textStyle.setBold(false);
        })
        .on(`+${tagName}`, function () {
            textPlayer.textStyle.setBold(true);
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            textPlayer.textStyle.setBold(false);
            parser.skipEvent();
        });
};

const GetValue$o = Phaser.Utils.Objects.GetValue;

var OnParseItalicTag = function (textPlayer, parser, config) {
    var tagName = GetValue$o(config, 'tags.i', 'i');
    parser
        .on('start', function () {
            textPlayer.textStyle.setItalic(false);
        })
        .on(`+${tagName}`, function () {
            textPlayer.textStyle.setItalic(true);
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            textPlayer.textStyle.setItalic(false);
            parser.skipEvent();
        });
};

const GetValue$p = Phaser.Utils.Objects.GetValue;

var OnParseFontSizeTag = function (textPlayer, parser, config) {
    var tagName = GetValue$p(config, 'tags.size', 'size');
    var defaultFontSize;
    parser
        .on('start', function () {
            defaultFontSize = textPlayer.textStyle.fontSize;
        })
        .on(`+${tagName}`, function (fontSize) {
            textPlayer.textStyle.setFontSize(fontSize);
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            textPlayer.textStyle.setFontSize(defaultFontSize);
            parser.skipEvent();
        })
        .on('complete', function () {
            textPlayer.textStyle.setFontSize(defaultFontSize);
        });
};

const GetValue$q = Phaser.Utils.Objects.GetValue;

var OnParseOffsetYTag = function (textPlayer, parser, config) {
    var tagName = GetValue$q(config, 'tags.y', 'y');
    var defaultOffsetY;
    parser
        .on('start', function () {
            defaultOffsetY = textPlayer.textStyle.offsetY;
            textPlayer.textStyle.setOffsetY(0);
        })
        .on(`+${tagName}`, function (y) {
            if (y === undefined) {
                y = defaultOffsetY;
            }
            textPlayer.textStyle.setOffsetY(y);
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            textPlayer.textStyle.setOffsetY(0);
            parser.skipEvent();
        })
        .on('complete', function () {
            textPlayer.textStyle.setOffsetY(0);
        });
};

const GetValue$r = Phaser.Utils.Objects.GetValue;

var OnParseShadowColorTag = function (textPlayer, parser, config) {
    var tagName = GetValue$r(config, 'tags.shadow', 'shadow');
    var defaultShadowColor;
    parser
        .on('start', function () {
            defaultShadowColor = textPlayer.textStyle.shadowColor;
            textPlayer.textStyle.setShadowColor(null);
        })
        .on(`+${tagName}`, function (color) {
            if (color === undefined) {
                color = defaultShadowColor;
            }
            textPlayer.textStyle.setShadowColor(color);
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            textPlayer.textStyle.setShadowColor(null);
            parser.skipEvent();
        })
        .on('complete', function () {
            textPlayer.textStyle.setShadowColor(defaultShadowColor);
        });
};

const GetValue$s = Phaser.Utils.Objects.GetValue;

var OnParseImageTag = function (textPlayer, parser, config) {
    var tagName = GetValue$s(config, 'tags.img', 'img');
    parser
        .on(`+${tagName}`, function (name) {
            var imgData = textPlayer.imageManager.get(name);
            AppendImage.call(textPlayer,
                imgData.key, imgData.frame,
                {
                    width: imgData.width,
                    hieght: imgData.height,
                    leftSpace: imgData.left,
                    rightSpace: imgData.right
                }
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {

            parser.skipEvent();
        });
};

const GetValue$t = Phaser.Utils.Objects.GetValue;

var OnParseTypingSpeedTag = function (textPlayer, parser, config) {
    var tagName = GetValue$t(config, 'tags.speed', 'speed');
    var defaultSpeed;
    parser
        .on('start', function () {
            defaultSpeed = textPlayer.typeWriter.speed;
        })
        .on(`+${tagName}`, function (speed) {
            AppendCommand$1(textPlayer, speed);
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            AppendCommand$1(textPlayer, defaultSpeed);
            parser.skipEvent();
        })
        .on('complete', function () {
            textPlayer.typeWriter.speed = defaultSpeed;
        });
};

var SetSpeed = function(speed) {
    this.typeWriter.setSpeed(speed);  // this: textPlayer
};

var AppendCommand$1 = function (textPlayer, speed) {
    AppendCommand.call(textPlayer,
        'speed',      // name
        SetSpeed,     // callback
        speed,        // params
        textPlayer,   // scope
    );
};

const GetValue$u = Phaser.Utils.Objects.GetValue;

var OnParsePlaySoundEffectTag = function (textPlayer, parser, config) {
    var tagName = GetValue$u(config, 'tags.se', 'se');
    parser
        .on(`+${tagName}`, function (name, fadeInTime) {
            AppendCommand.call(textPlayer,
                'se',                 // name
                PlaySoundEffect,      // callback
                [name, fadeInTime],   // params
                textPlayer,           // scope
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            parser.skipEvent();
        });
};

var PlaySoundEffect = function (params) {
    if (this.skipSoundEffect) {
        return;
    }

    var name = params[0];
    var fadeInTime = params[1];

    this.soundManager.playSoundEffect(name);  // this: textPlayer
    if (fadeInTime) {
        this.soundManager.fadeInSoundEffect(fadeInTime);
    }
};

const GetValue$v = Phaser.Utils.Objects.GetValue;

var OnParseFadeInSoundEffectTag = function (textPlayer, parser, config) {
    var tagName = GetValue$v(config, 'tags.se.fadein', 'se.fadein');
    parser
        .on(`+${tagName}`, function (time) {
            AppendCommand.call(textPlayer,
                'se.fadein',         // name
                FadeInSoundEffect,   // callback
                time,                // params
                textPlayer,          // scope
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            parser.skipEvent();
        });
};

var FadeInSoundEffect = function (time) {
    // this: textPlayer
    this.soundManager.fadeInSoundEffect(time);
};

const GetValue$w = Phaser.Utils.Objects.GetValue;

var OnParseFadeOutSoundEffectTag = function (textPlayer, parser, config) {
    var tagName = GetValue$w(config, 'tags.se.fadeout', 'se.fadeout');
    parser
        .on(`+${tagName}`, function (time, isStopped) {
            isStopped = (isStopped === 'stop');
            AppendCommand.call(textPlayer,
                'se.fadeout',        // name
                FadeOutSoundEffect,  // callback
                [time, isStopped],   // params
                textPlayer,          // scope
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            parser.skipEvent();
        });
};

var FadeOutSoundEffect = function (params) {
    // this: textPlayer
    this.soundManager.fadeOutSoundEffect(...params);
};

const GetValue$x = Phaser.Utils.Objects.GetValue;

var OnParseSetSoundEffectVolumeTag = function (textPlayer, parser, config) {
    var tagName = GetValue$x(config, 'tags.se.volume', 'se.volume');
    parser
        .on(`+${tagName}`, function (name) {
            AppendCommand.call(textPlayer,
                'se.volume',           // name
                SetSoundEffectVolume,  // callback
                name,                  // params
                textPlayer,            // scope
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            parser.skipEvent();
        });
};

var SetSoundEffectVolume = function (name) {
    // this: textPlayer
    this.soundManager.setSoundEffectVolume(name);
};

const GetValue$y = Phaser.Utils.Objects.GetValue;

var OnParsePlayBackgroundMusicTag = function (textPlayer, parser, config) {
    var tagName = GetValue$y(config, 'tags.bgm', 'bgm');
    parser
        .on(`+${tagName}`, function (name, fadeInTime) {
            AppendCommand.call(textPlayer,
                'bgm',                // name
                PlayBackgroundMusic,  // callback
                [name, fadeInTime],   // params
                textPlayer,           // scope
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            AppendCommand.call(textPlayer,
                'bgm.stop',           // name
                StopBackgroundMusic,  // callback
                undefined,            // params
                textPlayer,           // scope
            );
            parser.skipEvent();
        });
};

var PlayBackgroundMusic = function (params) {
    var name = params[0];
    var fadeInTime = params[1];

    // this: textPlayer
    this.soundManager.playBackgroundMusic(name);
    if (fadeInTime) {
        this.soundManager.fadeInBackgroundMusic(fadeInTime);
    }
};

var StopBackgroundMusic = function () {
    // this: textPlayer
    this.soundManager.stopBackgroundMusic();
};

const GetValue$z = Phaser.Utils.Objects.GetValue;

var OnParseFadeInBackgroundMusicTag = function (textPlayer, parser, config) {
    var tagName = GetValue$z(config, 'tags.bgm.fadein', 'bgm.fadein');
    parser
        .on(`+${tagName}`, function (time) {
            AppendCommand.call(textPlayer,
                'bgm.fadein',            // name
                FadeInBackgroundMusic,   // callback
                time,                    // params
                textPlayer,              // scope
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            parser.skipEvent();
        });
};

var FadeInBackgroundMusic = function (time) {
    // this: textPlayer
    this.soundManager.fadeInBackgroundMusic(time);
};

const GetValue$A = Phaser.Utils.Objects.GetValue;

var OnParseFadeOutBackgroundMusicTag = function (textPlayer, parser, config) {
    var tagName = GetValue$A(config, 'tags.bgm.fadeout', 'bgm.fadeout');
    parser
        .on(`+${tagName}`, function (time, isStopped) {
            AppendCommand.call(textPlayer,
                'bgm.fadeout',           // name
                FadeOutBackgroundMusic,  // callback
                [time, isStopped],      // params
                textPlayer,             // scope
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            parser.skipEvent();
        });
};

var FadeOutBackgroundMusic = function (params) {
    // this: textPlayer
    this.soundManager.fadeOutBackgroundMusic(...params);
};

const GetValue$B = Phaser.Utils.Objects.GetValue;

var OnParseCrossFadeBackgroundMusicTag = function (textPlayer, parser, config) {
    var tagName = GetValue$B(config, 'tags.bgm.cross', 'bgm.cross');
    parser
        .on(`+${tagName}`, function (name, fadeTime) {
            AppendCommand.call(textPlayer,
                'bgm.cross',               // name
                CrossFadeBackgroundMusic,  // callback
                [name, fadeTime],          // params
                textPlayer,                // scope
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            parser.skipEvent();
        });
};

var CrossFadeBackgroundMusic = function (params) {
    // this: textPlayer
    this.soundManager.crossFadeBackgroundMusic(...params);
};

const GetValue$C = Phaser.Utils.Objects.GetValue;

var OnParsePauseBackgroundMusicTag = function (textPlayer, parser, config) {
    var tagName = GetValue$C(config, 'tags.bgm.pause', 'bgm.pause');
    parser
        .on(`+${tagName}`, function () {
            AppendCommand.call(textPlayer,
                'bgm.pause',           // name
                PauseBackgroundMusic,  // callback
                undefined,             // params
                textPlayer,            // scope
            );
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {
            AppendCommand.call(textPlayer,
                'bgm.resume',           // name
                ResumeBackgroundMusic,  // callback
                undefined,              // params
                textPlayer,             // scope
            );
            parser.skipEvent();
        });
};

var PauseBackgroundMusic = function () {
    // this: textPlayer
    this.soundManager.pauseBackgroundMusic();
};

var ResumeBackgroundMusic = function () {
    // this: textPlayer
    this.soundManager.resumeBackgroundMusic();
};

const GetValue$D = Phaser.Utils.Objects.GetValue;

var OnParseFadeInCameraTag = function (textPlayer, parser, config) {
    var tagName = GetValue$D(config, 'tags.camera.fadein', 'camera.fadein');
    parser
        .on(`+${tagName}`, function (duration, red, green, blue) {
            AppendCommand.call(textPlayer,
                'camera.fadein',               // name
                PlayFadeInEffect,              // callback
                [duration, red, green, blue],  // params
                textPlayer,                    // scope
            );
            parser.skipEvent();
        });
};

var PlayFadeInEffect = function (params) {
    // this: textPlayer
    this.camera.fadeIn(...params);
};

const GetValue$E = Phaser.Utils.Objects.GetValue;

var OnParseFadeOutCameraTag = function (textPlayer, parser, config) {
    var tagName = GetValue$E(config, 'tags.camera.fadeout', 'camera.fadeout');
    parser
        .on(`+${tagName}`, function (duration, red, green, blue) {
            AppendCommand.call(textPlayer,
                'camera.fadeout',              // name
                PlayFadeOutEffect,             // callback
                [duration, red, green, blue],  // params
                textPlayer,                    // scope
            );
            parser.skipEvent();
        });
};

var PlayFadeOutEffect = function (params) {
    // this: textPlayer
    this.camera.fadeOut(...params);
};

const GetValue$F = Phaser.Utils.Objects.GetValue;

var OnParseShakeCameraTag = function (textPlayer, parser, config) {
    var tagName = GetValue$F(config, 'tags.camera.shake', 'camera.shake');
    parser
        .on(`+${tagName}`, function (duration, intensity) {
            AppendCommand.call(textPlayer,
                'camera.shake',         // name
                PlayShakeEffect,        // callback
                [duration, intensity],  // params
                textPlayer,             // scope
            );
            parser.skipEvent();
        });
};

var PlayShakeEffect = function (params) {
    // this: textPlayer
    this.camera.shake(...params);
};

const GetValue$G = Phaser.Utils.Objects.GetValue;

var OnParseFlashCameraTag = function (textPlayer, parser, config) {
    var tagName = GetValue$G(config, 'tags.camera.flash', 'camera.flash');
    parser
        .on(`+${tagName}`, function (duration, red, green, blue) {
            AppendCommand.call(textPlayer,
                'camera.flash',                // name
                PlayFlashEffect,               // callback
                [duration, red, green, blue],  // params
                textPlayer,                    // scope
            );
            parser.skipEvent();
        });
};

var PlayFlashEffect = function (params) {
    // this: textPlayer
    this.camera.flash(...params);
};

const GetValue$H = Phaser.Utils.Objects.GetValue;

var OnParseZoomCameraTag = function (textPlayer, parser, config) {
    var tagName = GetValue$H(config, 'tags.camera.zoom', 'camera.zoom');
    parser
        .on(`+${tagName}`, function (value) {
            AppendCommand.call(textPlayer,
                'camera.zoom',   // name
                Zoom,      // callback
                value,           // params
                textPlayer,      // scope
            );
            parser.skipEvent();
        })
        .on(`+${tagName}.to`, function (value, duration, ease) {
            AppendCommand.call(textPlayer,
                'camera.zoom.to',         // name
                ZoomTo,             // callback
                [value, duration, ease],  // params
                textPlayer,               // scope
            );
            parser.skipEvent();
        });
};

var Zoom = function (value) {
    // this: textPlayer
    this.camera.setZoom(value);
};

var ZoomTo = function (params) {
    // this: textPlayer
    this.camera.zoomTo(...params);
};

const GetValue$I = Phaser.Utils.Objects.GetValue;
const DegToRad$4 = Phaser.Math.DegToRad;

var OnParseRotateCameraTag = function (textPlayer, parser, config) {
    var tagName = GetValue$I(config, 'tags.camera.rotate', 'camera.rotate');
    parser
        .on(`+${tagName}`, function (value) {
            value = DegToRad$4(value);
            AppendCommand.call(textPlayer,
                'camera.rotate',  // name
                Rotate,           // callback
                value,            // params
                textPlayer,       // scope
            );
            parser.skipEvent();
        })
        .on(`+${tagName}.to`, function (value, duration, ease) {
            value = DegToRad$4(value);
            AppendCommand.call(textPlayer,
                'camera.rotate.to',       // name
                RotateTo,                 // callback
                [value, duration, ease],  // params
                textPlayer,               // scope
            );
            parser.skipEvent();
        });
};

var Rotate = function (value) {
    // this: textPlayer
    this.camera.setRotation(value);
};

var RotateTo = function (params) {
    var value = params[0];
    var duration = params[1];
    var ease = params[2];

    // this: textPlayer
    this.camera.rotateTo(value, false, duration, ease);
};

const GetValue$J = Phaser.Utils.Objects.GetValue;

var OnParseScrollCameraTag = function (textPlayer, parser, config) {
    var tagName = GetValue$J(config, 'tags.camera.scroll', 'camera.scroll');
    parser
        .on(`+${tagName}`, function (x, y) {
            AppendCommand.call(textPlayer,
                'camera.scroll',  // name
                Scroll,           // callback
                [x, y],           // params
                textPlayer,       // scope
            );
            parser.skipEvent();
        })
        .on(`+${tagName}.to`, function (x, y, duration, ease) {
            AppendCommand.call(textPlayer,
                'camera.scroll.to',       // name
                ScrollTo,                 // callback
                [x, y, duration, ease],   // params
                textPlayer,               // scope
            );
            parser.skipEvent();
        });
};

var Scroll = function (params) {
    // this: textPlayer
    this.camera.setScroll(...params);
};

var ScrollTo = function (params) {
    var x = params[0];
    var y = params[1];
    var duration = params[2];
    var ease = params[3];

    // this: textPlayer
    var camera = this.camera;
    var xSave = camera.scrollX;
    var ySave = camera.scrollY;
    camera.setScroll(x, y);
    x += camera.centerX;
    y += camera.centerY;
    camera.setScroll(xSave, ySave);

    // x,y in pan() is the centerX, centerY
    camera.pan(x, y, duration, ease);
};

const GetValue$K = Phaser.Utils.Objects.GetValue;

var OnParseWaitTag = function (textPlayer, parser, config) {
    var tagWait = GetValue$K(config, 'tags.wait', 'wait');
    var tagClick = GetValue$K(config, 'tags.click', 'click');
    parser
        .on(`+${tagWait}`, function (name) {
            AppendCommand$2(textPlayer, name);
            parser.skipEvent();
        })
        .on(`-${tagWait}`, function () {
            parser.skipEvent();
        })
        .on(`+${tagClick}`, function () {  // Equal to [wait=click]
            AppendCommand$2(textPlayer, 'click');
            parser.skipEvent();
        })
        .on(`-${tagClick}`, function () {  // Equal to [/wait]
            parser.skipEvent();
        });
};

var Wait = function (name) {
    this.typeWriter.wait(name);  // this: textPlayer
};

var AppendCommand$2 = function (textPlayer, name) {
    AppendCommand.call(textPlayer,
        'wait',       // name
        Wait,         // callback
        name,         // params
        textPlayer,   // scope
    );
};

const GetValue$L = Phaser.Utils.Objects.GetValue;

var IsAddSpriteTag = function (tags, prefix) {
    // sprite.name
    return (tags.length === 2) && (tags[0] === prefix)
};

var OnParseAddSpriteTag = function (textPlayer, parser, config) {
    var prefix = GetValue$L(config, 'sprite', 'sprite');
    if (!prefix) {
        return;
    }
    parser
        .on('+', function (tag, ...args) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [sprite.name=key,frame], or [sprite.name]
            var tags = tag.split('.');
            if (IsAddSpriteTag(tags, prefix)) {
                var name = tags[1];
                AppendCommand.call(textPlayer,
                    'sprite.add',      // name
                    AddSprite,         // callback
                    [name, ...args],   // params
                    textPlayer,        // scope
                );
            } else {
                return;
            }

            parser.skipEvent();
        })
        .on('-', function (tag) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [/sprite.name]
            var tags = tag.split('.');
            if (IsAddSpriteTag(tags, prefix)) {
                var name = tags[1];
                AppendCommand.call(textPlayer,
                    'sprite.remove',   // name
                    RemoveSprite,      // callback
                    name,              // params
                    textPlayer,        // scope
                );
            } else {
                return;
            }

            parser.skipEvent();
        });
};

var AddSprite = function (params) {
    // this: textPlayer
    this.spriteManager.add(...params);
};

var RemoveSprite = function (name) {
    // this: textPlayer
    this.spriteManager.remove(name);
};

const GetValue$M = Phaser.Utils.Objects.GetValue;

var OnParseRemoveAllSpritesTag = function (textPlayer, parser, config) {
    var prefix = GetValue$M(config, 'sprite', 'sprite');
    if (!prefix) {
        return;
    }
    parser
        .on('-', function (tag) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [/sprite]
            if (tag === prefix) {
                AppendCommand.call(textPlayer,
                    'sprite.removeall',    // name
                    RemoveAllSprites,      // callback
                    undefined,             // params
                    textPlayer,            // scope
                );
            } else {
                return;
            }

            parser.skipEvent();
        });
};

var RemoveAllSprites = function () {
    // this: textPlayer
    this.spriteManager.removeAll();
};

const GetValue$N = Phaser.Utils.Objects.GetValue;

var IsSetTextureTag = function (tags, prefix) {
    // sprite.name.texture
    return (tags.length === 3) && (tags[0] === prefix) && (tags[2] === 'texture')
};

var OnParseSetTextureTag = function (textPlayer, parser, config) {
    var prefix = GetValue$N(config, 'sprite', 'sprite');
    if (!prefix) {
        return;
    }
    parser
        .on('+', function (tag, textureKey, frameKey) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [sprite.name.texture=key,frame]
            var tags = tag.split('.');
            if (IsSetTextureTag(tags, prefix)) {
                var name = tags[1];
                AppendCommand.call(textPlayer,
                    'sprite.texture',               // name
                    SetTexture$1,                     // callback
                    [name, textureKey, frameKey],   // params
                    textPlayer,                     // scope
                );
            } else {
                return;
            }

            parser.skipEvent();
        });
};

var SetTexture$1 = function (params) {
    // this: textPlayer
    this.spriteManager.setTexture(...params);
};

const GetValue$O = Phaser.Utils.Objects.GetValue;

var IsPlayAnimationTag = function (tags, prefix) {
    // sprite.name.play 
    return (tags.length === 3) && (tags[0] === prefix) && (tags[2] === 'play');
};

var IsStopAnimationTag = function (tags, prefix) {
    // sprite.name.stop 
    return (tags.length === 3) && (tags[0] === prefix) && (tags[2] === 'stop');
};

var OnParsePlayAnimationTag = function (textPlayer, parser, config) {
    var prefix = GetValue$O(config, 'sprite', 'sprite');
    if (!prefix) {
        return;
    }
    parser
        .on('+', function (tag) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [sprite.name.play=key], or [sprite.name.play=key0,key1,...]
            var tags = tag.split('.');
            var name;
            if (IsPlayAnimationTag(tags, prefix)) {
                name = tags[1];
            } else {
                return;
            }
            var keys = Array.prototype.slice.call(arguments, 1);
            AppendCommand.call(textPlayer,
                'sprite.play',   // name
                PlayAnimation,   // callback
                [name, keys],     // params
                textPlayer,      // scope
            );
            parser.skipEvent();
        })
        .on('+', function (tag) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [sprite.name.stop]
            var tags = tag.split('.');
            var name;
            if (IsStopAnimationTag(tags, prefix)) {
                name = tags[1];
            } else {
                return;
            }
            AppendCommand.call(textPlayer,
                'sprite.stop',   // name
                StopAnimation,   // callback
                name,            // params
                textPlayer,      // scope
            );
            parser.skipEvent();
        })
        .on('-', function (tag) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [/sprite.name.play]
            var tags = tag.split('.');
            var name;
            if (IsPlayAnimationTag(tags, prefix)) {
                name = tags[1];
            } else {
                return;
            }
            AppendCommand.call(textPlayer,
                'sprite.stop',    // name
                StopAnimation,      // callback
                name,              // params
                textPlayer,        // scope
            );
            parser.skipEvent();
        });
};

var PlayAnimation = function (params) {
    var name = params[0];
    var keys = params[1];
    var key = keys.shift();

    // this: textPlayer
    this.spriteManager.playAnimation(name, key);
    if (keys.length > 0) {
        this.spriteManager.chainAnimation(name, keys);
    }
};

var StopAnimation = function (name) {
    // this: textPlayer
    this.spriteManager.stopAnimation(name);
};

const GetValue$P = Phaser.Utils.Objects.GetValue;

var IsChainAnimationTag = function (tags, prefix) {
    // sprite.name.chain 
    return (tags.length === 3) && (tags[0] === prefix) && (tags[2] === 'chain');
};

var OnParseChainAnimationTag = function (textPlayer, parser, config) {
    var prefix = GetValue$P(config, 'sprite', 'sprite');
    if (!prefix) {
        return;
    }
    parser
        .on('+', function (tag) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [sprite.name.chain=key]
            var tags = tag.split('.');
            var name;
            if (IsChainAnimationTag(tags, prefix)) {
                name = tags[1];
            } else {
                return;
            }
            var keys = Array.prototype.slice.call(arguments, 1);
            AppendCommand.call(textPlayer,
                'sprite.chain',   // name
                ChainAnimation,   // callback
                [name, keys],     // params
                textPlayer,       // scope
            );
            parser.skipEvent();
        });
};

var ChainAnimation = function (params) {
    // this: textPlayer
    this.spriteManager.chainAnimation(...params);
};

const GetValue$Q = Phaser.Utils.Objects.GetValue;

var IsPauseAnimationTag = function (tags, prefix) {
    // sprite.name.pause 
    return (tags.length === 3) && (tags[0] === prefix) && (tags[2] === 'pause');
};

var OnParsePauseAnimationTag = function (textPlayer, parser, config) {
    var prefix = GetValue$Q(config, 'sprite', 'sprite');
    if (!prefix) {
        return;
    }
    parser
        .on('+', function (tag) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [sprite.name.chain=key]
            var tags = tag.split('.');
            var name;
            if (IsPauseAnimationTag(tags, prefix)) {
                name = tags[1];
            } else {
                return;
            }
            AppendCommand.call(textPlayer,
                'sprite.pause',   // name
                PauseAnimation,   // callback
                name,             // params
                textPlayer,       // scope
            );
            parser.skipEvent();
        });
};

var PauseAnimation = function (name) {
    // this: textPlayer
    this.spriteManager.pauseAnimation(name);
};

const GetValue$R = Phaser.Utils.Objects.GetValue;

var IsSetPropertyTag = function (tags, prefix) {
    // sprite.name.prop
    return (tags.length === 3) && (tags[0] === prefix);
};

var OnParseSetSpritePropertyTag = function (textPlayer, parser, config) {
    var prefix = GetValue$R(config, 'sprite', 'sprite');
    if (!prefix) {
        return;
    }
    parser
        .on(`+`, function (tag, value) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [sprite.name.prop=value]
            var tags = tag.split('.');
            var name, property;
            if (IsSetPropertyTag(tags, prefix)) {
                name = tags[1];
                property = tags[2];
            } else {
                return;
            }
            AppendCommand.call(textPlayer,
                'sprite.set',                   // name
                SetProperty,                    // callback
                [name, property, value],        // params
                textPlayer,                     // scope
            );
            parser.skipEvent();
        });
};

var SetProperty = function (params) {
    // this: textPlayer
    this.spriteManager.setProperty(...params);
};

const GetValue$S = Phaser.Utils.Objects.GetValue;

var EaseMode = {
    to: true,
    yoyo: true
};

var IsEasePropertyTag = function (tags, prefix) {
    // sprite.name.prop.to, or sprite.name.prop.yoyo
    return (tags.length === 4) && (tags[0] === prefix) && EaseMode[tags[3]];
};

var OnParseEaseSpritePropertyTag = function (textPlayer, parser, config) {
    var prefix = GetValue$S(config, 'sprite', 'sprite');
    if (!prefix) {
        return;
    }
    parser
        .on(`+`, function (tag, value, duration, ease) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            // [sprite.name.prop.to=value,duration,ease]
            var tags = tag.split('.');
            var name, property, isYoyo;
            if (IsEasePropertyTag(tags, prefix)) {
                name = tags[1];
                property = tags[2];
                isYoyo = (tags[3] === 'yoyo');
            } else {
                return;
            }
            AppendCommand.call(textPlayer,
                'sprite.ease',               // name
                EaseProperty,                // callback
                [
                    name, property, value,
                    duration, ease, isYoyo
                ],                            // params
                textPlayer,                   // scope
            );
            parser.skipEvent();
        });
};

var EaseProperty = function (params) {
    // this: textPlayer
    this.spriteManager.easeProperty(...params);
};

var OnParseCustomTag = function (textPlayer, parser, config) {
    parser
        .on('start', function () {
            textPlayer.emit('parser.start', parser);
        })
        .on('+', function (tagName, ...value) {
            if (parser.skipEventFlag) {  // Has been processed before
                return;
            }

            var startTag = `+${tagName}`;
            textPlayer.emit(`parser.${startTag}`, parser, ...value);
            AppendCommand$3(textPlayer, startTag, value);
        })
        .on('-', function (tagName) {
            if (parser.skipEventFlag) {
                return;
            }

            var endTag = `-${tagName}`;
            textPlayer.emit(`parser.${endTag}`, parser);
            AppendCommand$3(textPlayer, endTag);
        })
        .on('complete', function () {
            textPlayer.emit('parser.complete', parser);
        });
};

var FireEvent$1 = function (param, tagName) {
    var eventName = `tag.${tagName}`;
    // this: textPlayer
    if (param == null) {
        this.emit(eventName);
    } else {
        this.emit(eventName, ...param);
    }

};

var AppendCommand$3 = function (textPlayer, name, param) {
    AppendCommand.call(textPlayer,
        name,         // name
        FireEvent$1,    // callback
        param,        // params
        textPlayer,   // scope
    );
};

const GetValue$T = Phaser.Utils.Objects.GetValue;

var OnParseBoldTag$1 = function (textPlayer, parser, config) {
    var tagName = GetValue$T(config, 'tags.r', 'r');
    parser
        .on(`+${tagName}`, function () {
            AppendText.call(textPlayer, '\n');
            parser.skipEvent();
        })
        .on(`-${tagName}`, function () {            
            parser.skipEvent();
        });
};

var OnParseContent = function (textPlayer, parser, config) {
    parser
        .on('content', function (content) {
            AppendText.call(textPlayer, content);
        });
};

const ParseCallbacks = [
    OnParseColorTag, OnParseStrokeColorTag,
    OnParseBoldTag, OnParseItalicTag,
    OnParseFontSizeTag, OnParseOffsetYTag, OnParseShadowColorTag, OnParseImageTag,
    OnParseTypingSpeedTag,
    OnParsePlaySoundEffectTag, OnParseFadeInSoundEffectTag, OnParseFadeOutSoundEffectTag, OnParseSetSoundEffectVolumeTag,
    OnParsePlayBackgroundMusicTag, OnParseFadeInBackgroundMusicTag, OnParseFadeOutBackgroundMusicTag, OnParseCrossFadeBackgroundMusicTag, OnParsePauseBackgroundMusicTag,
    OnParseFadeInCameraTag, OnParseFadeOutCameraTag, OnParseShakeCameraTag, OnParseFlashCameraTag, OnParseZoomCameraTag, OnParseRotateCameraTag, OnParseScrollCameraTag,
    OnParseWaitTag,
    OnParseAddSpriteTag, OnParseRemoveAllSpritesTag,
    OnParseSetTextureTag, OnParsePlayAnimationTag, OnParseChainAnimationTag, OnParsePauseAnimationTag,
    OnParseSetSpritePropertyTag, OnParseEaseSpritePropertyTag, // Add ParseSetSpritePropertyTag later    
    OnParseCustomTag,
    OnParseBoldTag$1, OnParseContent
];

var AddParseCallbacks = function (textPlayer, parser, config) {
    for (var i = 0, cnt = ParseCallbacks.length; i < cnt; i++) {
        ParseCallbacks[i](textPlayer, parser, config);
    }
};

/*
Skip line
- An empty line, only has space
- A comment line, start with commentLineStart ('//')
*/

var PreProcess = function (parser, source) {
    var comentLineStart = parser.commentLineStart;
    var lines = source.split('\n');
    for (var i = 0, cnt = lines.length; i < cnt; i++) {
        var line = lines[i];
        if (line === '') ; else if (line.trim().length === 0) {
            // An empty line, only has space
            lines[i] = '';

        } else if (comentLineStart && line.startsWith(comentLineStart)) {
            // A comment line, start with commentLineStart ('//')
            lines[i] = '';
        }
    }
    // Use [r] to put \n
    return lines.join('');
};

const GetValue$U = Phaser.Utils.Objects.GetValue;

class Parser extends BracketParser {
    constructor(textPlayer, config) {
        if (config === undefined) {
            config = {};
        }
        if (!config.hasOwnProperty('delimiters')) {
            config.delimiters = '[]';
        }
        super(config);

        AddParseCallbacks(textPlayer, this, config);

        this.setCommentLineStartSymbol(GetValue$U(config, 'comment', '//'));
    }

    setCommentLineStartSymbol(symbol) {
        this.commentLineStart = symbol;
        return this;
    }

    start(source) {
        super.start(PreProcess(this, source));
        return this;
    }
}

var WaitEvent = function (eventEmitter, eventName) {
    return new Promise(function (resolve, reject) {
        eventEmitter.once(eventName, function () {
            resolve();
        });
    });
};

var WaitComplete = function (eventEmitter) {
    return WaitEvent(eventEmitter, 'complete');
};

var Start = function (children) {
    this.children = children;
    this.index = 0;
    this.isPageTyping = true;

    if (this.onTypeStart) {
        this.onTypeStart(children);
    }
    this.typing();

    return WaitComplete(this);  // Promise
};

const TypingDelayTimerType = 'delay';
const TypingAnimationTimerType = 'anim';

var Typing = function (offsetTime) {
    if (offsetTime === undefined) {
        offsetTime = 0;
    }

    var delay = 0;
    this.inTypingProcessLoop = true;
    while (this.inTypingProcessLoop) {
        var child = this.getNextChild();
        if (!child) {
            if (this.timeline.isRunning) {
                // Wait until last animationConfig is end
                this.timeline.once('complete', function () {
                    this.isPageTyping = false;
                    this.emit('complete');
                }, this);
            } else {
                this.isPageTyping = false;
                this.emit('complete');
            }
            break;  // Leave this typing loop
        }

        if (IsTypeable(child)) {
            // Typing this char
            var animationConfig = this.animationConfig;
            if (animationConfig.duration > 0) {
                var animationTimer = this.timeline.addTimer({
                    name: TypingAnimationTimerType,
                    target: child,
                    duration: animationConfig.duration,
                    yoyo: animationConfig.yoyo,
                    onStart: animationConfig.onStart,
                    onProgress: animationConfig.onProgress,
                    onComplete: animationConfig.onComplete,
                });
                if (this.skipTypingAnimation) {
                    animationTimer.seek(1);
                }
            } else {  // No animationConfig, only invoke onStart callback
                if (animationConfig.onStart) {
                    animationConfig.onStart(child, 0);
                }
            }
            this.textPlayer.emit('typing', child);

            delay += (this.speed + offsetTime);
            offsetTime = 0;
            var isLastChild = (this.index === this.children.length);  // this.index: Point to next child
            if ((delay > 0) && !isLastChild) {
                // Process next character later
                this.typingTimer = this.timeline.addTimer({
                    name: TypingDelayTimerType,
                    target: this,
                    duration: delay,
                    onComplete: function (target, t, timer) {
                        target.typingTimer = undefined;
                        Typing.call(target, timer.remainder);
                    }
                });
                break;  // Leave this typing loop                
            }
            // Process next child
        } else if (IsCommand(child)) {
            child.exec();
            // Process next child
        }

    }

    this.inTypingProcessLoop = false;
};

var Pause = function () {
    // Pause typing timer and animation progresses
    this.timeline.pause(); 
    return this;
};

var Resume = function () {
    // Resume typing timer and animation progresses
    this.timeline.resume();
    return this;
};

var PauseTyping = function () {
    // Already in typingPaused state
    if (this.isTypingPaused) {
        return this;
    }

    if (this.typingTimer) {  // Pause when typing timer is counting
        this.typingTimer.pause();
        this.isTypingPaused = true;
    } else if (this.inTypingProcessLoop) {  // Pause in loop of typing(), by tag
        this.inTypingProcessLoop = false;
        this.isTypingPaused = true;
    }
    return this;
};

var ResumeTyping = function (offsetTime) {
    // Already not in typingPaused state
    if (!this.isTypingPaused) {
        return this;
    }
    if (offsetTime === undefined) {
        offsetTime = 0;
    }

    if (this.typingTimer) {  // Pause when typing timer is paused
        this.isTypingPaused = false;
        this.typingTimer.resume();
        this.typingTimer.remainder += offsetTime;
    } else if (this.isTypingPaused) {  // Resume paused by tag
        this.isTypingPaused = false;
        this.typing(offsetTime);
    }
    return this;
};

// Internal events

const RemoveWaitEvents = '_remove.wait';
const StopPlayEvent = '_remove.play';

const ClearEvents = [
    RemoveWaitEvents,
    StopPlayEvent
];

var GetWrapCallback = function (textPlayer, callback, args, scope, removeFrom) {
    return function () {
        textPlayer.emit(RemoveWaitEvents, removeFrom); // Remove all wait events
        callback.apply(scope, args);
    }
};

var WaitCallback = function (textPlayer, postfixName, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'custom');

    var eventName = (postfixName) ? `wait.${postfixName}` : 'wait';
    textPlayer.emit(eventName, wrapCallback);
};

var DelayCall = function (textPlayer, delay, callback, args, scope) {
    return textPlayer.typeWriter.timeline.delayCall(delay, callback, args, scope);
};

var WaitTime = function (textPlayer, time, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'time');

    var timer;

    // Remove all wait events
    textPlayer.once(RemoveWaitEvents, function () {
        if (timer) {
            timer.remove();
            timer = undefined;
        }
    });

    timer = DelayCall(textPlayer, time, wrapCallback);

    textPlayer.emit('wait.time', time);
};

var WaitClick = function (textPlayer, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'click');

    var clickEE = textPlayer.clickEE;

    // Remove all wait events
    textPlayer.once(RemoveWaitEvents, function () {
        clickEE.off('pointerdown', wrapCallback, textPlayer);
    });

    clickEE.once('pointerdown', wrapCallback, textPlayer);

    textPlayer.emit('wait.click');
};

var WaitMusic = function (textPlayer, music, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'music');

    if (music) {
        // Remove all wait events
        textPlayer.once(RemoveWaitEvents, function () {
            music.off('complete', wrapCallback, textPlayer);
        });

        music.once('complete', wrapCallback, textPlayer);
    }

    textPlayer.emit('wait.music', music);

    if (!music) {
        wrapCallback();
    }
};

var IsWaitCameraEffect = function (name) {
    switch (name) {
        case 'camera.fadein':
        case 'camera.fadeout':
        case 'camera.flash':
        case 'camera.shake':
        case 'camera.zoom':
        case 'camera.rotate':
        case 'camera.scroll':
            return true;
        default:
            return false;
    }
};

var WaitCameraEffect = function (textPlayer, effectName, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, `camera.${effectName}`);

    var camera = textPlayer.camera;

    var effect, completeEventName;
    switch (effectName) {
        case 'camera.fadein':
            effect = camera.fadeEffect;
            completeEventName = 'camerafadeincomplete';
            break;

        case 'camera.fadeout':
            effect = camera.fadeEffect;
            completeEventName = 'camerafadeoutcomplete';
            break;

        case 'camera.flash':
            effect = camera.flashEffect;
            completeEventName = 'cameraflashcomplete';
            break;

        case 'camera.shake':
            effect = camera.shakeEffect;
            completeEventName = 'camerashakecomplete';
            break;

        case 'camera.zoom':
            effect = camera.zoomEffect;
            completeEventName = 'camerazoomcomplete';
            break;

        case 'camera.rotate':
            effect = camera.rotateToEffect;
            completeEventName = 'camerarotatecomplete';
            break;

        case 'camera.scroll':
            effect = camera.panEffect;
            completeEventName = 'camerapancomplete';
            break;
    }

    if (!effect.isRunning) {
        textPlayer.emit('wait.camera', effectName);
        wrapCallback();

    } else {
        // Remove all wait events
        textPlayer.once(RemoveWaitEvents, function (removeFrom) {
            camera.off(completeEventName, wrapCallback, textPlayer);
        });
        camera.once(completeEventName, wrapCallback, textPlayer);
        textPlayer.emit('wait.camera', effectName);
    }

};

var WaitKey = function (textPlayer, keyName, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'keydown');

    var eventName = `keydown-${keyName.toUpperCase()}`;
    var keyboard = textPlayer.scene.input.keyboard;

    // Remove all wait events
    textPlayer.once(RemoveWaitEvents, function () {
        keyboard.off(eventName, wrapCallback, textPlayer);
    });

    keyboard.once(eventName, wrapCallback, textPlayer);

    textPlayer.emit('wait.keydown', keyName);
};

var IsWaitSprite = function (name) {
    // sprite, sprite.name, sprite.name.prop
    var names = name.split('.');
    return (names[0] === 'sprite') && (names.length <= 3);
};

var WaitSprite = function (textPlayer, tag, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope);
    var tags = tag.split('.');
    var spriteManager = textPlayer.spriteManager;
    switch (tags.length) {
        case 1:  // sprite: wait all sprites has beeen destroyed
            if (spriteManager.isEmpty) {
                textPlayer.emit('wait.sprite');
                wrapCallback();
            } else {
                // Remove all wait events
                textPlayer.once(RemoveWaitEvents, function (removeFrom) {
                    spriteManager.off('empty', wrapCallback, textPlayer);
                });
                spriteManager.once('empty', wrapCallback, textPlayer);
                textPlayer.emit('wait.sprite');
            }
            break;

        case 2:  // sprite.name: wait sprite.name has been destroyed
            var name = tags[1];
            if (spriteManager.has(name)) {
                var spriteData = textPlayer.spriteManager.get(name);
                var sprite = spriteData.sprite;
                // Remove all wait events
                textPlayer.once(RemoveWaitEvents, function () {
                    sprite.off('destroy', wrapCallback, textPlayer);
                });

                sprite.once('destroy', wrapCallback, textPlayer);
                textPlayer.emit('wait.sprite', name);
            } else {
                textPlayer.emit('wait.sprite', name);
                wrapCallback();
            }
            break;

        case 3:  // sprite.name.prop: wait ease sprite.name.prop has been completed
            var name = tags[1];
            var prop = tags[2];
            var task = textPlayer.spriteManager.getTweenTask(name, prop);
            if (task) {
                // Remove all wait events
                textPlayer.once(RemoveWaitEvents, function () {
                    task.off('complete', wrapCallback, textPlayer);
                });

                task.once('complete', wrapCallback, textPlayer);
                textPlayer.emit('wait.sprite', name, prop);
            } else {
                textPlayer.emit('wait.sprite', name, prop);
                wrapCallback();
            }
            break;
    }

};

const KeyCodes = Phaser.Input.Keyboard.KeyCodes;

var WaitMultiple = function (textPlayer, names, callback, args, scope) {
    if ((typeof (names) === 'string') && (names.length > 1) && (names.indexOf('|') !== -1)) {
        names = names.split('|');
    } else {
        names = [names];
    }

    for (var i = 0, cnt = names.length; i < cnt; i++) {
        var name = names[i];

        if ((name == null) || (name === 'wait')) {  // Wait event
            WaitCallback(textPlayer, undefined, callback, args, scope);

        } else if ((typeof (name) === 'number') || !isNaN(name)) { // A number, or a number string
            WaitTime(textPlayer, parseFloat(name), callback, args, scope);

        } else if (name === 'click') {  // 'click'
            WaitClick(textPlayer, callback, args, scope);

        } else if (name === 'se') {
            var music = textPlayer.soundManager.getLastSoundEffect();
            WaitMusic(textPlayer, music, callback, args, scope);

        } else if (name === 'bgm') {
            var music = textPlayer.soundManager.getBackgroundMusic();
            WaitMusic(textPlayer, music, callback, args, scope);

        } else if (KeyCodes.hasOwnProperty(name.toUpperCase())) {
            WaitKey(textPlayer, name, callback, args, scope);

        } else if (IsWaitCameraEffect(name)) {
            WaitCameraEffect(textPlayer, name, callback, args, scope);

        } else if (IsWaitSprite(name)) {
            WaitSprite(textPlayer, name, callback, args, scope);

        } else {
            WaitCallback(textPlayer, name, callback, args, scope);

        }
    }
};

var Wait$1 = function (name) {
    // Already in typingPaused state, or ignore any wait
    if (this.ignoreWait) {
        return this;
    }

    this.pauseTyping();
    WaitMultiple(this.textPlayer, name, this.resumeTyping, [], this);

    return this;
};

var SetTimeScale = function (value) {
    this.timeline.setTimeScale(value);
    return this;
};

var SetIgnoreWait = function (value) {
    if (value === undefined) {
        value = true;
    }
    this.ignoreWait = value;
    return this;
};

var SetSkipTypingAnimation = function (value) {
    if (value === undefined) {
        value = true;
    }
    this.skipTypingAnimation = value;

    if (value) {
        // Skip current playing typing-animation
        var timers = this.timeline.getTimers(TypingAnimationTimerType);
        for (var i = 0, cnt = timers.length; i < cnt; i++) {
            timers[i].seek(1);
        }
    }
    return this;
};

var SetSkipSoundEffect = function (value) {
    if (value === undefined) {
        value = true;
    }
    this.skipSoundEffect = value;

    if (value) {
        var soundManager = this.textPlayer._soundManager;
        if (soundManager) {
            soundManager.fadeOutAllSoundEffects(100, true);
        }
    }
    return this;
};

var SkipCurrentTypingDelay = function () {
    if (this.typingTimer) {
        this.typingTimer.seek(1);
    }
    return this;
};

var Methods$2 = {
    start: Start,
    typing: Typing,
    pause: Pause,
    resume: Resume,
    pauseTyping: PauseTyping,
    resumeTyping: ResumeTyping,
    wait: Wait$1,
    setTimeScale: SetTimeScale,
    setIgnoreWait: SetIgnoreWait,
    setSkipTypingAnimation: SetSkipTypingAnimation,
    setSkipSoundEffect: SetSkipSoundEffect,
    skipCurrentTypingDelay: SkipCurrentTypingDelay,
};

const SceneClass = Phaser.Scene;
var IsSceneObject = function (object) {
    return (object instanceof SceneClass);
};

var GetSceneObject = function (object) {
    if ((object == null) || (typeof (object) !== 'object')) {
        return null;
    } else if (IsSceneObject(object)) { // object = scene
        return object;
    } else if (object.scene && IsSceneObject(object.scene)) { // object = game object
        return object.scene;
    } else if (object.parent && object.parent.scene && IsSceneObject(object.parent.scene)) { // parent = bob object
        return object.parent.scene;
    }
};

const GetValue$V = Phaser.Utils.Objects.GetValue;

class ComponentBase {
    constructor(parent, config) {
        this.parent = parent;  // gameObject or scene
        this.scene = GetSceneObject(parent);
        this.isShutdown = false;

        // Event emitter, default is private event emitter
        this.setEventEmitter(GetValue$V(config, 'eventEmitter', true));

        // Register callback of parent destroy event, also see `shutdown` method
        if (this.parent && (this.parent === this.scene)) { // parent is a scene
            this.scene.events.once('shutdown', this.onSceneDestroy, this);
        } else if (this.parent && this.parent.once) { // bob object does not have event emitter
            this.parent.once('destroy', this.onParentDestroy, this);
        }
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        // parent might not be shutdown yet
        if (this.parent && (this.parent === this.scene)) { // parent is a scene
            this.scene.events.off('shutdown', this.onSceneDestroy, this);
        } else if (this.parent && this.parent.once) { // bob object does not have event emitter
            this.parent.off('destroy', this.onParentDestroy, this);
        }

        this.destroyEventEmitter();
        this.parent = undefined;
        this.scene = undefined;
        this.isShutdown = true;
    }

    destroy(fromScene) {
        this.shutdown(fromScene);
    }

    onSceneDestroy() {
        this.destroy(true);
    }

    onParentDestroy(parent, fromScene) {
        this.destroy(fromScene);
    }

}
Object.assign(
    ComponentBase.prototype,
    EventEmitterMethods
);

const GetValue$W = Phaser.Utils.Objects.GetValue;

class TickTask extends ComponentBase {
    constructor(parent, config) {
        super(parent, config);

        this._isRunning = false;
        this.isPaused = false;
        this.tickingState = false;
        this.setTickingMode(GetValue$W(config, 'tickingMode', 1));
        // boot() later
    }

    // override
    boot() {
        if ((this.tickingMode === 2) && (!this.tickingState)) {
            this.startTicking();
        }
    }

    // override
    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        this.stop();
        if (this.tickingState) {
            this.stopTicking();
        }
        super.shutdown(fromScene);
    }

    setTickingMode(mode) {
        if (typeof (mode) === 'string') {
            mode = TICKINGMODE[mode];
        }
        this.tickingMode = mode;
    }

    // override
    startTicking() {
        this.tickingState = true;
    }

    // override
    stopTicking() {
        this.tickingState = false;
    }

    get isRunning() {
        return this._isRunning;
    }

    set isRunning(value) {
        if (this._isRunning === value) {
            return;
        }

        this._isRunning = value;
        if ((this.tickingMode === 1) && (value != this.tickingState)) {
            if (value) {
                this.startTicking();
            } else {
                this.stopTicking();
            }
        }
    }

    start() {
        this.isPaused = false;
        this.isRunning = true;
        return this;
    }

    pause() {
        // Only can ba paused in running state
        if (this.isRunning) {
            this.isPaused = true;
            this.isRunning = false;
        }
        return this;
    }

    resume() {
        // Only can ba resumed in paused state (paused from running state)
        if (this.isPaused) {
            this.isRunning = true;
        }
        return this;
    }

    stop() {
        this.isPaused = false;
        this.isRunning = false;
        return this;
    }

    complete() {
        this.isPaused = false;
        this.isRunning = false;
        this.emit('complete', this.parent, this);
    }
}

const TICKINGMODE = {
    'no': 0,
    'lazy': 1,
    'always': 2
};

const GetValue$X = Phaser.Utils.Objects.GetValue;

class BaseClock extends TickTask {
    constructor(parent, config) {
        super(parent, config);

        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        this.isRunning = GetValue$X(o, 'isRunning', false);
        this.timeScale = GetValue$X(o, 'timeScale', 1);
        this.now = GetValue$X(o, 'now', 0);
        return this;
    }

    toJSON() {
        return {
            isRunning: this.isRunning,
            timeScale: this.timeScale,
            now: this.now,
            tickingMode: this.tickingMode
        };
    }

    // Override
    // startTicking() { }

    // Override
    // stopTicking() {}

    start(startAt) {
        if (startAt === undefined) {
            startAt = 0;
        }
        this.delta = 0;
        this.now = startAt;
        super.start();
        return this;
    }

    seek(time) {
        this.now = time;
        return this;
    }

    setTimeScale(value) {
        this.timeScale = value;
        return this;
    }

    tick(delta) {
        delta *= this.timeScale;
        this.now += delta;
        this.delta = delta;
        this.emit('update', this.now, this.delta);
        return this;
    }
}

class Clock extends BaseClock {
    startTicking() {
        super.startTicking();
        this.scene.events.on('update', this.update, this);
    }

    stopTicking() {
        super.stopTicking();
        if (this.scene) { // Scene might be destoryed
            this.scene.events.off('update', this.update, this);
        }
    }

    update(time, delta) {
        if ((!this.isRunning) || (this.timeScale === 0)) {
            return this;
        }
        this.tick(delta);
        return this;
    }
}

var Yoyo = function (t, threshold) {
    if (threshold === undefined) {
        threshold = 0.5;
    }
    if (t <= threshold) {
        t = t / threshold;
    } else {
        t = 1 - ((t - threshold) / (1 - threshold));
    }

    return t;
};

const Clamp = Phaser.Math.Clamp;

class Timer {
    constructor(timeline, config) {
        this
            .setTimeline(timeline)
            .reset(config);
    }

    setTimeline(timeline) {
        this.timeline = timeline;
        return this;
    }

    setName(name) {
        this.name = name;
        return this;
    }

    setCallbacks(target, onStart, onProgress, onComplete) {
        this.target = target;
        this.onStart = onStart;
        this.onProgress = onProgress;
        this.onComplete = onComplete;
        return this;
    }

    setDuration(duration, yoyo) {
        if (yoyo === undefined) {
            yoyo = false;
        }
        this.duration = duration;
        this.remainder = duration;
        this.t = 0;
        this.yoyo = yoyo;
        return this;
    }

    setPaused(state) {
        this.isPaused = state;
        return this;
    }

    pause() {
        this.isPaused = true;
        return this;
    }

    resume() {
        this.isPaused = false;
        return this;
    }

    setRemoved(state) {
        this.removed = state;
        return this;
    }

    remove() {
        this.removed = true;
        return this;
    }

    seek(t) {
        this.remainder = this.duration * (1 - t);
        return this;
    }

    reset(o) {
        this
            .setName(o.name)
            .setDuration(o.duration, o.yoyo)
            .setCallbacks(o.target, o.onStart, o.onProgress, o.onComplete)
            .setPaused(false)
            .setRemoved(false);
        return this;
    }

    onFree() {
        this
            .setTimeline()
            .setCallbacks();
    }

    getProgress() {
        var value = 1 - (this.remainder / this.duration);
        value = Clamp(value, 0, 1);
        if (this.yoyo) {
            value = Yoyo(value);
        }
        return value;
    }

    setProgress(value) {
        value = Clamp(value, 0, 1);
        this.remainder = this.duration * (1 - value);
    }

    runCallback(callback) {
        if (!callback) {
            return;
        }
        callback(this.target, this.t, this);
    }

    update(time, delta) {
        if (this.removed) {
            return true;
        } else if (this.isPaused) {
            return false;
        }

        this.remainder -= delta;
        this.t = this.getProgress();
        this.runCallback(this.onProgress);

        var isCompleted = (this.remainder <= 0);
        if (isCompleted) {
            this.runCallback(this.onComplete);
        }
        return isCompleted;
    }
}

class TimerPool extends Stack {
    allocate() {
        return this.pop();
    }

    free(timer) {
        timer.onFree();
        this.push(timer);
    }

    freeMultiple(arr) {
        for (var i = 0, cnt = arr.length; i < cnt; i++) {
            this.free(arr[i]);
        }
        return this;
    }
}

const GetValue$Y = Phaser.Utils.Objects.GetValue;
const TimerPool$1 = new TimerPool();

class Timeline extends Clock {
    constructor(parent, config) {
        super(parent, config);

        this.addedTimers = [];
        this.timers = [];
        this.timerPool = GetValue$Y(config, 'pool', TimerPool$1);
    }

    shutdown() {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        this.timerPool
            .freeMultiple(this.addedTimers)
            .freeMultiple(this.timers);

        this.timerPool = undefined;
        this.addedTimers = undefined;
        this.timers = undefined;

        super.shutdown();
    }

    addTimer(config) {
        var timer = this.timerPool.allocate();
        if (!timer) {
            timer = new Timer(this, config);
        } else {
            timer
                .setTimeline(this)
                .reset(config);
        }
        this.addedTimers.push(timer);
        timer.runCallback(timer.onStart);

        if (!this.isRunning) {
            this.start();
        }
        return timer;
    }

    delayCall(delay, callback, args, scope) {
        var timer = this.addTimer({
            duration: delay,
            onComplete: function (target, t, timer) {
                if (args === undefined) {
                    args = [];
                }
                args.push(timer);
                callback.apply(scope, args);
            }
        });
        return timer;
    }

    getTimers(name) {
        var timers = [];

        var timerQueues = [this.addedTimers, this.timers];
        for (var ti = 0, tcnt = timerQueues.length; ti < tcnt; ti++) {
            var timerQueue = timerQueues[ti];
            for (var i = 0, cnt = timerQueue.length; i < cnt; i++) {
                var timer = timerQueue[i];
                if (timer.name === name) {
                    timers.push(timer);
                }
            }
        }
        return timers;
    }

    update(time, delta) {
        super.update(time, delta);

        this.timers.push(...this.addedTimers);
        this.addedTimers.length = 0;
        var pendingTimers = [];
        for (var i = 0, cnt = this.timers.length; i < cnt; i++) {
            var timer = this.timers[i];
            var isStopped = timer.update(this.now, this.delta);
            if (isStopped) {
                this.timerPool.free(timer);  // Free timer
            } else {
                pendingTimers.push(timer);  // Add to timer queue
            }
        }
        this.timers = pendingTimers;

        if ((this.timers.length === 0) && (this.addedTimers.length === 0)) {
            this.complete(); // Emit 'complete' event
        }
    }
}

const GetValue$Z = Phaser.Utils.Objects.GetValue;

class TypeWriter {
    constructor(textPlayer, config) {
        this.setEventEmitter();
        this.textPlayer = textPlayer;
        this.isPageTyping = false;
        this.timeline = new Timeline(textPlayer);
        this.typingTimer = undefined;  // Typing delay
        this.pauseTypingTimer = undefined;  // Wait time
        this.inTypingProcessLoop = false;  // Used in this.typing()
        this.isTypingPaused = false;  // Used in this.wait(), this.pauseTyping(), this.resumeTyping()
        this.setIgnoreWait(false);
        this.setSkipTypingAnimation(false);

        this.setTypingStartCallback(GetValue$Z(config, 'onTypingStart', SetChildrenInvisible));
        this.setSpeed(GetValue$Z(config, 'speed', 250));
        this.setAnimationConfig(GetValue$Z(config, 'animation', undefined));
    }

    destroy() {
        this.destroyEventEmitter();

        this.textPlayer = undefined;

        this.timeline.destroy();
        this.timeline = undefined;

        this.typingTimer = undefined;

        this.pauseTypingTimer = undefined;

        this.onTypeStart = undefined;

        this.animationConfig = undefined;
    }

    setSpeed(speed) {
        this.speed = speed;
        return this;
    }

    setTypingStartCallback(callback) {
        this.onTypeStart = callback;
        return this;
    }

    setAnimationConfig(config) {
        if (config === undefined) {
            config = {};
        } else if (config === false) {
            config = {
                duration: 0
            };
        }
        if (!config.hasOwnProperty('duration')) {
            // Apply default duration
            config.duration = 1000;
        }
        if (!config.hasOwnProperty('onStart')) {
            // Apply default onStart callback
            config.onStart = SetChildVisible;
        }
        this.animationConfig = config;
        return this;
    }

    getNextChild() {
        var child = this.children[this.index];
        this.index = Math.min(this.index + 1, this.children.length);  // Point to next child
        return child;
    }
}

var SetChildVisible = function (child) {
    child.setVisible();
};

var SetChildrenInvisible = function (children) {
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        children[i].setVisible(false);
    }
};

Object.assign(
    TypeWriter.prototype,
    EventEmitterMethods,
    Methods$2,
);

class SceneUpdateTickTask extends TickTask {
    startTicking() {
        super.startTicking();
        this.scene.events.on('update', this.update, this);
    }

    stopTicking() {
        super.stopTicking();
        if (this.scene) { // Scene might be destoryed
            this.scene.events.off('update', this.update, this);
        }
    }

    // update(time, delta) {
    //     
    // }

}

const GetValue$_ = Phaser.Utils.Objects.GetValue;
const Clamp$1 = Phaser.Math.Clamp;

class Timer$1 {
    constructor(config) {
        this.resetFromJSON(config);
    }

    resetFromJSON(o) {
        this.state = GetValue$_(o, 'state', IDLE);
        this.timeScale = GetValue$_(o, 'timeScale', 1);
        this.delay = GetValue$_(o, 'delay', 0);
        this.repeat = GetValue$_(o, 'repeat', 0);
        this.repeatCounter = GetValue$_(o, 'repeatCounter', 0);
        this.duration = GetValue$_(o, 'duration', 0);
        this.nowTime = GetValue$_(o, 'nowTime', 0);
        this.justRestart = GetValue$_(o, 'justRestart', false);
    }

    toJSON() {
        return {
            state: this.state,
            timeScale: this.timeScale,
            delay: this.delay,
            repeat: this.repeat,
            repeatCounter: this.repeatCounter,
            duration: this.duration,
            nowTime: this.nowTime,
            justRestart: this.justRestart,
        }
    }

    destroy() {

    }

    setTimeScale(timeScale) {
        this.timeScale = timeScale;
        return this;
    }

    setDelay(delay) {
        if (delay === undefined) {
            delay = 0;
        }
        this.delay = delay;
        return this;
    }

    setDuration(duration) {
        this.duration = duration;
        return this;
    }

    setRepeat(repeat) {
        this.repeat = repeat;
        return this;
    }

    setRepeatInfinity() {
        this.repeat = -1;
        return this;
    }

    start() {
        this.nowTime = (this.delay > 0) ? -this.delay : 0;
        this.state = (this.nowTime >= 0) ? COUNTDOWN : DELAY;
        this.repeatCounter = 0;
        return this;
    }

    stop() {
        this.state = IDLE;
        return this;
    }

    update(time, delta) {
        if (this.state === IDLE || this.state === DONE ||
            delta === 0 || this.timeScale === 0
        ) {
            return;
        }

        this.nowTime += (delta * this.timeScale);
        this.state = (this.nowTime >= 0) ? COUNTDOWN : DELAY;

        this.justRestart = false;
        if (this.nowTime >= this.duration) {
            if ((this.repeat === -1) || (this.repeatCounter < this.repeat)) {
                this.repeatCounter++;
                this.justRestart = true;
                this.nowTime -= this.duration;
            } else {
                this.nowTime = this.duration;
                this.state = DONE;
            }
        }
    }

    get t() {
        var t;
        switch (this.state) {
            case IDLE:
            case DELAY:
                t = 0;
                break;

            case COUNTDOWN:
                t = this.nowTime / this.duration;
                break;

            case DONE:
                t = 1;
                break;
        }
        return Clamp$1(t, 0, 1);
    }

    set t(value) {
        value = Clamp$1(value, -1, 1);
        if (value < 0) {
            this.state = DELAY;
            this.nowTime = -this.delay * value;
        } else {
            this.state = COUNTDOWN;
            this.nowTime = this.duration * value;

            if ((value === 1) && (this.repeat !== 0)) {
                this.repeatCounter++;
            }
        }
    }

    get isIdle() {
        return this.state === IDLE;
    }

    get isDelay() {
        return this.state === DELAY;
    }

    get isCountDown() {
        return this.state === COUNTDOWN;
    }

    get isRunning() {
        return this.state === DELAY || this.state === COUNTDOWN;
    }

    get isDone() {
        return this.state === DONE;
    }

    get isOddIteration() {
        return (this.repeatCounter & 1) === 1;
    }

    get isEvenIteration() {
        return (this.repeatCounter & 1) === 0;
    }

}

const IDLE = 0;
const DELAY = 1;
const COUNTDOWN = 2;
const DONE = -1;

class TimerTickTask extends SceneUpdateTickTask {
    constructor(parent, config) {
        super(parent, config);
        this.timer = new Timer$1();
        // boot() later 
    }

    // override
    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        super.shutdown(fromScene);
        this.timer.destroy();
        this.timer = undefined;
    }

    start() {
        this.timer.start();
        super.start();
        return this;
    }

    stop() {
        this.timer.stop();
        super.stop();
        return this;
    }

    complete() {
        this.timer.stop();
        super.complete();
        return this;
    }

}

const GetValue$$ = Phaser.Utils.Objects.GetValue;
const GetAdvancedValue$1 = Phaser.Utils.Objects.GetAdvancedValue;
const GetEaseFunction = Phaser.Tweens.Builders.GetEaseFunction;

class EaseValueTaskBase extends TimerTickTask {
    resetFromJSON(o) {
        this.timer.resetFromJSON(GetValue$$(o, 'timer'));
        this.setEnable(GetValue$$(o, 'enable', true));
        this.setDelay(GetAdvancedValue$1(o, 'delay', 0));
        this.setDuration(GetAdvancedValue$1(o, 'duration', 1000));
        this.setEase(GetValue$$(o, 'ease', 'Linear'));
        this.setRepeat(GetValue$$(o, 'repeat', 0));

        return this;
    }

    setEnable(e) {
        if (e == undefined) {
            e = true;
        }
        this.enable = e;
        return this;
    }

    setDelay(time) {
        this.delay = time;
        return this;
    }

    setDuration(time) {
        this.duration = time;
        return this;
    }

    setEase(ease) {
        if (ease === undefined) {
            ease = 'Linear';
        }
        this.ease = ease;
        this.easeFn = GetEaseFunction(ease);
        return this;
    }

    setRepeat(repeat) {
        this.repeat = repeat;
        return this;
    }

    // Override
    start() {
        // Ignore start if timer is running, i.e. in DELAY, o RUN state
        if (this.timer.isRunning) {
            return this;
        }

        super.start();
        return this;
    }

    restart() {
        this.timer.stop();
        this.start.apply(this, arguments);
        return this;
    }

    update(time, delta) {
        if ((!this.isRunning) || (!this.enable)) {
            return this;
        }

        var gameObject = this.parent;
        if (!gameObject.active) {
            return this;
        }

        var timer = this.timer;
        timer.update(time, delta);

        // isDelay, isCountDown, isDone
        if (!timer.isDelay) {
            this.updateGameObject(gameObject, timer);
        }

        this.emit('update', gameObject, this);

        if (timer.isDone) {
            this.complete();
        }
        return this;
    }

    // Override
    updateGameObject(gameObject, timer) {

    }
}

const GetValue$10 = Phaser.Utils.Objects.GetValue;
const GetAdvancedValue$2 = Phaser.Utils.Objects.GetAdvancedValue;
const Linear = Phaser.Math.Linear;

class Fade extends EaseValueTaskBase {
    constructor(scene, sound, config) {
        sound.scene = scene;
        sound.active = true;

        super(sound, config);
        // this.parent = sound
        // this.timer

        this.volume = {};
        this.resetFromJSON(config);
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);
        this.setMode(GetValue$10(o, 'mode', 0));
        this.setEnable(GetValue$10(o, 'enable', true));
        this.setVolumeRange(
            GetAdvancedValue$2(o, 'volume.start', this.parent.volume),
            GetAdvancedValue$2(o, 'volume.end', 0)
        );
        return this;
    }

    setMode(m) {
        if (typeof (m) === 'string') {
            m = MODE[m];
        }
        this.mode = m;
        return this;
    }

    setVolumeRange(start, end) {
        this.volume.start = start;
        this.volume.end = end;
        return this;
    }

    start() {
        if (this.timer.isRunning) {
            return this;
        }

        this.parent.setVolume(this.volume.start);

        this.timer
            .setDelay(this.delay)
            .setDuration(this.duration);

        super.start();
        return this;
    }

    updateGameObject(sound, timer) {
        sound.volume = Linear(this.volume.start, this.volume.end, timer.t);
    }

    complete() {
        super.complete();

        switch (this.mode) {
            case 1:
                this.parent.stop();
                break;
            case 2:
                this.parent.destroy();
                break;
        }

        return this;
    }
}

const MODE = {
    stop: 1,
    destroy: 2
};

var FadeIn = function (scene, sound, duration, endVolume, startVolume) {
    if (endVolume === undefined) {
        endVolume = 1;
    }
    if (startVolume === undefined) {
        startVolume = 0;
    }

    var config = {
        mode: 0,
        volume: {
            start: startVolume,
            end: endVolume
        },
        duration: duration
    };

    // create sound instance by key
    if (typeof (sound) === 'string') {
        sound = scene.sound.add(sound);
    }

    var fade;
    if (sound.hasOwnProperty('_fade')) {
        fade = sound._fade;
        fade.stop().resetFromJSON(config);
    } else {
        fade = new Fade(scene, sound, config);
        sound._fade = fade;
    }

    fade.start();
    if (!sound.isPlaying) {
        sound.setVolume(startVolume).play();
    }
    return sound;
};

var FadeOut = function (scene, sound, duration, destroy) {
    if (destroy === undefined) {
        destroy = true;
    }

    var config = {
        mode: ((destroy) ? 2 : 1), // 1: stop, 2: destroy
        volume: {
            start: sound.volume,
            end: 0
        },
        duration: duration
    };

    var fade;
    if (sound.hasOwnProperty('_fade')) {
        fade = sound._fade;
        fade.stop().resetFromJSON(config);
    } else {
        fade = new Fade(scene, sound, config);
        sound._fade = fade;
    }

    fade.start();
    if (!sound.isPlaying) {
        sound.play();
    }
    return sound;
};

const GetValue$11 = Phaser.Utils.Objects.GetValue;
const RemoveItem$1 = Phaser.Utils.Array.Remove;

class SoundManager {
    constructor(scene, config) {
        this.scene = scene;

        // Sound effect will be destroyed when completed
        this.soundEffects = [];

        // Background music will be (fade out)destroyed when play next one.
        this.backgroundMusic = undefined;

        this.setBackgroundMusicLoopValue(GetValue$11(config, 'bgm.loop', true));
        this.setBackgroundMusicFadeTime(GetValue$11(config, 'bgm.fade', 500));

        var initialBackgroundMusic = GetValue$11(config, 'bgm.initial', undefined);
        if (initialBackgroundMusic) {
            this.setCurrentBackgroundMusic(initialBackgroundMusic);
        }
    }

    destroy(fromScene) {
        if (this.soundEffects.length && !fromScene) {
            for (var i = this.soundEffects.length - 1; i >= 0; i--) {
                this.soundEffects[i].destroy();
            }
        }
        this.soundEffects.length = 0;

        if (this.backgroundMusic && !fromScene) {
            this.backgroundMusic.destroy();
        }
        this.backgroundMusic = undefined;

        this.scene = undefined;
    }

    setBackgroundMusicLoopValue(value) {
        this.backgroundMusicLoopValue = value;
        return this;
    }

    setBackgroundMusicFadeTime(time) {
        this.backgroundMusicFadeTime = time;
        return this;
    }

    getSoundEffects() {
        return this.soundEffects;
    }

    getLastSoundEffect() {
        return this.soundEffects[this.soundEffects.length - 1];
    }

    getBackgroundMusic() {
        return this.backgroundMusic;
    }

    playSoundEffect(key) {
        var soundEffect = this.scene.sound.add(key);
        this.soundEffects.push(soundEffect);

        soundEffect
            .once('complete', function () {
                soundEffect.destroy();

                // SoundManager has been destroyed
                if (!this.scene) {
                    return;
                }
                RemoveItem$1(this.soundEffects, soundEffect);
            }, this)
            .once('destroy', function () {
                // SoundManager has been destroyed
                if (!this.scene) {
                    return;
                }
                RemoveItem$1(this.soundEffects, soundEffect);
            }, this)
            .play();

        return this;
    }

    setSoundEffectVolume(volume) {
        var soundEffect = this.getLastSoundEffect();
        if (soundEffect) {
            soundEffect.setVolume(volume);
        }

        return this;
    }

    fadeInSoundEffect(time) {
        var soundEffect = this.getLastSoundEffect();
        if (soundEffect) {
            FadeIn(this.scene, soundEffect, time);
        }

        return this;
    }

    fadeOutSoundEffect(time, isStopped) {
        var soundEffect = this.getLastSoundEffect();
        if (soundEffect) {
            FadeOut(this.scene, soundEffect, time, isStopped);
        }

        return this;
    }

    fadeOutAllSoundEffects(time, isStopped) {
        for (var i = this.soundEffects.length - 1; i >= 0; i--) {
            FadeOut(this.scene, this.soundEffects[i], time, isStopped);
        }

        return this;
    }

    setCurrentBackgroundMusic(music) {
        this.backgroundMusic = music;

        if (music) {
            music.setLoop(this.backgroundMusicLoopValue);
            music
                .once('complete', function () {
                    this.backgroundMusic.destroy();
                    this.backgroundMusic = undefined;
                }, this)
                .once('destroy', function () {
                    this.backgroundMusic = undefined;
                }, this);

            if (!music.isPlaying) {
                music.play();
            }
        }
    }

    playBackgroundMusic(key) {
        // Don't re-play the same background music
        if (this.backgroundMusic && (this.backgroundMusic.key === key)) {
            return this;
        }

        this.stopBackgroundMusic(); // Stop previous background music

        this.setCurrentBackgroundMusic(this.scene.sound.add(key));

        if (this.backgroundMusicFadeTime > 0) {
            this.fadeInBackgroundMusic(this.backgroundMusicFadeTime);
        }
        return this;
    }

    pauseBackgroundMusic() {
        if (this.backgroundMusic) {
            this.backgroundMusic.pause();
        }
        return this;
    }

    resumeBackgroundMusic() {
        if (this.backgroundMusic) {
            this.backgroundMusic.resume();
        }
        return this;
    }

    stopBackgroundMusic() {
        if (this.backgroundMusic) {
            if (this.backgroundMusicFadeTime > 0) {
                this.fadeOutBackgroundMusic(this.backgroundMusicFadeTime, true);

            } else {
                this.backgroundMusic.stop();
                this.backgroundMusic.destroy();
                this.backgroundMusic = undefined;
            }
        }
        return this;
    }

    fadeInBackgroundMusic(time) {
        if (this.backgroundMusic) {
            FadeIn(this.scene, this.backgroundMusic, time);
        }

        return this;
    }

    fadeOutBackgroundMusic(time, isStopped) {
        if (this.backgroundMusic) {
            FadeOut(this.scene, this.backgroundMusic, time, isStopped);
        }

        return this;
    }

    crossFadeBackgroundMusic(key, time) {
        var backgroundMusicFadeTimeSave = this.backgroundMusicFadeTime;
        this.backgroundMusicFadeTime = 0;

        this
            .fadeOutBackgroundMusic(time, true)
            .playBackgroundMusic(key)
            .fadeInBackgroundMusic(time);

        this.backgroundMusicFadeTime = backgroundMusicFadeTimeSave;

        return this;
    }

}

class SpriteData {
    constructor(spriteManager, sprite, name) {
        this.spriteManager = spriteManager;
        this.sprite = sprite.setName(name);
        this.tweens = {};
        this.name = name;
    }

    get scene() {
        return this.spriteManager.scene;
    }

    destroy() {
        this
            .freeSprite()
            .freeTweens();

        this.spriteManager = undefined;
    }

    freeSprite() {
        this.sprite.destroy();
        this.sprite = undefined;
        return this;
    }

    freeTweens() {
        var tweenTasks = this.tweens;
        for (var propName in tweenTasks) {
            tweenTasks[propName].remove();
            delete tweenTasks[propName];
        }
        return this;
    }

    setProperty(property, value) {
        this.sprite[property] = value;
        return this;
    }

    easeProperty(property, value, duration, ease, isYoyo, onComplete) {
        var tweenTasks = this.tweens;
        if (tweenTasks.hasOwnProperty(property)) {
            tweenTasks[property].remove();
        }

        var config = {
            targets: this.sprite,
            duration: duration,
            ease: ease,
            yoyo: isYoyo,
            onComplete: function () {
                tweenTasks[property].remove();
                delete tweenTasks[property];
                if (onComplete) {
                    onComplete();
                }
            },
            onCompleteScope: this
        };
        config[property] = value;
        tweenTasks[property] = this.scene.tweens.add(config);
        return this;
    }

    setTexture(textureKey, frameKey) {
        this.sprite.setTexture(textureKey, frameKey);
        return this;
    }

    playAnimation(key) {
        this.sprite.play(key);
        return this;
    }

    stopAnimation() {
        this.sprite.stop();
        return this;
    }

    chainAnimation(keys) {
        this.sprite.chain(keys);
        return this;
    }

    pauseAnimation() {
        this.sprite.anims.pause();
        return this;
    }
}

var GetR = function (colorInt) {
    return (colorInt >> 16) & 0xff;
};

var GetG = function (colorInt) {
    return (colorInt >> 8) & 0xff;
};

var GetB = function (colorInt) {
    return (colorInt) & 0xff;
};

const MaskR = (~(0xff << 16) & 0xffffff);
const MaskG = (~(0xff << 8) & 0xffffff);
const MaskB = (~(0xff) & 0xffffff);

var SetR = function (colorInt, r) {
    return ((r & 0xff) << 16) | (colorInt & MaskR);
};

var SetG = function (colorInt, g) {
    return ((g & 0xff) << 8) | (colorInt & MaskG);
};

var SetB = function (colorInt, b) {
    return (b & 0xff) | (colorInt & MaskB);
};

var SetRGB = function (colorInt, r, g, b) {
    return ((r & 0xff) << 16) | ((g & 0xff) << 8) | ((b & 0xff));
};

var AddTintRGBProperties = function (gameObject, colorRGB) {
    // Don't attach properties again
    if (gameObject.hasOwnProperty('tintR')) {
        return gameObject;
    }

    if (colorRGB === undefined) {
        colorRGB = 0xffffff;
    }

    // Override tint property
    Object.defineProperty(gameObject, 'tint', {
        get: function () {
            return gameObject._tintRGB;
        },
        set: function (value) {
            value = Math.floor(value) & 0xffffff;
            gameObject.setTint(value);
            if (gameObject._tintRGB !== value) {
                gameObject._tintRGB = value;
                gameObject._tintR = GetR(value);
                gameObject._tintG = GetG(value);
                gameObject._tintB = GetB(value);
                // gameObject.emit('_tintchange', value, gameObject._tintR, gameObject._tintG, gameObject._tintB);
            }
        }
    });

    Object.defineProperty(gameObject, 'tintR', {
        get: function () {
            return gameObject._tintR;
        },
        set: function (value) {
            value = Math.floor(value) & 0xff;
            if (gameObject._tintR !== value) {
                gameObject._tintR = value;
                gameObject._tintRGB = SetR(gameObject._tintRGB, value);
                gameObject.tint = gameObject._tintRGB;
            }
        },
    });
    Object.defineProperty(gameObject, 'tintG', {
        get: function () {
            return gameObject._tintG;
        },
        set: function (value) {
            value = Math.floor(value) & 0xff;
            if (gameObject._tintG !== value) {
                gameObject._tintG = value;
                gameObject._tintRGB = SetG(gameObject._tintRGB, value);
                gameObject.tint = gameObject._tintRGB;
            }
        },
    });
    Object.defineProperty(gameObject, 'tintB', {
        get: function () {
            return gameObject._tintB;
        },
        set: function (value) {
            value = Math.floor(value) & 0xff;
            if (gameObject._tintB !== value) {
                gameObject._tintB = value;
                gameObject._tintRGB = SetB(gameObject._tintRGB, value);
                gameObject.tint = gameObject._tintRGB;
            }
        },
    });
    Object.defineProperty(gameObject, 'tintGray', {
        get: function () {
            return Math.floor((gameObject._tintR + gameObject._tintG + gameObject._tintB) / 3);
        },
        set: function (value) {
            value = Math.floor(value) & 0xff;
            if ((gameObject._tintR !== value) || (gameObject._tintG !== value) || (gameObject._tintB !== value)) {
                gameObject._tintR = value;
                gameObject._tintG = value;
                gameObject._tintB = value;
                gameObject._tintRGB = SetRGB(gameObject._tintRGB, value, value, value);
                gameObject.tint = gameObject._tintRGB;
            }
        },
    });

    gameObject.tint = colorRGB;

    return gameObject;
};

var IsEmpty = function (source) {
    for (var k in source) {
        return false;
    }
    return true;
};

const GetValue$12 = Phaser.Utils.Objects.GetValue;
const RemoveItem$2 = Phaser.Utils.Array.Remove;

class SpriteManager {
    constructor(scene, config) {
        this.scene = scene;

        this.setEventEmitter(GetValue$12(config, 'eventEmitter', undefined));
        this.setCreateCallback(GetValue$12(config, 'createCallback', 'sprite'));
        this.setSpriteFadeTime(GetValue$12(config, 'fade', 500));

        this.sprites = {};
        this.removedSprites = [];
    }

    destroy(fromScene) {
        this.clear(!fromScene);
        this.createCallback = undefined;
        this.scene = undefined;
    }

    setCreateCallback(callback) {
        if (callback === 'sprite') {
            this.createCallback = function (scene, textureKey, frameName) {
                return scene.add.sprite(0, 0, textureKey, frameName);
            };
        } else if (callback === 'image') {
            this.createCallback = function (scene, textureKey, frameName) {
                return scene.add.image(0, 0, textureKey, frameName);
            };
        } else {
            this.createCallback = callback;
        }
        return this;
    }

    setSpriteFadeTime(time) {
        this.fadeTime = time;
        return this;
    }

    has(name) {
        return this.sprites.hasOwnProperty(name);
    }

    get(name) {
        return this.sprites[name];
    }

    getTweenTask(name, prop) {
        if (this.has(name)) {
            var tweenTasks = this.get(name).tweens;
            if (tweenTasks.hasOwnProperty(prop)) {
                return tweenTasks[prop];
            }
        }
        return null;
    }

    get isEmpty() {
        return IsEmpty(this.sprites) && (this.removedSprites.length === 0);
    }

    clear(destroyChild) {
        if (destroyChild === undefined) {
            destroyChild = true;
        }
        for (var name in this.sprites) {
            if (destroyChild) {
                this.sprites[name].destroy();
            }
            delete this.sprites[name];
        }
        this.removedSprites.length = 0;
        return this;
    }

    add(name, textureKey, frameName) {
        this.remove(name);

        var sprite;
        if (arguments.length === 3) {
            sprite = this.createCallback(this.scene, textureKey, frameName);
        } else {
            var args = Array.prototype.slice.call(arguments, 1);
            sprite = this.createCallback(this.scene, ...args);
        }

        if (this.fadeTime > 0) {
            AddTintRGBProperties(sprite);
        }
        sprite.once('destroy', function () {
            RemoveItem$2(this.removedSprites, sprite);
            if (this.isEmpty) {
                this.emit('empty');
            }
        }, this);

        var spriteData = new SpriteData(this, sprite, name);
        this.sprites[name] = spriteData;

        if (this.fadeTime > 0) {
            spriteData
                .setProperty('tintGray', 0)
                .easeProperty('tintGray', 255, this.fadeTime);
        }
        return this;
    }

    setProperty(name, property, value) {
        if (!this.has(name)) {
            return this;
        }
        this.get(name).setProperty(property, value);
        return this;
    }

    easeProperty(name, property, value, duration, ease, isYoyo, onComplete) {
        if (!this.has(name)) {
            return this;
        }

        if (duration === undefined) {
            duration = 1000;
        }
        if (ease === undefined) {
            ease = 'Linear';
        }

        this.get(name).easeProperty(property, value, duration, ease, isYoyo, onComplete);
        return this;
    }

    remove(name) {
        if (!this.has(name)) {
            return this;
        }

        var spriteData = this.get(name);
        delete this.sprites[name];

        this.removedSprites.push(spriteData.sprite);
        if (this.fadeTime > 0) {
            spriteData.easeProperty(
                'tintGray',                 // property
                0,                          // to value
                this.fadeTime,              // duration
                'Linear',                   // ease 
                false,                      // yoyo
                function () {               // onComplete
                    spriteData.destroy();
                }
            );

        } else {
            spriteData.destroy();

        }
        return this;
    }

    removeAll() {
        for (var name in this.sprites) {
            this.remove(name);
        }
        return this;
    }

    setTexture(name, textureKey, frameKey) {
        if (!this.has(name)) {
            return this;
        }

        this.get(name).setTexture(textureKey, frameKey);
        return this;
    }

    playAnimation(name, key) {
        if (!this.has(name)) {
            this.add(name);
        }

        this.get(name).playAnimation(key);
        return this;
    }

    stopAnimation(name) {
        if (!this.has(name)) {
            return this;
        }

        this.get(name).stopAnimation();
        return this;
    }

    chainAnimation(name, keys) {
        if (!this.has(name)) {
            return this;
        }

        this.get(name).chainAnimation(keys);
        return this;
    }

    pauseAnimation(name) {
        if (!this.has(name)) {
            return this;
        }

        this.get(name).pauseAnimation();
        return this;
    }
}

Object.assign(
    SpriteManager.prototype,
    EventEmitterMethods
);

var SetClickTarget = function (target) {
    if (IsSceneObject(target)) {
        this.clickEE = target.input;
    } else {  // Assume that target is a game object
        this.clickEE = target.setInteractive();
    }
    return this;
};

var SetTargetCamera = function (camera) {
    this.camera = camera;
    return this;
};

var SetNextPageInput = function (input) {
    var textPlayer = this;
    if (!input) {
        this.nextPageInput = null;

    } else if (typeof (input) === 'function') {
        this.nextPageInput = function (callback, args, scope) {
            var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope);
            input.call(textPlayer, wrapCallback);
        };

    } else {
        this.nextPageInput = function (callback, args, scope) {
            WaitMultiple(textPlayer, input, callback, args, scope);
        };
    }
};

var AddImage$1 = function (key, config) {
    this.imageManager.add(key, config);
    return this;
};

var Play = function (content) {
    if (this.isPlaying) {
        return this;
    }

    this.removeChildren();
    this.parser.start(content); // Parse bbcode-content

    this.isPlaying = true;
    this.once('complete', function () {
        this.isPlaying = false;
    }, this);

    this.lastWrapResult = undefined;
    this.typingNextPage();
    return this;
};

var PlayPromise = function (content) {
    var promise = WaitComplete(this);
    this.play(content);
    return promise;
};

const GetValue$13 = Phaser.Utils.Objects.GetValue;

var TypingNextPage = function () {
    if (!this.isPlaying || this.isPageTyping) {
        return this;
    }

    var wrapCallback = GetValue$13(this.wrapConfig, 'callback', this.runWordWrap);
    if (typeof (wrapCallback) === 'string') {
        wrapCallback = this[wrapCallback];
    }

    var result = wrapCallback.call(this, this.lastWrapResult);
    this.lastWrapResult = result;

    this.emit('page.start');

    var OnTypingPageComplete = function () {
        this.emit(StopPlayEvent);  // Clear registed StopPlayEvent
        if (result.isLastPage) {
            this.emit('complete');
        } else {
            this.emit('page.complete');
            if (this.nextPageInput) {
                this.nextPageInput(TypingNextPage, [], this);
            }

        }
    };

    // Remove event when typing pages has been canceled
    this.once(StopPlayEvent, function () {
        this.typeWriter.off('complete', OnTypingPageComplete, this);
    });

    this.typeWriter
        .once('complete', OnTypingPageComplete, this)
        .start(result.children);
};

var Pause$1 = function() {
    // Pause typing timer and animation progresses
    this.typeWriter.pause();
    return this;
};

var Resume$1 = function() {
    // Resume typing timer and animation progresses
    this.typeWriter.resume();
    return this;
};

var SetTimeScale$1 = function (value) {
    this.typeWriter.setTimeScale(value);
    return this;
};

var SetIgnoreWait$1 = function (value) {    
    this.typeWriter.setIgnoreWait(value);
    return this;
};

var ShowPage = function () {
    // Only can work after playing, and before processing last child
    if (!this.isPlaying || !this.isPageTyping) {
        return this;
    }

    // Save parameters
    var typingSpeedSave = this.typeWriter.speed;
    var ignoreWaitSave = this.typeWriter.ignoreWait;
    var skipTypingAnimationSave = this.typeWriter.skipTypingAnimation;
    var skipSoundEffectSave = this.typeWriter.skipSoundEffect;

    this.typeWriter
        .once('complete', function () {
            // Recover parameters
            this.typeWriter
                .setSpeed(typingSpeedSave)
                .setIgnoreWait(ignoreWaitSave)
                .setSkipTypingAnimation(skipTypingAnimationSave)
                .setSkipSoundEffect(skipSoundEffectSave);

        }, this)

        .setSpeed(0)
        .skipCurrentTypingDelay()
        .setIgnoreWait(true)
        .setSkipTypingAnimation(true)
        .setSkipSoundEffect(true);

    return this;
};

var Methods$3 = {
    setClickTarget: SetClickTarget,
    setTargetCamera: SetTargetCamera,
    setNextPageInput: SetNextPageInput,
    addImage: AddImage$1,
    play: Play,
    playPromise: PlayPromise,
    typingNextPage: TypingNextPage,
    pause: Pause$1,
    resume: Resume$1,
    setTimeScale: SetTimeScale$1,
    setIgnoreWait: SetIgnoreWait$1,
    showPage: ShowPage,
};

var ClearEvents$1 = function (textPlayer) {
    for (var i = 0, cnt = ClearEvents.length; i < cnt; i++) {
        textPlayer.emit(ClearEvents[i]);
    }
};

const IsPlainObject$4 = Phaser.Utils.Objects.IsPlainObject;
const GetValue$14 = Phaser.Utils.Objects.GetValue;

class TextPlayer extends DynamicText {
    constructor(scene, x, y, fixedWidth, fixedHeight, config) {
        if (IsPlainObject$4(x)) {
            config = x;
        } else if (IsPlainObject$4(fixedWidth)) {
            config = fixedWidth;
        }
        if (config === undefined) {
            config = {};
        }

        // Don't set text in DynamicText's constructor
        var content = config.text;
        delete config.text;

        super(scene, x, y, fixedWidth, fixedHeight, config);
        this.type = 'rexTextPlayer';

        this.parser = new Parser(this, GetValue$14(config, 'parser', undefined));

        this.typeWriter = new TypeWriter(this, GetValue$14(config, 'typing', undefined));

        this._imageManager = undefined;
        var imageData = GetValue$14(config, 'images', undefined);
        if (imageData) {
            this.addImage(imageData);
        }

        this._soundManager = undefined;
        var soundManagerConfig = GetValue$14(config, 'sounds', undefined);
        if (soundManagerConfig) {
            this._soundManager = new SoundManager(this.scene, soundManagerConfig);
        }

        this.setTargetCamera(GetValue$14(config, 'camera', this.scene.cameras.main));

        this._spriteManager = undefined;
        var spriteManagerConfig = GetValue$14(config, 'sprites', undefined);
        if (spriteManagerConfig) {
            this._spriteManager = new SpriteManager(this.scene, spriteManagerConfig);
        }

        this.setClickTarget(GetValue$14(config, 'clickTarget', this));  // this.clickEE

        this.setNextPageInput(GetValue$14(config, 'nextPageInput', null));

        this.isPlaying = false;

        if (content) {
            this.play(content);
        }
    }

    get imageManager() {
        if (this._imageManager === undefined) {
            this._imageManager = new ImageManager(this.scene);
        }
        return this._imageManager;
    }

    get soundManager() {
        if (this._soundManager === undefined) {
            this._soundManager = new SoundManager(this.scene);
        }
        return this._soundManager;
    }

    get spriteManager() {
        if (this._spriteManager === undefined) {
            this._spriteManager = new SpriteManager(this.scene);
        }
        return this._spriteManager;
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        ClearEvents$1(this);

        this.parser.destroy();
        this.parser = undefined;

        this.typeWriter.destroy(fromScene);
        this.typeWriter = undefined;

        if (this._imageManager) {
            this._imageManager.destroy(fromScene);
        }
        this._imageManager = undefined;

        if (this._soundManager) {
            this._soundManager.destroy(fromScene);
        }
        this._soundManager = undefined;

        this.camera = undefined;

        if (this._spriteManager) {
            this._spriteManager.destroy(fromScene);
        }
        this._spriteManager = undefined;

        this.clickEE = undefined;

        super.destroy(fromScene);
    }

    get isPageTyping() {
        return this.typeWriter.isPageTyping;
    }
}

Object.assign(
    TextPlayer.prototype,
    Methods$3
);

var DrawCircle = function (
    canvas, context,
    x, y,
    rx, ry,
    fillStyle, strokeStyle, lineWidth,
    startAngle, endAngle, anticlockwise
) {

    if (startAngle === undefined) {
        startAngle = 0;
    }
    if (endAngle === undefined) {
        endAngle = 2 * Math.PI;
    }
    if (anticlockwise === undefined) {
        anticlockwise = false;
    }

    context.beginPath();

    context.ellipse(x, y, rx, ry, 0, startAngle, endAngle, anticlockwise);

    if (fillStyle != null) {
        context.fillStyle = fillStyle;
        context.fill();
    }

    if (strokeStyle != null) {
        context.strokeStyle = strokeStyle;
        context.lineWidth = lineWidth;
        context.stroke();
    }
};

var DrawText = function (
    canvas, context,
    x, y,
    text, font,
    fillStyle, strokeStyle, lineWidth,
    textAlign, textBaseline
) {

    if ((lineWidth === undefined) && (strokeStyle != null)) {
        lineWidth = 2;
    }

    if (textAlign === undefined) {
        textAlign = 'start';
    }

    if (textBaseline === undefined) {
        textBaseline = 'alphabetic';
    }

    context.font = font;
    context.textAlign = textAlign;
    context.textBaseline = textBaseline;

    context.fillStyle = fillStyle;
    context.strokeStyle = strokeStyle;

    context.lineWidth = lineWidth;
    context.lineCap = 'round';
    context.lineJoin = 'round';

    if ((strokeStyle != null) && (strokeStyle !== 'none') && (lineWidth > 0)) {
        context.strokeText(text, x, y);
    }

    if ((fillStyle != null) && (fillStyle !== 'none')) {
        context.fillText(text, x, y);
    }

};

var DrawContent$2 = function () {
    var x = this.radius;
    var lineWidth = this.thickness * this.radius;
    var barRadius = this.radius - (lineWidth / 2);
    var centerRadius = this.radius - lineWidth;
    var canvas = this.canvas,
        context = this.context;

    // Draw track
    if (this.trackColor && (lineWidth > 0)) {
        context.save();

        DrawCircle(
            canvas, context,
            x, x,
            barRadius, barRadius,
            undefined,
            this.trackColor,
            lineWidth
        );

        context.restore();
    }

    // Draw bar
    if ((this.barColor) && (barRadius > 0)) {
        var anticlockwise, startAngle, endAngle;
        if (this.value === 1) {
            anticlockwise = false;
            startAngle = 0;
            endAngle = 2 * Math.PI;
        } else {
            anticlockwise = this.anticlockwise;
            startAngle = this.startAngle;
            var deltaAngle = 2 * Math.PI * ((anticlockwise) ? (1 - this.value) : this.value);
            endAngle = deltaAngle + startAngle;
        }

        context.save();

        DrawCircle(
            canvas, context,
            x, x,
            barRadius, barRadius,
            undefined,
            this.barColor,
            lineWidth,
            startAngle, endAngle, anticlockwise
        );

        context.restore();
    }

    // Draw center
    if (this.centerColor && (centerRadius > 0)) {
        var fillStyle;
        if (this.centerColor2) {
            fillStyle = this.context.createRadialGradient(x, x, 0, x, x, centerRadius);
            fillStyle.addColorStop(0, this.centerColor);
            fillStyle.addColorStop(1, this.centerColor2);
        } else {
            fillStyle = this.centerColor;
        }

        context.save();

        DrawCircle(
            canvas, context,
            x, x,
            centerRadius, centerRadius,
            fillStyle
        );

        context.restore();
    }

    // Draw text
    if (this.textFormatCallback && (this.textColor || this.textStrokeColor)) {

        context.save();

        DrawText(
            canvas, context,
            x, x,
            this.getFormatText(), this.textFont,
            this.textColor, this.textStrokeColor, this.textStrokeThickness,
            'center',  // textAlign
            'middle'   // textBaseline
        );

        context.restore();
    }
};

const GetValue$15 = Phaser.Utils.Objects.GetValue;
const Linear$1 = Phaser.Math.Linear;

class EaseValueTask extends EaseValueTaskBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;
        // this.timer

        this.resetFromJSON();
        this.boot();
    }

    start(config) {
        if (this.timer.isRunning) {
            return this;
        }

        var gameObject = this.parent;
        this.propertyKey = GetValue$15(config, 'key', 'value');
        var currentValue = gameObject[this.propertyKey];
        this.fromValue = GetValue$15(config, 'from', currentValue);
        this.toValue = GetValue$15(config, 'to', currentValue);

        this.setEase(GetValue$15(config, 'ease', this.ease));
        this.setDuration(GetValue$15(config, 'duration', this.duration));

        this.timer.setDuration(this.duration);

        gameObject[this.propertyKey] = this.fromValue;

        super.start();
        return this;
    }

    updateGameObject(gameObject, timer) {
        var t = timer.t;
        t = this.easeFn(t);

        gameObject[this.propertyKey] = Linear$1(this.fromValue, this.toValue, t);
    }
}

var SetEaseValuePropName = function (name) {
    this.easeValuePropName = name;
    return this;
};

var SetEaseValueDuration = function (duration) {
    this.easeValueDuration = duration;
    return this;
};

var SetEaseValueFunction = function (ease) {
    this.easeFunction = ease;
    return this;
};

var StopEaseValue = function () {
    if (this.easeValueTask) {
        this.easeValueTask.stop();
    }
    return this;
};

var EaseValueTo = function (value, min, max) {
    if ((value === undefined) || (value === null)) {
        return this;
    }

    if (min !== undefined) {
        value = Percent(value, min, max);
    }

    if (this.easeValueTask === undefined) {
        this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
    }

    this.easeValueTask.restart({
        key: this.easeValuePropName,
        to: value,
        duration: this.easeValueDuration,
        ease: this.easeFunction
    });

    return this;
};

var EaseValueMethods = {
    setEaseValuePropName: SetEaseValuePropName,
    setEaseValueDuration: SetEaseValueDuration,
    setEaseValueFunction: SetEaseValueFunction,
    stopEaseValue: StopEaseValue,
    easeValueTo: EaseValueTo
};

const GetValue$16 = Phaser.Utils.Objects.GetValue;
const IsPlainObject$5 = Phaser.Utils.Objects.IsPlainObject;
const Clamp$2 = Phaser.Math.Clamp;
const Linear$2 = Phaser.Math.Linear;
const Percent$1 = Phaser.Math.Percent;

const DefaultStartAngle = Phaser.Math.DegToRad(270);

class CircularProgress extends Canvas {
    constructor(scene, x, y, radius, barColor, value, config) {
        if (IsPlainObject$5(x)) {
            config = x;
            x = GetValue$16(config, 'x', 0);
            y = GetValue$16(config, 'y', 0);
            radius = GetValue$16(config, 'radius', 1);
            barColor = GetValue$16(config, 'barColor', undefined);
            value = GetValue$16(config, 'value', 0);
        }
        var width = radius * 2;
        super(scene, x, y, width, width);
        this.type = 'rexCircularProgressCanvas';
        this.eventEmitter = GetValue$16(config, 'eventEmitter', this);

        this.setRadius(radius);
        this.setTrackColor(GetValue$16(config, 'trackColor', undefined));
        this.setBarColor(barColor);
        this.setCenterColor(GetValue$16(config, 'centerColor', undefined));

        this.setThickness(GetValue$16(config, 'thickness', 0.2));
        this.setStartAngle(GetValue$16(config, 'startAngle', DefaultStartAngle));
        this.setAnticlockwise(GetValue$16(config, 'anticlockwise', false));

        this.setTextColor(GetValue$16(config, 'textColor', undefined));
        this.setTextStrokeColor(
            GetValue$16(config, 'textStrokeColor', undefined),
            GetValue$16(config, 'textStrokeThickness', undefined)
        );

        var textFont = GetValue$16(config, 'textFont', undefined);
        if (textFont) {
            this.setTextFont(textFont);
        } else {
            this.setTextFont(
                GetValue$16(config, 'textSize', '16px'),
                GetValue$16(config, 'textFamily', 'Courier'),
                GetValue$16(config, 'textStyle', '')
            );
        }
        this.setTextFormatCallback(
            GetValue$16(config, 'textFormatCallback', undefined),
            GetValue$16(config, 'textFormatCallbackScope', undefined)
        );

        var callback = GetValue$16(config, 'valuechangeCallback', null);
        if (callback !== null) {
            var scope = GetValue$16(config, 'valuechangeCallbackScope', undefined);
            this.eventEmitter.on('valuechange', callback, scope);
        }

        this
            .setEaseValuePropName('value')
            .setEaseValueDuration(GetValue$16(config, 'easeValue.duration', 0))
            .setEaseValueFunction(GetValue$16(config, 'easeValue.ease', 'Linear'));

        this.setValue(value);
    }

    resize(width, height) {
        width = Math.floor(Math.min(width, height));
        if (width === this.width) {
            return this;
        }

        super.resize(width, width);
        this.setRadius(width / 2);
        return this;
    }

    get value() {
        return this._value;
    }

    set value(value) {
        value = Clamp$2(value, 0, 1);

        var oldValue = this._value;
        var valueChanged = (oldValue != value);
        this.dirty = this.dirty || valueChanged;
        this._value = value;

        if (valueChanged) {
            this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
    }

    setValue(value, min, max) {
        if ((value === undefined) || (value === null)) {
            return this;
        }

        if (min !== undefined) {
            value = Percent$1(value, min, max);
        }
        this.value = value;
        return this;
    }

    addValue(inc, min, max) {
        if (min !== undefined) {
            inc = Percent$1(inc, min, max);
        }
        this.value += inc;
        return this;
    }

    getValue(min, max) {
        var value = this.value;
        if (min !== undefined) {
            value = Linear$2(min, max, value);
        }
        return value;
    }

    get radius() {
        return this._radius;
    }

    set radius(value) {
        this.dirty = this.dirty || (this._radius != value);
        this._radius = value;
        var width = value * 2;
        this.resize(width, width);
    }

    setRadius(radius) {
        this.radius = radius;
        return this;
    }

    get trackColor() {
        return this._trackColor;
    }

    set trackColor(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || (this._trackColor != value);
        this._trackColor = value;
    }

    setTrackColor(color) {
        this.trackColor = color;
        return this;
    }

    get barColor() {
        return this._barColor;
    }

    set barColor(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || (this._barColor != value);
        this._barColor = value;
    }

    setBarColor(color) {
        this.barColor = color;
        return this;
    }

    get startAngle() {
        return this._startAngle;
    }

    set startAngle(value) {
        this.dirty = this.dirty || (this._startAngle != value);
        this._startAngle = value;
    }

    setStartAngle(angle) {
        this.startAngle = angle;
        return this;
    }

    get anticlockwise() {
        return this._anticlockwise;
    }

    set anticlockwise(value) {
        this.dirty = this.dirty || (this._anticlockwise != value);
        this._anticlockwise = value;
    }

    setAnticlockwise(anticlockwise) {
        if (anticlockwise === undefined) {
            anticlockwise = true;
        }
        this.anticlockwise = anticlockwise;
        return this;
    }

    get thickness() {
        return this._thickness;
    }

    set thickness(value) {
        value = Clamp$2(value, 0, 1);
        this.dirty = this.dirty || (this._thickness != value);
        this._thickness = value;
    }

    setThickness(thickness) {
        this.thickness = thickness;
        return this;
    }

    get centerColor() {
        return this._centerColor;
    }

    set centerColor(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || (this._centerColor != value);
        this._centerColor = value;
    }

    get centerColor2() {
        return this._centerColor2;
    }

    set centerColor2(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || (this._centerColor2 != value);
        this._centerColor2 = value;
    }

    setCenterColor(color, color2) {
        this.centerColor = color;
        this.centerColor2 = color2;
        return this;
    }

    get textColor() {
        return this._textColor;
    }

    set textColor(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || (this._textColor != value);
        this._textColor = value;
    }

    setTextColor(color) {
        this.textColor = color;
        return this;
    }

    get textStrokeColor() {
        return this._textStrokeColor;
    }

    set textStrokeColor(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || (this._textStrokeColor != value);
        this._textStrokeColor = value;
    }

    get textStrokeThickness() {
        return this._textStrokeThickness;
    }

    set textStrokeThickness(value) {
        this.dirty = this.dirty || (this._textStrokeThickness != value);
        this._textStrokeThickness = value;
    }

    setTextStrokeColor(color, thickness) {
        if (thickness === undefined) {
            thickness = 2;
        }
        this.textStrokeColor = color;
        this.textStrokeThickness = thickness;
        return this;
    }

    get textFont() {
        return this._textFont;
    }

    set textFont(value) {
        this.dirty = this.dirty || (this._textFont != value);
        this._textFont = value;
    }

    setTextFont(fontSize, fontFamily, fontStyle) {
        var font;
        if (fontFamily === undefined) {
            font = fontSize;
        } else {
            font = fontStyle + ' ' + fontSize + ' ' + fontFamily;
        }
        this.textFont = font;
        return this;
    }

    setTextFormatCallback(callback, scope) {
        this.textFormatCallback = callback;
        this.textFormatCallbackScope = scope;
        return this;
    }

    updateTexture() {
        this.clear();
        DrawContent$2.call(this);
        super.updateTexture();
        return this;
    }

    getFormatText(value) {
        if (value === undefined) {
            value = this.value;
        }

        var text;
        if (this.textFormatCallbackScope) {
            text = this.textFormatCallback(value);
        } else {
            text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
        }
        return text;
    }
}

Object.assign(
    CircularProgress.prototype,
    EaseValueMethods
);

var WebGLRenderer$1 = function (renderer, src, camera, parentMatrix) {
    src.updateData();
    camera.addToRenderList(src);

    var pipeline = renderer.pipelines.set(src.pipeline);

    var result = GetCalcMatrix(src, camera, parentMatrix);

    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);

    var dx = src._displayOriginX;
    var dy = src._displayOriginY;

    var alpha = camera.alpha * src.alpha;

    renderer.pipelines.preBatch(src);

    var shapes = src.geom;
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
        shapes[i].webglRender(pipeline, calcMatrix, alpha, dx, dy);
    }

    renderer.pipelines.postBatch(src);
};

const SetTransform$1 = Phaser.Renderer.Canvas.SetTransform;

var CanvasRenderer$1 = function (renderer, src, camera, parentMatrix) {
    src.updateData();
    camera.addToRenderList(src);

    var ctx = renderer.currentContext;

    if (SetTransform$1(renderer, ctx, src, camera, parentMatrix)) {
        var dx = src._displayOriginX;
        var dy = src._displayOriginY;

        var shapes = src.geom;
        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
            shapes[i].canvasRender(ctx, dx, dy);
        }

        //  Restore the context saved in SetTransform
        ctx.restore();
    }
};

var Render$3 = {
    renderWebGL: WebGLRenderer$1,
    renderCanvas: CanvasRenderer$1

};

const Shape$1 = Phaser.GameObjects.Shape;
const RemoveItem$3 = Phaser.Utils.Array.Remove;

class BaseShapes extends Shape$1 {
    constructor(scene, x, y, width, height) {
        if (x === undefined) {
            x = 0;
        }
        if (y === undefined) {
            y = 0;
        }
        if (width === undefined) {
            width = 0;
        }
        if (height === undefined) {
            height = width;
        }

        super(scene, 'rexShapes', []);

        this._width = -1;
        this._height = -1;
        this.dirty = true;
        this.isSizeChanged = true;
        this.shapes = {};

        this.setPosition(x, y);
        this.setSize(width, height);

        this.updateDisplayOrigin();
    }

    get width() {
        return this._width;
    }

    set width(value) {
        this.setSize(value, this._height);
    }

    get height() {
        return this._height;
    }

    set height(value) {
        this.setSize(this._width, value);
    }

    setDirty(value) {
        if (value === undefined) {
            value = true;
        }
        this.dirty = value;
        return this;
    }

    setSize(width, height) {
        this.isSizeChanged = this.isSizeChanged || (this._width !== width) || (this._height !== height);
        this.dirty = this.dirty || this.isSizeChanged;
        this._width = width;
        this._height = height;
        this.updateDisplayOrigin();
        var input = this.input;
        if (input && !input.customHitArea) {
            input.hitArea.width = width;
            input.hitArea.height = height;
        }
        return this;
    }

    resize(width, height) {
        this.setSize(width, height);
        return this;
    }

    setFillStyle(color, alpha) {
        if (alpha === undefined) {
            alpha = 1;
        }

        this.dirty = this.dirty ||
            (this.fillColor !== color) ||
            (this.fillAlpha !== alpha);

        this.fillColor = color;
        this.fillAlpha = alpha;
        return this;
    }

    setStrokeStyle(lineWidth, color, alpha) {
        if (alpha === undefined) {
            alpha = 1;
        }
        this.dirty = this.dirty ||
            (this.lineWidth !== lineWidth) ||
            (this.strokeColor !== color) ||
            (this.strokeAlpha !== alpha);

        this.lineWidth = lineWidth;
        this.strokeColor = color;
        this.strokeAlpha = alpha;
        return this;
    }

    updateShapes() {

    }

    updateData() {
        if (!this.dirty) {
            return this;
        }

        this.updateShapes();
        var shapes = this.geom;
        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
            var shape = shapes[i];
            if (shape.dirty) {
                shape.updateData();
            }
        }

        this.dirty = false;
        this.isSizeChanged = false;

        return this;
    }

    clear() {
        this.geom.length = 0;
        Clear(this.shapes);
        return this;
    }

    getShape(name) {
        return this.shapes[name];
    }

    getShapes() {
        return this.geom;
    }

    addShape(shape) {
        this.geom.push(shape);
        var name = shape.name;
        if (name) {
            this.shapes[name] = shape;
        }
        this.dirty = true;
        return this;
    }

    deleteShape(name) {
        var shape = this.getShape(name);
        if (shape) {
            delete this.shapes[name];
            RemoveItem$3(this.geom, shape);
        }
        return this;
    }
}

Object.assign(
    BaseShapes.prototype,
    Render$3
);

var FillStyle = function (color, alpha) {
    if (color === undefined) {
        this.isFilled = false;
    } else {
        if (alpha === undefined) {
            alpha = 1;
        }
        this.isFilled = true;
        this.fillColor = color;
        this.fillAlpha = alpha;
    }
    return this;
};

var LineStyle = function (lineWidth, color, alpha) {
    if ((lineWidth === undefined) || (color === undefined)) {
        this.isStroked = false;
    } else {
        if (alpha === undefined) {
            alpha = 1;
        }
        this.isStroked = true;
        this.lineWidth = lineWidth;
        this.strokeColor = color;
        this.strokeAlpha = alpha;
    }
    return this;
};

var StyleMethods = {
    fillStyle: FillStyle,
    lineStyle: LineStyle
};

var SetData = function (key, value) {
    if (this.data === undefined) {
        this.data = {};
    }
    this.data[key] = value;
    return this;
};

var GetData = function (key, defaultValue) {
    if (this.data === undefined) {
        this.data = {};
    }
    if (!this.data.hasOwnProperty(key)) {
        this.data[key] = defaultValue;
    }
    return this.data[key];
};

var DataMethods$1 = {
    setData: SetData,
    getData: GetData
};

class BaseGeom {
    constructor() {
        this.name = undefined;
        this.dirty = true;
        this.data = undefined;

        this.isFilled = false;
        this.fillColor = undefined;
        this.fillAlpha = 1;

        this.isStroked = false;
        this.lineWidth = 1;
        this.strokeColor = undefined;
        this.strokeAlpha = 1;
    }

    setName(name) {
        this.name = name;
        return this;
    }

    reset() {
        this.fillStyle();
        this.lineStyle();
        return this;
    }

    webglRender(pipeline, calcMatrix, alpha, dx, dy) {

    }

    canvasRender(ctx, dx, dy) {

    }

    updateData() {

    }
}

Object.assign(
    BaseGeom.prototype,
    StyleMethods,
    DataMethods$1
);

const Earcut$1 = Phaser.Geom.Polygon.Earcut;

class PathBase extends BaseGeom {
    constructor() {
        super();

        this.pathData = [];
        this.pathIndexes = [];
        this.closePath = false;
    }

    updateData() {
        this.pathIndexes = Earcut$1(this.pathData);
        return this;
    }

    webglRender(pipeline, calcMatrix, alpha, dx, dy) {
        if (this.isFilled) {
            FillPathWebGL(pipeline, calcMatrix, this, alpha, dx, dy);
        }

        if (this.isStroked) {
            StrokePathWebGL(pipeline, this, alpha, dx, dy);
        }
    }

    canvasRender(ctx, dx, dy) {
        var path = this.pathData;
        var pathLength = path.length - 1;

        var px1 = path[0] - dx;
        var py1 = path[1] - dy;

        ctx.beginPath();

        ctx.moveTo(px1, py1);

        if (!this.closePath) {
            pathLength -= 2;
        }

        for (var i = 2; i < pathLength; i += 2) {
            var px2 = path[i] - dx;
            var py2 = path[i + 1] - dy;
            ctx.lineTo(px2, py2);
        }

        if (this.closePath) {
            ctx.closePath();
        }


        if (this.isFilled) {
            FillStyleCanvas(ctx, this);
            ctx.fill();
        }

        if (this.isStroked) {
            LineStyleCanvas(ctx, this);
            ctx.stroke();
        }
    }
}

const DegToRad$5 = Phaser.Math.DegToRad;

class Arc extends PathBase {
    constructor(x, y, radiusX, radiusY, startAngle, endAngle, anticlockwise, pie) {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (radiusX === undefined) { radiusX = 0; }
        if (radiusY === undefined) { radiusY = 0; }
        if (startAngle === undefined) { startAngle = 0; }
        if (endAngle === undefined) { endAngle = 360; }
        if (anticlockwise === undefined) { anticlockwise = false; }
        if (pie === undefined) { pie = false; }

        super();

        this.setCenterPosition(x, y);
        this.setRadius(radiusX, radiusY);
        this.setAngle(startAngle, endAngle, anticlockwise);
        this.setPie(pie);
        this.setIterations(32);
    }

    get x() {
        return this._x;
    }

    set x(value) {
        this.dirty = this.dirty || (this._x !== value);
        this._x = value;
    }

    get y() {
        return this._y;
    }

    set y(value) {
        this.dirty = this.dirty || (this._y !== value);
        this._y = value;
    }

    setCenterPosition(x, y) {
        if (y === undefined) {
            y = x;
        }
        this.x = x;
        this.y = y;
        return this;
    }

    get radiusX() {
        return this._radiusX;
    }

    set radiusX(value) {
        this.dirty = this.dirty || (this._radiusX !== value);
        this._radiusX = value;
    }

    get radiusY() {
        return this._radiusY;
    }

    set radiusY(value) {
        this.dirty = this.dirty || (this._radiusY !== value);
        this._radiusY = value;
    }

    setRadius(radiusX, radiusY) {
        if (radiusY === undefined) {
            radiusY = radiusX;
        }
        this.radiusX = radiusX;
        this.radiusY = radiusY;
        return this;
    }

    get startAngle() {
        return this._startAngle;
    }

    set startAngle(value) {
        this.dirty = this.dirty || (this._startAngle !== value);
        this._startAngle = value;
    }

    get endAngle() {
        return this._endAngle;
    }

    set endAngle(value) {
        this.dirty = this.dirty || (this._endAngle !== value);
        this._endAngle = value;
    }

    get anticlockwise() {
        return this._anticlockwise;
    }

    set anticlockwise(value) {
        this.dirty = this.dirty || (this._anticlockwise !== value);
        this._anticlockwise = value;
    }

    setAngle(startAngle, endAngle, anticlockwise) {
        // startAngle, endAngle in degrees
        if (anticlockwise === undefined) {
            anticlockwise = false;
        }

        this.startAngle = startAngle;
        this.endAngle = endAngle;
        this.anticlockwise = anticlockwise;
        return this;
    }

    get pie() {
        return this._pie;
    }

    set pie(value) {
        this.dirty = this.dirty || (this._pie !== value);
        this._pie = value;
    }

    setPie(pie) {
        if (pie === undefined) {
            pie = true;
        }
        this.pie = pie;
        return this;
    }

    get iterations() {
        return this._iterations;
    }

    set iterations(value) {
        this.dirty = this.dirty || (this._iterations !== value);
        this._iterations = value;
    }

    setIterations(iterations) {
        this.iterations = iterations;
        return this;
    }

    updateData() {
        this.pathData.length = 0;
        if (this.pie) {
            this.pathData.push(this.x, this.y);
        }
        ArcTo(
            this.x, this.y,
            this.radiusX, this.radiusY,
            this.startAngle, this.endAngle, this.anticlockwise,
            this.iterations,
            this.pathData
        );
        if (this.pie) {
            this.pathData.push(this.x, this.y);
        }
        this.pathData.push(this.pathData[0], this.pathData[1]);
        super.updateData();
        return this;
    }

    canvasRender(ctx, dx, dy) {
        ctx.beginPath();
        var x = this.x - dx,
            y = this.y - dy,
            startAngle = DegToRad$5(this.startAngle),
            endAngle = DegToRad$5(this.endAngle);
        if (this.pie) {
            ctx.moveTo(x, y);
            ctx.lineTo(
                x + Math.cos(startAngle) * this.radiusX,
                y + Math.sin(startAngle) * this.radiusY
            );
        }
        ctx.ellipse(
            x, y,
            this.radiusX, this.radiusY,
            0,
            startAngle, endAngle, this.anticlockwise
        );
        if (this.pie) {
            ctx.lineTo(x, y);
        }
        if (this.isFilled) {
            FillStyleCanvas(ctx, this);
            ctx.fill();
        }
        if (this.isStroked) {
            LineStyleCanvas(ctx, this);
            ctx.stroke();
        }
    }
}

class Circle extends Arc {
    constructor(x, y, radius) {
        super(x, y, radius, radius, 0, 360);
    }
}

class Curve extends PathBase {
    constructor(curve) {
        super();
        this.setCurve(curve);
        this.setIterations(32);
    }

    get curve() {
        return this._curve;
    }

    set curve(value) {
        this.dirty = this.dirty || (this._curve !== value);
        this._curve = value;
    }

    setCurve(curve) {
        this.curve = curve;
        return this;
    }

    get iterations() {
        return this._iterations;
    }

    set iterations(value) {
        this.dirty = this.dirty || (this._iterations !== value);
        this._iterations = value;
    }

    setIterations(iterations) {
        this.iterations = iterations;
        return this;
    }
    
    updateData() {
        this.pathData.length = 0;
        var points = this.curve.getPoints(this.iterations);
        for (var i = 0, cnt = points.length; i < cnt; i++) {
            this.pathData.push(points[i].x, points[i].y);
        }
        this.pathData.push(points[0].x, points[0].y);

        super.updateData();
        return this;
    }

}

class Ellipse extends Arc {
    constructor(x, y, radiusX, radiusY) {
        super(x, y, radiusX, radiusY, 0, 360);
    }
}

class Line extends PathBase {
    constructor(x0, y0, x1, y1) {
        if (x0 === undefined) { x0 = 0; }
        if (y0 === undefined) { y0 = 0; }
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }

        super();

        this.setP0(x0, y0);
        this.setP1(x1, y1);
    }

    get x0() {
        return this._x0;
    }

    set x0(value) {
        this.dirty = this.dirty || (this._x0 !== value);
        this._x0 = value;
    }

    get y0() {
        return this._y0;
    }

    set y0(value) {
        this.dirty = this.dirty || (this._y0 !== value);
        this._y0 = value;
    }

    setP0(x, y) {
        this.x0 = x;
        this.y0 = y;
        return this;
    }

    get x1() {
        return this._x1;
    }

    set x1(value) {
        this.dirty = this.dirty || (this._x1 !== value);
        this._x1 = value;
    }

    get y1() {
        return this._y1;
    }

    set y1(value) {
        this.dirty = this.dirty || (this._y1 !== value);
        this._y1 = value;
    }

    setP1(x, y) {
        this.x1 = x;
        this.y1 = y;
        return this;
    }

    updateData() {
        this.pathData.length = 0;
        this.pathData.push(this.x0, this.y0);
        this.pathData.push(this.x1, this.y1);
        this.pathData.push(this.x0, this.y0);
        super.updateData();
        return this;
    }
}

var StartAt = function (x, y, pathData) {
    pathData.length = 0;
    pathData.push(x, y);
    return pathData;
};

const QuadraticBezierInterpolation = Phaser.Math.Interpolation.QuadraticBezier;

var QuadraticBezierTo = function (cx, cy, x, y, iterations, pathData) {
    var pathDataCnt = pathData.length;
    var p0x = pathData[pathDataCnt - 2];
    var p0y = pathData[pathDataCnt - 1];
    for (var i = 1, last = iterations - 1; i <= last; i++) {
        var t = i / last;
        pathData.push(
            QuadraticBezierInterpolation(t, p0x, cx, x),
            QuadraticBezierInterpolation(t, p0y, cy, y)
        );
    }
    return pathData;
};

const PointRotateAround$1 = Phaser.Math.RotateAround;

var RotateAround$2 = function (centerX, centerY, angle, pathData) {
    var point = { x: 0, y: 0 };
    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
        point.x = pathData[i];
        point.y = pathData[i + 1];
        PointRotateAround$1(point, centerX, centerY, angle);
        pathData[i] = point.x;
        pathData[i + 1] = point.y;
    }
    return pathData;
};

var Offset = function (x, y, pathData) {
    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
        pathData[i] += x;
        pathData[i + 1] += y;
    }
    return pathData;
};

var ToPoints = function (pathData, points) {
    if (points === undefined) {
        points = [];
    }
    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
        points.push({
            x: pathData[i],
            y: pathData[i + 1]
        });
    }
    return points;
};

const Polygon = Phaser.Geom.Polygon;

var ToPolygon = function (pathData, polygon) {
    if (polygon === undefined) {
        polygon = new Polygon();
    }
    polygon.setTo(pathData);
    return polygon;
};

const DegToRad$6 = Phaser.Math.DegToRad;

class PathData {
    constructor(pathData) {
        if (pathData === undefined) {
            pathData = [];
        }

        this.pathData = pathData;
        this.closePath = false;
        this.setIterations(32);

        this.lastPointX = undefined;
        this.lastPointY = undefined;
    }

    setIterations(iterations) {
        this.iterations = iterations;
        return this;
    }

    startAt(x, y) {
        StartAt(x, y, this.pathData);
        this.lastPointX = x;
        this.lastPointY = y;
        return this;
    }

    lineTo(x, y, relative) {
        if (relative === undefined) {
            relative = false;
        }
        if (relative) {
            x += this.lastPointX;
            y += this.lastPointY;
        }

        LineTo(x, y, this.pathData);

        this.lastPointX = x;
        this.lastPointY = y;
        return this;
    }

    verticalLineTo(x, relative) {
        this.lineTo(x, this.lastPointY, relative);
        return this;
    }

    horizontalLineTo(y, relative) {
        this.lineTo(this.lastPointX, y, relative);
        return this;
    }

    ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
        if (anticlockwise === undefined) {
            anticlockwise = false;
        }

        ArcTo(
            centerX, centerY,
            radiusX, radiusY,
            startAngle, endAngle, anticlockwise,
            this.iterations,
            this.pathData
        );

        var pathDataCnt = this.pathData.length;
        this.lastPointX = this.pathData[pathDataCnt - 2];
        this.lastPointY = this.pathData[pathDataCnt - 1];
        return this;
    }

    arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
        this.ellipticalArc(centerX, centerY, radius, radius, startAngle, endAngle, anticlockwise);
        return this;
    }

    quadraticBezierTo(cx, cy, x, y) {
        QuadraticBezierTo(
            cx, cy, x, y,
            this.iterations,
            this.pathData
        );

        this.lastPointX = x;
        this.lastPointY = y;
        this.lastCX = cx;
        this.lastCY = cy;
        return this;
    }

    smoothQuadraticBezierTo(x, y) {
        var cx = this.lastPointX * 2 - this.lastCX;
        var cy = this.lastPointY * 2 - this.lastCY;
        this.quadraticBezierTo(cx, cy, x, y);
        return this;
    }

    cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y) {
        QuadraticBezierTo(
            cx0, cy0, cx1, cy1, x, y,
            this.iterations,
            this.pathData
        );

        this.lastPointX = x;
        this.lastPointY = y;
        this.lastCX = cx1;
        this.lastCY = cy1;
        return this;
    }

    smoothCubicBezierCurveTo(cx1, cy1, x, y) {
        var cx0 = this.lastPointX * 2 - this.lastCX;
        var cy0 = this.lastPointY * 2 - this.lastCY;
        this.cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y);
        return this;
    }

    close() {
        this.closePath = true;
        return this;
    }

    end() {
        this.pathData.push(this.lastPointX, this.lastPointY);
        return this;
    }

    rotateAround(centerX, centerY, angle) {
        if (this.pathData.length === 0) {
            return this;
        }

        angle = DegToRad$6(angle);

        RotateAround$2(centerX, centerY, angle, this.pathData);

        var pathDataCnt = this.pathData.length;
        this.lastPointX = this.pathData[pathDataCnt - 2];
        this.lastPointY = this.pathData[pathDataCnt - 1];
        if (this.lastCX !== undefined) {
            var point = {
                x: this.lastCX,
                y: this.lastCY
            };
            PointRotateAround(point, centerX, centerY, angle);
            this.lastCX = point.x;
            this.lastCY = point.y;
        }
        return this;
    }

    offset(x, y) {
        Offset(x, y, this.pathData);
        return this;
    }

    toPoints() {
        return ToPoints(this.pathData);
    }

    toPolygon(polygon) {
        return ToPolygon(this.pathData, polygon);
    }

    draw(graphics, isFill, isStroke) {
        var points = this.toPoints();
        if (isFill) {
            graphics.fillPoints(points, this.closePath, this.closePath);
        }
        if (isStroke) {
            graphics.strokePoints(points, this.closePath, this.closePath);
        }

        return this;
    }

}

class Lines extends PathBase {
    constructor() {
        super();
        this.builder = new PathData(this.pathData);
    }

    get iterations() {
        return this.builder.iterations;
    }

    set iterations(value) {
        this.dirty = this.dirty || (this.builder.iterations !== value);
        this.builder.setIterations(value);
    }

    setIterations(iterations) {
        this.iterations = iterations;
        return this;
    }

    get lastPointX() {
        return this.builder.lastPointX;
    }

    get lastPointY() {
        return this.builder.lastPointY;
    }

    startAt(x, y) {
        this.builder.startAt(x, y);

        this.dirty = true;
        return this;
    }

    lineTo(x, y, relative) {
        this.builder.lineTo(x, y, relative);

        this.dirty = true;
        return this;
    }

    verticalLineTo(x, relative) {
        this.builder.verticalLineTo(x, relative);

        this.dirty = true;
        return this;
    }

    horizontalLineTo(y, relative) {
        this.builder.horizontalLineTo(y, relative);

        this.dirty = true;
        return this;
    }

    ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
        this.builder.ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise);

        this.dirty = true;
        return this;
    }

    arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
        this.builder.arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise);

        this.dirty = true;
        return this;
    }

    quadraticBezierTo(cx, cy, x, y) {
        this.builder.quadraticBezierTo(cx, cy, x, y);

        this.dirty = true;
        return this;
    }

    smoothQuadraticBezierTo(x, y) {
        this.builder.smoothQuadraticBezierTo(x, y);

        this.dirty = true;
        return this;
    }

    cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y) {
        this.builder.cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y);

        this.dirty = true;
        return this;
    }

    smoothCubicBezierCurveTo(cx1, cy1, x, y) {
        this.builder.smoothCubicBezierCurveTo(cx1, cy1, x, y);

        this.dirty = true;
        return this;
    }

    close() {
        this.builder.close();

        this.closePath = this.builder.closePath;
        this.dirty = true;
        return this;
    }

    end() {
        this.builder.end();
        this.dirty = true;
        return this;
    }

    rotateAround(centerX, centerY, angle) {
        this.builder.rotateAround(centerX, centerY, angle);

        this.dirty = true;
        return this;
    }

    offset(x, y) {
        this.builder.offset(x, y);

        this.dirty = true;
        return this;
    }

    toPolygon(polygon) {
        return this.builder.toPolygon(polygon);
    }
}

const DistanceBetween = Phaser.Math.Distance.Between;
const Linear$3 = Phaser.Math.Linear;

const Utils$4 = Phaser.Renderer.WebGL.Utils;

class Rectangle$1 extends BaseGeom {
    constructor(x, y, width, height) {
        if (x === undefined) { x = 0; }
        if (y === undefined) { y = 0; }
        if (width === undefined) { width = 0; }
        if (height === undefined) { height = width; }

        super();

        this.pathData = [];
        this.closePath = true;

        this.setTopLeftPosition(x, y);
        this.setSize(width, height);
    }

    get x() {
        return this._x;
    }

    set x(value) {
        this.dirty = this.dirty || (this._x !== value);
        this._x = value;
    }

    get y() {
        return this._y;
    }

    set y(value) {
        this.dirty = this.dirty || (this._y !== value);
        this._y = value;
    }

    setTopLeftPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }

    get width() {
        return this._width;
    }

    set width(value) {
        this.dirty = this.dirty || (this._width !== value);
        this._width = value;
    }

    get height() {
        return this._height;
    }

    set height(value) {
        this.dirty = this.dirty || (this._height !== value);
        this._height = value;
    }

    setSize(width, height) {
        this.width = width;
        this.height = height;
        return this;
    }

    updateData() {
        this.pathData.length = 0;
        var x0 = this.x,
            x1 = x0 + this.width,
            y0 = this.y,
            y1 = y0 + this.height;
        this.pathData.push(x0, y0);
        this.pathData.push(x1, y0);
        this.pathData.push(x1, y1);
        this.pathData.push(x0, y1);
        this.pathData.push(x0, y0);
        return this;
    }

    webglRender(pipeline, calcMatrix, alpha, dx, dy) {
        if (this.isFilled) {
            var fillTint = pipeline.fillTint;
            var fillTintColor = Utils$4.getTintAppendFloatAlpha(this.fillColor, this.fillAlpha * alpha);

            fillTint.TL = fillTintColor;
            fillTint.TR = fillTintColor;
            fillTint.BL = fillTintColor;
            fillTint.BR = fillTintColor;

            pipeline.batchFillRect(-dx + this.x, -dy + this.y, this.width, this.height);
        }

        if (this.isStroked) {
            StrokePathWebGL(pipeline, this, alpha, dx, dy);
        }
    }

    canvasRender(ctx, dx, dy) {
        if (this.isFilled) {
            FillStyleCanvas(ctx, this);
            ctx.fillRect(-dx, -dy, this.width, this.height);
        }

        if (this.isStroked) {
            LineStyleCanvas(ctx, this);
            ctx.beginPath();
            ctx.rect(-dx, -dy, this.width, this.height);
            ctx.stroke();
        }
    }
}

const Utils$5 = Phaser.Renderer.WebGL.Utils;

class Triangle extends BaseGeom {
    constructor(x0, y0, x1, y1, x2, y2) {
        if (x0 === undefined) { x0 = 0; }
        if (y0 === undefined) { y0 = 0; }
        if (x1 === undefined) { x1 = 0; }
        if (y1 === undefined) { y1 = 0; }
        if (x2 === undefined) { x2 = 0; }
        if (y2 === undefined) { y2 = 0; }

        super();

        this.pathData = [];
        this.closePath = true;

        this.setP0(x0, y0);
        this.setP1(x1, y1);
        this.setP2(x2, y2);
    }

    get x0() {
        return this._x0;
    }

    set x0(value) {
        this.dirty = this.dirty || (this._x0 !== value);
        this._x0 = value;
    }

    get y0() {
        return this._y0;
    }

    set y0(value) {
        this.dirty = this.dirty || (this._y0 !== value);
        this._y0 = value;
    }

    setP0(x, y) {
        this.x0 = x;
        this.y0 = y;
        return this;
    }

    get x1() {
        return this._x1;
    }

    set x1(value) {
        this.dirty = this.dirty || (this._x1 !== value);
        this._x1 = value;
    }

    get y1() {
        return this._y1;
    }

    set y1(value) {
        this.dirty = this.dirty || (this._y1 !== value);
        this._y1 = value;
    }

    setP1(x, y) {
        this.x1 = x;
        this.y1 = y;
        return this;
    }

    get x2() {
        return this._x2;
    }

    set x2(value) {
        this.dirty = this.dirty || (this._x2 !== value);
        this._x2 = value;
    }

    get y2() {
        return this._y2;
    }

    set y2(value) {
        this.dirty = this.dirty || (this._y2 !== value);
        this._y2 = value;
    }

    setP2(x, y) {
        this.dirty = this.dirty || (this.x2 !== x) || (this.y2 !== y);
        this.x2 = x;
        this.y2 = y;
        return this;
    }

    updateData() {
        this.pathData.length = 0;
        this.pathData.push(this.x0, this.y0);
        this.pathData.push(this.x1, this.y1);
        this.pathData.push(this.x2, this.y2);
        this.pathData.push(this.x0, this.y0);
        return this;
    }

    webglRender(pipeline, calcMatrix, alpha, dx, dy) {
        if (this.isFilled) {
            var fillTintColor = Utils$5.getTintAppendFloatAlpha(this.fillColor, this.fillAlpha * alpha);

            var x0 = this.x0 - dx;
            var y0 = this.y0 - dy;
            var x1 = this.x1 - dx;
            var y1 = this.y1 - dy;
            var x2 = this.x2 - dx;
            var y2 = this.y2 - dy;

            var tx0 = calcMatrix.getX(x0, y0);
            var ty0 = calcMatrix.getY(x0, y0);
            var tx1 = calcMatrix.getX(x1, y1);
            var ty1 = calcMatrix.getY(x1, y1);
            var tx2 = calcMatrix.getX(x2, y2);
            var ty2 = calcMatrix.getY(x2, y2);

            pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, fillTintColor, fillTintColor, fillTintColor);
        }

        if (this.isStroked) {
            StrokePathWebGL(pipeline, this, alpha, dx, dy);
        }
    }

    canvasRender(ctx, dx, dy) {
        var x1 = this.x1 - dx;
        var y1 = this.y1 - dy;
        var x2 = this.x2 - dx;
        var y2 = this.y2 - dy;
        var x3 = this.x3 - dx;
        var y3 = this.y3 - dy;

        ctx.beginPath();

        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);

        ctx.closePath();

        if (this.isFilled) {
            FillStyleCanvas(ctx, this);
            ctx.fill();
        }

        if (this.isStroked) {
            LineStyleCanvas(ctx, this);
            ctx.stroke();
        }
    }
}

const GetValue$17 = Phaser.Utils.Objects.GetValue;
const IsPlainObject$6 = Phaser.Utils.Objects.IsPlainObject;
const Clamp$3 = Phaser.Math.Clamp;
const Linear$4 = Phaser.Math.Linear;
const Percent$2 = Phaser.Math.Percent;

const DefaultStartAngle$1 = Phaser.Math.DegToRad(270);
const RadToDeg$2 = Phaser.Math.RadToDeg;

class CircularProgress$1 extends BaseShapes {
    constructor(scene, x, y, radius, barColor, value, config) {
        if (IsPlainObject$6(x)) {
            config = x;
            x = GetValue$17(config, 'x', 0);
            y = GetValue$17(config, 'y', 0);
            radius = GetValue$17(config, 'radius', 1);
            barColor = GetValue$17(config, 'barColor', undefined);
            value = GetValue$17(config, 'value', 0);
        }
        var width = radius * 2;
        super(scene, x, y, width, width);
        this.type = 'rexCircularProgress';
        this.eventEmitter = GetValue$17(config, 'eventEmitter', this);

        this
            .addShape((new Circle()).setName('track'))
            .addShape((new Arc()).setName('bar'))
            .addShape((new Circle()).setName('center'));

        this.setRadius(radius);
        this.setTrackColor(GetValue$17(config, 'trackColor', undefined));
        this.setBarColor(barColor);
        this.setCenterColor(GetValue$17(config, 'centerColor', undefined));

        this.setThickness(GetValue$17(config, 'thickness', 0.2));
        this.setStartAngle(GetValue$17(config, 'startAngle', DefaultStartAngle$1));
        this.setAnticlockwise(GetValue$17(config, 'anticlockwise', false));

        var callback = GetValue$17(config, 'valuechangeCallback', null);
        if (callback !== null) {
            var scope = GetValue$17(config, 'valuechangeCallbackScope', undefined);
            this.eventEmitter.on('valuechange', callback, scope);
        }

        this
            .setEaseValuePropName('value')
            .setEaseValueDuration(GetValue$17(config, 'easeValue.duration', 0))
            .setEaseValueFunction(GetValue$17(config, 'easeValue.ease', 'Linear'));

        this.setValue(value);
    }

    resize(width, height) {
        width = Math.floor(Math.min(width, height));
        if (width === this.width) {
            return this;
        }

        super.resize(width, width);
        this.setRadius(width / 2);
        return this;
    }

    get value() {
        return this._value;
    }

    set value(value) {
        value = Clamp$3(value, 0, 1);

        var oldValue = this._value;
        var valueChanged = (oldValue != value);
        this.dirty = this.dirty || valueChanged;
        this._value = value;

        if (valueChanged) {
            this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
    }

    setValue(value, min, max) {
        if ((value === undefined) || (value === null)) {
            return this;
        }

        if (min !== undefined) {
            value = Percent$2(value, min, max);
        }
        this.value = value;
        return this;
    }

    addValue(inc, min, max) {
        if (min !== undefined) {
            inc = Percent$2(inc, min, max);
        }
        this.value += inc;
        return this;
    }

    getValue(min, max) {
        var value = this.value;
        if (min !== undefined) {
            value = Linear$4(min, max, value);
        }
        return value;
    }

    get radius() {
        return this._radius;
    }

    set radius(value) {
        this.dirty = this.dirty || (this._radius != value);
        this._radius = value;
        var width = value * 2;
        this.resize(width, width);
    }

    setRadius(radius) {
        this.radius = radius;
        return this;
    }

    get trackColor() {
        return this._trackColor;
    }

    set trackColor(value) {
        this.dirty = this.dirty || (this._trackColor != value);
        this._trackColor = value;
    }

    setTrackColor(color) {
        this.trackColor = color;
        return this;
    }

    get barColor() {
        return this._barColor;
    }

    set barColor(value) {
        this.dirty = this.dirty || (this._barColor != value);
        this._barColor = value;
    }

    setBarColor(color) {
        this.barColor = color;
        return this;
    }

    get startAngle() {
        return this._startAngle;
    }

    set startAngle(value) {
        this.dirty = this.dirty || (this._startAngle != value);
        this._startAngle = value;
    }

    setStartAngle(angle) {
        this.startAngle = angle;
        return this;
    }

    get anticlockwise() {
        return this._anticlockwise;
    }

    set anticlockwise(value) {
        this.dirty = this.dirty || (this._anticlockwise != value);
        this._anticlockwise = value;
    }

    setAnticlockwise(anticlockwise) {
        if (anticlockwise === undefined) {
            anticlockwise = true;
        }
        this.anticlockwise = anticlockwise;
        return this;
    }

    get thickness() {
        return this._thickness;
    }

    set thickness(value) {
        value = Clamp$3(value, 0, 1);
        this.dirty = this.dirty || (this._thickness != value);
        this._thickness = value;
    }

    setThickness(thickness) {
        this.thickness = thickness;
        return this;
    }

    get centerColor() {
        return this._centerColor;
    }

    set centerColor(value) {
        this.dirty = this.dirty || (this._centerColor != value);
        this._centerColor = value;
    }

    setCenterColor(color) {
        this.centerColor = color;
        return this;
    }

    updateShapes() {
        var x = this.radius;
        var lineWidth = this.thickness * this.radius;
        var barRadius = this.radius - (lineWidth / 2);
        var centerRadius = this.radius - lineWidth;

        // Track shape
        var trackShape = this.getShape('track');
        if (this.trackColor && (lineWidth > 0)) {
            trackShape
                .setCenterPosition(x, x)
                .setRadius(barRadius)
                .lineStyle(lineWidth, this.trackColor);
        } else {
            trackShape.reset();
        }

        // Bar shape
        var barShape = this.getShape('bar');
        if ((this.barColor) && (barRadius > 0)) {
            var anticlockwise, startAngle, endAngle;
            if (this.value === 1) {
                anticlockwise = false;
                startAngle = 0;
                endAngle = 360;
            } else {
                anticlockwise = this.anticlockwise;
                startAngle = RadToDeg$2(this.startAngle);
                var deltaAngle = 360 * ((anticlockwise) ? (1 - this.value) : this.value);
                endAngle = deltaAngle + startAngle;
            }
            barShape
                .setCenterPosition(x, x)
                .setRadius(barRadius)
                .setAngle(startAngle, endAngle, anticlockwise)
                .lineStyle(lineWidth, this.barColor);
        } else {
            barShape.reset();
        }

        // Center shape
        var centerShape = this.getShape('center');
        if (this.centerColor && (centerRadius > 0)) {
            centerShape
                .setCenterPosition(x, x)
                .setRadius(centerRadius)
                .fillStyle(this.centerColor);
        } else {
            centerShape.reset();
        }
    }
}

Object.assign(
    CircularProgress$1.prototype,
    EaseValueMethods
);

var GetSizerConfig = function (gameObject) {
    if (!gameObject.hasOwnProperty('rexSizer')) {
        gameObject.rexSizer = {};
    }
    return gameObject.rexSizer;
};

var GetChildPrevState = function (child) {
    var childConfig = GetSizerConfig(child);
    if (!childConfig.hasOwnProperty('prevState')) {
        childConfig.prevState = {};
    }
    return childConfig.prevState;
};

var GetDefaultBounds = function (scene, out) {
    if (out === undefined) {
        if (GlobRectangle === undefined) {
            GlobRectangle = new Phaser.Geom.Rectangle();
        }
        out = GlobRectangle;
    }
    var gameConfig = scene.game.config;
    out.setTo(0, 0, gameConfig.width, gameConfig.height);
    return out;
};

var GlobRectangle;

var PushIntoBounds = function (bounds) {
    if (bounds === undefined) {
        bounds = GetDefaultBounds(this.scene);
    }

    this.left = Math.max(this.left, bounds.left);
    this.right = Math.min(this.right, bounds.right);
    this.top = Math.max(this.top, bounds.top);
    this.bottom = Math.min(this.bottom, bounds.bottom);
    return this;
};

const ALIGN = Phaser.Display.Align;
var ALIGNMODE = {
    center: ALIGN.CENTER,
    left: ALIGN.LEFT_CENTER,
    right: ALIGN.RIGHT_CENTER,
    top: ALIGN.TOP_CENTER,
    bottom: ALIGN.BOTTOM_CENTER,

    'left-top': ALIGN.TOP_LEFT,
    'left-center': ALIGN.LEFT_CENTER,
    'left-bottom': ALIGN.BOTTOM_LEFT,
    'center-top': ALIGN.TOP_CENTER,
    'center-center': ALIGN.CENTER,
    'center-bottom': ALIGN.BOTTOM_CENTER,
    'right-top': ALIGN.TOP_RIGHT,
    'right-center': ALIGN.RIGHT_CENTER,
    'right-bottom': ALIGN.BOTTOM_RIGHT
};

var globZone = new Phaser.GameObjects.Zone({
    sys: {
        queueDepthSort: NOOP,
        events: {
            once: NOOP
        }
    }
}, 0, 0, 1, 1);
globZone.setOrigin(0);

var ALIGN_CONST = {

    /**
    * A constant representing a top-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_LEFT
    * @since 3.0.0
    * @type {integer}
    */
    TOP_LEFT: 0,

    /**
    * A constant representing a top-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    TOP_CENTER: 1,

    /**
    * A constant representing a top-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_RIGHT
    * @since 3.0.0
    * @type {integer}
    */
    TOP_RIGHT: 2,

    /**
    * A constant representing a left-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_TOP
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_TOP: 3,

    /**
    * A constant representing a left-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_CENTER: 4,

    /**
    * A constant representing a left-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_BOTTOM: 5,

    /**
    * A constant representing a center alignment or position.
    * @constant
    * @name Phaser.Display.Align.CENTER
    * @since 3.0.0
    * @type {integer}
    */
    CENTER: 6,

    /**
    * A constant representing a right-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_TOP
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_TOP: 7,

    /**
    * A constant representing a right-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_CENTER: 8,

    /**
    * A constant representing a right-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_BOTTOM: 9,

    /**
    * A constant representing a bottom-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_LEFT
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_LEFT: 10,

    /**
    * A constant representing a bottom-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_CENTER: 11,

    /**
    * A constant representing a bottom-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_RIGHT
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_RIGHT: 12

};

var GetDisplayWidth = function (gameObject) {
    if (gameObject.displayWidth !== undefined) {
        return gameObject.displayWidth;
    } else {
        return gameObject.width;
    }
};

var GetDisplayHeight = function (gameObject) {
    if (gameObject.displayHeight !== undefined) {
        return gameObject.displayHeight;
    } else {
        return gameObject.height;
    }
};

var GetBottom = function (gameObject) {
    var height = GetDisplayHeight(gameObject);
    return (gameObject.y + height) - (height * gameObject.originY);
};

var GetCenterX = function (gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x - (width * gameObject.originX) + (width * 0.5);
};

var SetBottom = function (gameObject, value) {
    var height = GetDisplayHeight(gameObject);
    gameObject.y = (value - height) + (height * gameObject.originY);
    return gameObject;
};

var SetCenterX = function (gameObject, x) {
    var width = GetDisplayWidth(gameObject);
    var offsetX = width * gameObject.originX;
    gameObject.x = (x + offsetX) - (width * 0.5);

    return gameObject;
};

var BottomCenter = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);

    return gameObject;
};

var GetLeft = function (gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x - (width * gameObject.originX);
};

var SetLeft = function (gameObject, value) {
    var width = GetDisplayWidth(gameObject);
    gameObject.x = value + (width * gameObject.originX);
    return gameObject;
};

var BottomLeft = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);

    return gameObject;
};

var GetRight = function (gameObject) {
    var width = GetDisplayWidth(gameObject);
    return (gameObject.x + width) - (width * gameObject.originX);
};

var SetRight = function (gameObject, value) {
    var width = GetDisplayWidth(gameObject);
    gameObject.x = (value - width) + (width * gameObject.originX);

    return gameObject;
};

var BottomRight = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);

    return gameObject;
};

var SetCenterY = function (gameObject, y) {
    var height = GetDisplayHeight(gameObject);
    var offsetY = height * gameObject.originY;
    gameObject.y = (y + offsetY) - (height * 0.5);

    return gameObject;
};

var CenterOn = function (gameObject, x, y) {
    SetCenterX(gameObject, x);
    return SetCenterY(gameObject, y);
};

var GetCenterY = function (gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y - (height * gameObject.originY) + (height * 0.5);
};

var Center = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);

    return gameObject;
};

var LeftCenter = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);

    return gameObject;
};

var RightCenter = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);

    return gameObject;
};

var GetTop = function (gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y - (height * gameObject.originY);
};

var SetTop = function (gameObject, value) {
    var height = GetDisplayHeight(gameObject);
    gameObject.y = value + (height * gameObject.originY);
    return gameObject;
};

var TopCenter = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);

    return gameObject;
};

var TopLeft = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);

    return gameObject;
};

var TopRight = function (gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) { offsetX = 0; }
    if (offsetY === undefined) { offsetY = 0; }

    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);

    return gameObject;
};

var AlignInMap = [];

AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = BottomCenter;
AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = BottomLeft;
AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = BottomRight;
AlignInMap[ALIGN_CONST.CENTER] = Center;
AlignInMap[ALIGN_CONST.LEFT_CENTER] = LeftCenter;
AlignInMap[ALIGN_CONST.RIGHT_CENTER] = RightCenter;
AlignInMap[ALIGN_CONST.TOP_CENTER] = TopCenter;
AlignInMap[ALIGN_CONST.TOP_LEFT] = TopLeft;
AlignInMap[ALIGN_CONST.TOP_RIGHT] = TopRight;

var QuickSet = function (child, alignIn, position, offsetX, offsetY) {
    return AlignInMap[position](child, alignIn, offsetX, offsetY);
};

var AlignIn = function (child, x, y, width, height, align) {
    globZone.setPosition(x, y).setSize(width, height);
    QuickSet(child, globZone, align);
};

const GetValue$18 = Phaser.Utils.Objects.GetValue;
const Group = Phaser.GameObjects.Group;

var DrawBounds = function (graphics, config) {
    var scene = graphics.scene;

    var color;
    var createTextCallback, createTextCallbackScope, textAlign;
    if (typeof (config) === 'number') {
        color = config;
    } else {
        color = GetValue$18(config, 'color', 0xffffff);
        var nameTextConfig = GetValue$18(config, 'name', false);
        if (nameTextConfig) {
            createTextCallback = GetValue$18(nameTextConfig, 'createTextCallback', DefaultCreateTextCallback);
            createTextCallbackScope = GetValue$18(nameTextConfig, 'createTextCallbackScope', undefined);
            textAlign = GetValue$18(nameTextConfig, 'align', 'left-top');
            if (typeof (textAlign) === 'string') {
                textAlign = ALIGNMODE[textAlign];
            }
        }
    }

    if (createTextCallback && !graphics.children) {
        graphics.children = new Group(scene);
        graphics.once('destroy', function (graphics, fromScene) {
            graphics.children.destroy(!fromScene);
            graphics.children = undefined;
        });
        var graphicsClear = graphics.clear.bind(graphics);
        graphics.clear = function () {
            graphicsClear();
            graphics.children.clear(false, true);
        };
    }

    var children = this.getAllShownChildren([this]), child;
    var nameText;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (!child.getBounds) {
            continue;
        }
        if (color) {
            graphics
                .lineStyle(1, color)
                .strokeRectShape(child.getBounds(GlobRect));
        }

        if (child.name && createTextCallback) {
            if (createTextCallbackScope) {
                nameText = createTextCallback.call(createTextCallbackScope, scene);
            } else {
                nameText = createTextCallback(scene);
            }
            if (nameText) {
                nameText.setText(child.name);
                graphics.children.add(nameText);

                AlignIn(nameText, GlobRect.x, GlobRect.y, GlobRect.width, GlobRect.height, textAlign);
            }
        }
    }
    return this;
};

var DefaultCreateTextCallback = function (scene, child, childBoundsRect) {
    return scene.add.text(0, 0, '');
};

var GlobRect = new Phaser.Geom.Rectangle();

const GetValue$19 = Phaser.Utils.Objects.GetValue;

var GetBoundsConfig = function (config, out) {
    if (out === undefined) {
        out = {};
    }
    if (typeof (config) === 'number') {
        out.left = config;
        out.right = config;
        out.top = config;
        out.bottom = config;
    } else {
        out.left = GetValue$19(config, 'left', 0);
        out.right = GetValue$19(config, 'right', 0);
        out.top = GetValue$19(config, 'top', 0);
        out.bottom = GetValue$19(config, 'bottom', 0);
    }
    return out;
};

const ContainerAdd = ContainerLite.prototype.add;

var AddChild$1 = function (gameObject) {
    ContainerAdd.call(this, gameObject);

    if (this.sizerEventsEnable) {
        gameObject.emit('sizer.add', gameObject, this);
        this.emit('add', gameObject, this);
    }

    return this;
};

const ContainerAdd$1 = ContainerLite.prototype.add;

var AddChildMethods = {
    pin(gameObject) {
        ContainerAdd$1.call(this, gameObject);
        return this;
    },

    addBackground(gameObject, paddingConfig, childKey) {
        if (this.backgroundChildren === undefined) {
            this.backgroundChildren = [];
        }

        if (typeof (paddingConfig) === 'string') {
            childKey = paddingConfig;
            paddingConfig = undefined;
        }

        if (paddingConfig === undefined) {
            paddingConfig = 0;
        }

        AddChild$1.call(this, gameObject);
        this.backgroundChildren.push(gameObject);

        var config = this.getSizerConfig(gameObject);
        config.padding = GetBoundsConfig(paddingConfig);

        if (childKey !== undefined) {
            this.addChildrenMap(childKey, gameObject);
        }
        return this;
    },

    isBackground(gameObject) {
        if (this.backgroundChildren === undefined) {
            return false;
        }
        return (this.backgroundChildren.indexOf(gameObject) !== -1);
    }
};

var AddChildrenMap = function (key, gameObject) {
    if (this.childrenMap === undefined) {
        this.childrenMap = {};
    }
    this.childrenMap[key] = gameObject;
    return this;
};

var GetElement = function (mapNameList, recursive) {
    if (typeof (mapNameList) === 'string') {
        mapNameList = mapNameList.split('.');
    }
    if (mapNameList.length === 0) {
        return undefined;
    }

    var name = mapNameList.shift(),
        element = null;
    if (name.charAt(0) === '#') { // Get element by name
        name = name.substring(1);
        element = this.getByName(name, recursive);
    } else if (name.indexOf('[') === (-1)) { // Get element by key
        if (this.childrenMap) {
            element = this.childrenMap[name];
        }
    } else { // Get element by key[]
        var innerMatch = name.match(RE_OBJ);
        if (innerMatch != null) {
            if (this.childrenMap) {
                var elements = this.childrenMap[innerMatch[1]];
                if (elements) {
                    element = elements[innerMatch[2]];
                }
            }
        }
    }

    if (mapNameList.length === 0) {
        return element;
    } else if (element && element.childrenMap) {
        return element.getElement(mapNameList);
    } else {
        return null;
    }
};

const RE_OBJ = /(\S+)\[(\d+)\]/i;

var PaddingMethods = {
    getInnerPadding(key) {
        return GetPadding(this.space, key);
    },

    setInnerPadding(key, value) {
        SetPadding(this.space, key, value);
        return this;
    },

    getOutterPadding(key) {
        return GetPadding(this.getSizerConfig(this).padding, key);
    },

    setOuterPadding(key, value) {
        SetPadding(this.getSizerConfig(this).padding, key, value);
        return this;
    },

    getChildOutterPadding(child, key) {
        if (typeof (child) === 'string') {
            child = this.getElement(child);
        }
        return GetPadding(this.getSizerConfig(child).padding, key);
    },

    setChildOuterPadding(child, key, value) {
        if (typeof (child) === 'string') {
            child = this.getElement(child);
        }
        SetPadding(this.getSizerConfig(child).padding, key, value);
        return this;
    },
};

var ResolveWidth = function (width) {
    var minWidth = Math.max(this.childrenWidth, this.minWidth);
    if (width === undefined) {
        width = minWidth;
    }

    return width;
};

var ResolveChildrenWidth = function (width) {
    // Resolve width of sizer children
    var child, childWidth;
    for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (child && child.isRexSizer && !child.ignoreLayout) {
            childWidth = this.getExpandedChildWidth(child, width);
            childWidth = child.resolveWidth(childWidth);
            child.resolveChildrenWidth(childWidth);
        }
    }
};

var ResolveHeight = function (height) {
    var minHeight = Math.max(this.childrenHeight, this.minHeight);
    if (height === undefined) {
        height = minHeight;
    }

    return height;
};

var GetChildWidth = function (child) {
    var childWidth;
    if (child.isRexSizer) { // Sizer game object
        childWidth = Math.max(child.minWidth, child.childrenWidth);
    } else {  // Normal game object
        if (child.minWidth !== undefined) {  // Force minWidth
            childWidth = child.minWidth;
        } else {
            childWidth = GetDisplayWidth(child);
        }
    }

    return childWidth;
};

var GetChildHeight = function (child) {
    var childHeight;
    if (child.isRexSizer) {  // Sizer game object
        childHeight = Math.max(child.minHeight, child.childrenHeight);
    } else {  // Normal game object
        if (child.minHeight !== undefined) {  // Force minHeight
            childHeight = child.minHeight;
        } else {
            childHeight = GetDisplayHeight(child);
        }
    }
    return childHeight;
};

// Override
var GetExpandedChildWidth = function (child, parentWidth) {
    return parentWidth;
};

// Override
var GetExpandedChildHeight = function (child, parentHeight) {
    return parentHeight;
};

// Override
var GetChildrenWidth = function () {
    return 0;
};

// Override
var GetChildrenHeight = function () {
    return 0;
};

var GetAllChildrenSizers = function (out) {
    if (out === undefined) {
        out = [];
    }
    var startIdx = out.length;
    var children = this.getChildrenSizers(out);
    var endIdx = out.length;
    for (var i = startIdx; i < endIdx; i++) {
        children[i].getAllChildrenSizers(out);
    }

    return out;
};

// Default method
var GetChildrenSizers = function(out) {
    if (out === undefined) {
        out = [];
    }
    return out;
};

var GetShownChildrenMethods = {
    getShownChildren(out) {
        if (out === undefined) {
            out = [];
        }
        var children = this.children,
            child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.rexSizer && child.rexSizer.hidden) { // Don't add hidden child
                continue;
            }

            out.push(child);
        }

        return out;
    },

    getAllShownChildren(out) {
        if (out === undefined) {
            out = [];
        }

        var children = this.children,
            child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.rexSizer && child.rexSizer.hidden) { // Don't add hidden child
                continue;
            }

            out.push(child);

            if (child.hasOwnProperty('isRexContainerLite')) {
                out.push(...child.getAllShownChildren());
            }
        }

        return out;
    }
};

var PreLayout = function () {
    this._childrenWidth = undefined;
    this._childrenHeight = undefined;

    var children = this.getChildrenSizers(),
        child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.ignoreLayout) {
            continue;
        }
        child.preLayout();
    }
};

var Layout = function () {
    this.runLayout();
    return this;
};

// Override
var RunLayout = function (parent, newWidth, newHeight) {
    // Skip hidden or !dirty sizer
    if (this.ignoreLayout) {
        return this;
    }

    var isTopmostParent = !parent;
    // Preprocessor, top parent only
    if (isTopmostParent) {
        this.preLayout();
    }

    // Calculate parent width
    newWidth = this.resolveWidth(newWidth);
    // Calculate all children width, run width wrap
    if (isTopmostParent) {
        this.resolveChildrenWidth(newWidth);
        this.runWidthWrap(newWidth);
    }
    // Calculate parent height
    newHeight = this.resolveHeight(newHeight);
    // Resize parent
    this.resize(newWidth, newHeight);

    if (this.sizerEventsEnable) {
        if (this.layoutedChildren === undefined) {
            this.layoutedChildren = [];
        }
    }

    // Layout children    
    this.layoutChildren();

    // Layout background children
    this.layoutBackgrounds();

    if (this.sizerEventsEnable) {
        this.emit('postlayout', this.layoutedChildren, this);
        this.layoutedChildren.length = 0;
    }

    return this.postLayout();
};

// Override
var LayoutChildren = function () {

};

var PostLayout = function (parent, newWidth, newHeight) {
    if (this._anchor) {
        this._anchor.updatePosition();
    }
    return this;
};

// Default method
var RunWidthWrap = function (width) {
    var child, childWidth;
    for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (
            (!child) ||
            (child.isRexSizer && child.ignoreLayout)
        ) {
            continue;
        }

        childWidth = this.getExpandedChildWidth(child, width);
        if (childWidth === undefined) {
            childWidth = this.resolveWidth(childWidth);
        }
        if (child.runWidthWrap) {
            child.runWidthWrap(childWidth);
        }
    }
    return this;
};

const Rectangle$2 = Phaser.Geom.Rectangle;
const Center$1 = Phaser.Scale.Center;

var GetViewport = function (scene, out) {
    if (out === undefined) {
        out = new Rectangle$2();
    } else if (out === true) {
        out = globRect;
    }

    var scaleManager = scene.scale;
    var baseSize = scaleManager.baseSize;
    var parentSize = scaleManager.parentSize;
    var canvasBounds = scaleManager.canvasBounds;
    var displayScale = scaleManager.displayScale;

    var x = (canvasBounds.x >= 0) ? 0 : -(canvasBounds.x * displayScale.x);

    var y = (canvasBounds.y >= 0) ? 0 : -(canvasBounds.y * displayScale.y);

    var width;
    if (parentSize.width >= canvasBounds.width) {
        width = baseSize.width;
    } else {
        width = baseSize.width - (canvasBounds.width - parentSize.width) * displayScale.x;
    }

    var height;
    if (parentSize.height >= canvasBounds.height) {
        height = baseSize.height;
    } else {
        height = baseSize.height - (canvasBounds.height - parentSize.height) * displayScale.y;
    }

    out.setTo(x, y, width, height);

    return out;
};

var globRect = new Rectangle$2();

class Anchor extends ComponentBase {
    constructor(gameObject, config) {
        super(gameObject, { eventEmitter: false });
        // No event emitter
        // this.parent = gameObject;

        this.viewport = undefined;
        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        if (o === undefined) {
            o = {};
        }

        // Position
        var alignX, configX;
        if (o.x !== undefined) {
            alignX = null;
            configX = o.x;
        } else if (o.left !== undefined) {
            alignX = 0;
            configX = o.left;
        } else if (o.right !== undefined) {
            alignX = 1;
            configX = o.right;
        } else if (o.centerX !== undefined) {
            alignX = 0.5;
            configX = o.centerX;
        }

        var alignY, configY;
        if (o.y !== undefined) {
            alignY = null;
            configY = o.y;
        } else if (o.top !== undefined) {
            alignY = 0;
            configY = o.top;
        } else if (o.bottom !== undefined) {
            alignY = 1;
            configY = o.bottom;
        } else if (o.centerY !== undefined) {
            alignY = 0.5;
            configY = o.centerY;
        }

        var percentageX, offsetX;
        if (configX !== undefined) {
            configX = configX.replace('left', '0%').replace('right', '100%').replace('center', '50%').split('%');
            percentageX = parseFloat(configX[0]) / 100;
            offsetX = (configX[1] === '') ? 0 : parseFloat(configX[1]);
        }
        var percentageY, offsetY;
        if (configY !== undefined) {
            configY = configY.replace('top', '0%').replace('bottom', '100%').replace('center', '50%').split('%');
            percentageY = parseFloat(configY[0]) / 100;
            offsetY = (configY[1] === '') ? 0 : parseFloat(configY[1]);
        }

        // Size
        var configWidth = o.width;
        var percentageWidth, paddingWidth;
        if (configWidth !== undefined) {
            configWidth = configWidth.split('%');
            percentageWidth = parseFloat(configWidth[0]) / 100;
            paddingWidth = (configWidth[1] === '') ? 0 : parseFloat(configWidth[1]);
        }

        var configHeight = o.height;
        var percentageHeight, paddingHeight;
        if (configHeight !== undefined) {
            configHeight = configHeight.split('%');
            percentageHeight = parseFloat(configHeight[0]) / 100;
            paddingHeight = (configHeight[1] === '') ? 0 : parseFloat(configHeight[1]);
        }

        // Position
        this.setAlign(alignX, alignY);
        this.setPercentage(percentageX, percentageY);
        this.setOffset(offsetX, offsetY);
        // Size
        this.setSizePercentage(percentageWidth, percentageHeight);
        this.setSizePadding(paddingWidth, paddingHeight);

        var onResizeCallback = o.onResizeCallback;
        var onResizeCallbackScope = o.onResizeCallbackScope;
        if (onResizeCallback !== undefined) {
            this.setResizeCallback(onResizeCallback, onResizeCallbackScope);
        }

        var onUpdateViewportCallback = o.onUpdateViewportCallback;
        var onUpdateViewportCallbackScope = o.onUpdateViewportCallbackScope;
        if (onUpdateViewportCallback !== undefined) {
            this.setUpdateViewportCallback(onUpdateViewportCallback, onUpdateViewportCallbackScope);
        }

        return this;
    }

    boot() {
        this.scene.scale.on('resize', this.anchor, this);
        this.anchor();
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        this.scene.scale.off('resize', this.anchor, this);

        this.viewport = undefined;
        this.onUpdateViewportCallback = undefined;
        this.onUpdateViewportCallbackScope = undefined;
        this.onResizeCallback = undefined;
        this.onResizeCallbackScope = undefined;

        super.shutdown(fromScene);
    }

    // Position
    setAlign(x, y) {
        this.alignX = x;
        this.alignY = y;
        return this;
    }

    setPercentage(x, y) {
        this.percentageX = x;
        this.percentageY = y;
        return this;
    }

    setOffset(x, y) {
        this.offsetX = x;
        this.offsetY = y;
        return this;
    }

    // Size
    setSizePercentage(width, height) {
        this.percentageWidth = width;
        this.percentageHeight = height;
        return this;
    }

    setSizePadding(width, height) {
        this.paddingWidth = width;
        this.paddingHeight = height;
        return this;
    }

    setResizeCallback(callback, scope) {
        this.onResizeCallback = callback;
        this.onResizeCallbackScope = scope;
        return this;
    }

    setUpdateViewportCallback(callback, scope) {
        this.onUpdateViewportCallback = callback;
        this.onUpdateViewportCallbackScope = scope;
        return this;
    }

    anchor() {
        this.updateViewport();
        this.updateSize();
        this.updatePosition();
        return this;
    }

    updateSize() {
        var callback = this.onResizeCallback,
            scope = this.onResizeCallbackScope;
        var newWidth = this.anchorWidth,
            newHeight = this.anchorHeight;
        if (((newWidth === undefined) && (newHeight === undefined)) || !callback) {
            return;
        }

        var gameObject = this.parent;
        if (newWidth === undefined) {
            newWidth = gameObject.width;
        }
        if (newHeight === undefined) {
            newHeight = gameObject.height;
        }

        if (scope) {
            callback.call(scope, newWidth, newHeight, gameObject, this);
        } else {
            callback(newWidth, newHeight, gameObject, this);
        }
    }

    updatePosition() {
        var gameObject = this.parent;

        if (this.alignX === null) {
            gameObject.x = this.anchorX;
        } else if (this.alignX !== undefined) {
            gameObject.x = this.anchorX + (gameObject.displayWidth * (gameObject.originX - this.alignX));
        }

        if (this.alignY === null) {
            gameObject.y = this.anchorY;
        } else if (this.alignY !== undefined) {
            gameObject.y = this.anchorY + (gameObject.displayHeight * (gameObject.originY - this.alignY));
        }

        return this;
    }

    get anchorX() {
        return this.viewport.x + (this.viewport.width * this.percentageX) + this.offsetX;
    }

    get anchorY() {
        return this.viewport.y + (this.viewport.height * this.percentageY) + this.offsetY;
    }

    get anchorWidth() {
        if (this.percentageWidth === undefined) {
            return undefined;
        }
        return (this.viewport.width * this.percentageWidth) + this.paddingWidth;
    }

    get anchorHeight() {
        if (this.percentageHeight === undefined) {
            return undefined;
        }
        return (this.viewport.height * this.percentageHeight) + this.paddingHeight;
    }

    updateViewport() {
        this.viewport = GetViewport(
            this.scene,
            (this.viewport) ? this.viewport : true
        );

        var callback = this.onUpdateViewportCallback,
            scope = this.onUpdateViewportCallbackScope;
        if (callback) {
            if (scope) {
                callback.call(scope, this.viewport, this.parent, this);
            } else {
                callback(this.viewport, this.parent, this);
            }
        }
    }
}

var SetAnchor = function (config) {
    if (config === undefined) {
        config = {};
    }

    // Assign default onResizeCallback if not given    
    var hasMinWidth = config.hasOwnProperty('width');
    var hasMinHeight = config.hasOwnProperty('height');
    var hasOnResizeCallback = config.hasOwnProperty('onResizeCallback');
    if ((hasMinWidth || hasMinHeight) && !hasOnResizeCallback) {
        config.onResizeCallback = function (width, height, sizer) {
            if (hasMinWidth) {
                sizer.setMinWidth(width);
            }

            if (hasMinHeight) {
                sizer.setMinHeight(height);
            }

            sizer.layout();
        };
    }

    if (this._anchor === undefined) {
        this._anchor = new Anchor(this, config);
    } else {
        this._anchor.resetFromJSON(config);
    }
    return this;
};

const GetValue$1a = Phaser.Utils.Objects.GetValue;
const GetAdvancedValue$3 = Phaser.Utils.Objects.GetAdvancedValue;
const Linear$5 = Phaser.Math.Linear;

class Scale$1 extends EaseValueTaskBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;
        // this.timer

        this.scaleStart = {};
        this.scaleEnd = {};

        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);

        this.setMode(GetValue$1a(o, 'mode', 0));
        this.setScaleRange(
            GetAdvancedValue$3(o, 'start', undefined),
            GetAdvancedValue$3(o, 'end', 0)
        );

        return this;
    }

    setMode(m) {
        if (typeof (m) === 'string') {
            m = MODE$1[m];
        }
        this.mode = m;
        return this;
    }

    setScaleRange(start, end) {
        if (typeof (start) === 'number') {
            this.startX = start;
            this.startY = start;
        } else {
            this.startX = GetAdvancedValue$3(start, 'x', this.parent.scaleX);
            this.startY = GetAdvancedValue$3(start, 'y', this.parent.scaleY);
        }
        if (typeof (end) === 'number') {
            this.endX = end;
            this.endY = end;
        } else {
            this.endX = GetAdvancedValue$3(end, 'x', undefined);
            this.endY = GetAdvancedValue$3(end, 'y', undefined);
        }

        this.hasScaleX = (this.startX !== undefined) && (this.endX !== undefined);
        this.hasScaleY = (this.startY !== undefined) && (this.endY !== undefined);
        return this;
    }

    start() {
        if (this.timer.isRunning) {
            return this;
        }

        var gameObject = this.parent;
        if (this.hasScaleX) {
            gameObject.scaleX = this.startX;
        }
        if (this.hasScaleY) {
            gameObject.scaleY = this.startY;
        }

        this.timer
            .setDelay(this.delay)
            .setDuration(this.duration)
            .setRepeat((this.mode === 2) ? -1 : 0);

        super.start();
        return this;
    }

    updateGameObject(gameObject, timer) {
        var t = timer.t;
        if (timer.isOddIteration) {  // Yoyo
            t = 1 - t;
        }
        t = this.easeFn(t);

        if (this.hasScaleX) {
            gameObject.scaleX = Linear$5(this.startX, this.endX, t);
        }
        if (this.hasScaleY) {
            gameObject.scaleY = Linear$5(this.startY, this.endY, t);
        }
    }

    complete() {
        super.complete();

        if (this.mode === 1) {
            this.parent.destroy();
            // Will also destroy this behavior
        }
        return this;
    }
}

const MODE$1 = {
    stop: 0,
    destroy: 1,
    yoyo: 2
};

var PopUp = function (gameObject, duration, orientation, ease, scale) {
    var start;
    switch (orientation) {
        case 0:
        case 'x':
            start = { x: 0 };
            break;
        case 1:
        case 'y':
            start = { y: 0 };
            break;
        default:
            start = 0;
            break;
    }

    var config = {
        mode: 0,
        start: start,
        end: 1,
        duration: duration,
        ease: (ease === undefined) ? 'Cubic' : ease
    };

    if (scale === undefined) {
        scale = new Scale$1(gameObject, config);
    } else {
        scale.resetFromJSON(config);
    }
    scale.restart();

    return scale;
};

var ScaleDownDestroy = function (gameObject, duration, orientation, ease, destroyMode, scale) {
    if (destroyMode instanceof Scale$1) {
        scale = destroyMode;
        destroyMode = undefined;
    }

    if (destroyMode === undefined) {
        destroyMode = true;
    }

    var config = {};
    config.mode = (destroyMode) ? 1 : 0;
    switch (orientation) {
        case 0:
        case 'x':
            config.end = {
                x: 0
            };
            break;
        case 1:
        case 'y':
            config.end = {
                y: 0
            };
            break;
        default:
            config.end = 0;
            break;
    }
    config.duration = duration;
    config.ease = (ease === undefined) ? 'Linear' : ease;

    if (scale === undefined) {
        scale = new Scale$1(gameObject, config);
    } else {
        scale.resetFromJSON(config);
    }
    scale.restart();

    return scale;
};

const IsPlainObject$7 = Phaser.Utils.Objects.IsPlainObject;

var OnInitScale = function (gameObject, scale) {
    // Route 'complete' of scale to gameObject
    scale.completeEventName = undefined;
    scale.on('complete', function () {
        if (scale.completeEventName) {
            gameObject.emit(scale.completeEventName, gameObject);
            scale.completeEventName = undefined;
        }
    });

    // Update local state
    scale.on('update', function () {
        var parent = gameObject.getParentSizer();
        if (parent) {
            parent.resetChildPositionState(gameObject);
        }
    });
};

var ScaleMethods = {
    popUp(duration, orientation, ease) {
        if (IsPlainObject$7(duration)) {
            var config = duration;
            duration = config.duration;
            orientation = config.orientation;
            ease = config.ease;
        }

        var isInit = (this._scale === undefined);

        this._scale = PopUp(this, duration, orientation, ease, this._scale);

        if (isInit) {
            OnInitScale(this, this._scale);
        }

        this._scale.completeEventName = 'popup.complete';

        return this;
    },

    popUpPromise(duration, orientation, ease) {
        this.popUp(duration, orientation, ease);
        return WaitComplete(this._scale);
    },

    scaleDownDestroy(duration, orientation, ease, destroyMode) {
        if (IsPlainObject$7(duration)) {
            var config = duration;
            duration = config.duration;
            orientation = config.orientation;
            ease = config.ease;
            destroyMode = config.destroy;
        }

        var isInit = (this._scale === undefined);

        this._scale = ScaleDownDestroy(this, duration, orientation, ease, destroyMode, this._scale);

        if (isInit) {
            OnInitScale(this, this._scale);
        }

        this._scale.completeEventName = 'scaledown.complete';

        return this;
    },

    scaleDownDestroyPromise(duration, orientation, ease, destroyMode) {
        this.scaleDownDestroy(duration, orientation, ease, destroyMode);
        return WaitComplete(this._scale);
    },

    scaleDown(duration, orientation, ease) {
        this.scaleDownDestroy(duration, orientation, ease, false);
        return this;
    },

    scaleDownPromise(duration, orientation, ease) {
        this.scaleDown(duration, orientation, ease);
        return WaitComplete(this._scale);
    }


};

const GetValue$1b = Phaser.Utils.Objects.GetValue;
const GetAdvancedValue$4 = Phaser.Utils.Objects.GetAdvancedValue;
const Linear$6 = Phaser.Math.Linear;

class Fade$1 extends EaseValueTaskBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;
        // this.timer

        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);

        this.setMode(GetValue$1b(o, 'mode', 0));
        this.setAlphaRange(
            GetAdvancedValue$4(o, 'start', this.parent.alpha),
            GetAdvancedValue$4(o, 'end', 0)
        );
        return this;
    }

    setMode(m) {
        if (typeof (m) === 'string') {
            m = MODE$2[m];
        }
        this.mode = m;
        return this;
    }

    setAlphaRange(start, end) {
        this.alphaStart = start;
        this.alphaEnd = end;
        return this;
    }

    start() {
        if (this.timer.isRunning) {
            return this;
        }

        var gameObject = this.parent;
        gameObject.setAlpha(this.alphaStart);

        this.timer
            .setDelay(this.delay)
            .setDuration(this.duration)
            .setRepeat((this.mode === 2) ? -1 : 0);

        super.start();
        return this;
    }

    updateGameObject(gameObject, timer) {
        var t = timer.t;
        if (timer.isOddIteration) {  // Yoyo
            t = 1 - t;
        }

        gameObject.alpha = Linear$6(this.alphaStart, this.alphaEnd, t);
    }

    complete() {
        super.complete();
        if (this.mode === 1) {
            this.parent.destroy();
            // Will also destroy this behavior
        }
        return this;
    }

}

const MODE$2 = {
    stop: 0,
    destroy: 1,
    yoyo: 2
};

const IsPlainObject$8 = Phaser.Utils.Objects.IsPlainObject;

var FadeIn$1 = function (gameObject, duration, alpha, fade) {
    var startAlpha, endAlpha;
    if (IsPlainObject$8(alpha)) {
        startAlpha = alpha.start;
        endAlpha = alpha.end;
    } else {
        endAlpha = alpha;
    }
    if (startAlpha === undefined) {
        startAlpha = 0;
    }
    if (endAlpha === undefined) {
        endAlpha = 1;
    }

    var config = {
        mode: 0,
        start: startAlpha,
        end: endAlpha,
        duration: duration,
    };

    if (fade === undefined) {
        fade = new Fade$1(gameObject, config);
    } else {
        fade.resetFromJSON(config);
    }
    fade.restart();

    return fade;
};

var FadeOutDestroy = function (gameObject, duration, destroyMode, fade) {
    if (destroyMode instanceof Fade$1) {
        fade = destroyMode;
        destroyMode = undefined;
    }

    if (destroyMode === undefined) {
        destroyMode = true;
    }

    var config = {
        mode: (destroyMode) ? 1 : 0,
        end: 0,
        duration: duration,
    };

    if (fade === undefined) {
        fade = new Fade$1(gameObject, config);
    } else {
        fade.resetFromJSON(config);
    }
    fade.restart();

    return fade;
};

const IsPlainObject$9 = Phaser.Utils.Objects.IsPlainObject;

var OnInitFade = function (gameObject, fade) {
    // Route 'complete' of fade to gameObject
    fade.completeEventName = undefined;
    fade.on('complete', function () {
        if (fade.completeEventName) {
            gameObject.emit(fade.completeEventName, gameObject);
            fade.completeEventName = undefined;
        }
    });

    // Update local state
    fade.on('update', function () {
        var parent = gameObject.getParentSizer();
        if (parent) {
            parent.resetChildAlphaState(gameObject);
        }
    });
};

var FadeMethods = {
    fadeIn(duration, alpha) {
        if (IsPlainObject$9(duration)) {
            var config = duration;
            duration = config.duration;
        }

        var isInit = (this._fade === undefined);

        this._fade = FadeIn$1(this, duration, alpha, this._fade);

        if (isInit) {
            OnInitFade(this, this._fade);
        }

        this._fade.completeEventName = 'fadein.complete';

        return this;
    },

    fadeInPromoise(duration, alpha) {
        this.fadeIn(duration, alpha);
        return WaitComplete(this._fade);
    },

    fadeOutDestroy(duration, destroyMode) {
        if (IsPlainObject$9(duration)) {
            var config = duration;
            duration = config.duration;
            destroyMode = config.destroy;
        }

        var isInit = (this._fade === undefined);

        this._fade = FadeOutDestroy(this, duration, destroyMode, this._fade);

        if (isInit) {
            OnInitFade(this, this._fade);
        }

        this._fade.completeEventName = 'fadeout.complete';

        return this;
    },

    fadeOutDestroyPromise(duration, destroyMode) {
        this.fadeOutDestroy(duration, destroyMode);
        return WaitComplete(this._fade);
    },

    fadeOut(duration) {
        this.fadeOutDestroy(duration, false);
        return this;
    },

    fadeOutPromise(duration) {
        this.fadeOut(duration);
        return WaitComplete(this._fade);
    }
};

const GetValue$1c = Phaser.Utils.Objects.GetValue;
const GetAdvancedValue$5 = Phaser.Utils.Objects.GetAdvancedValue;
const Linear$7 = Phaser.Math.Linear;

class EaseMove extends EaseValueTaskBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;
        // this.timer

        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);

        this.setMode(GetValue$1c(o, 'mode', 0));

        if (o && (o.hasOwnProperty('x') || o.hasOwnProperty('y'))) {
            var endX = GetAdvancedValue$5(o, 'x', undefined);
            var endY = GetAdvancedValue$5(o, 'y', undefined);
            this.setTargetPosition(endX, endY);
        } else {
            this.setTargetPosition(o);
        }

        return this;
    }

    setMode(m) {
        if (typeof (m) === 'string') {
            m = MODE$3[m];
        }
        this.mode = m;
        return this;
    }

    setTargetPosition(x, y) {
        if ((typeof (x) === 'number') || (typeof (y) === 'number')) {
            // endX, endY
            // x,y : a number, or undefined
            this.startX = this.parent.x;
            this.startY = this.parent.y;
            this.endX = x;
            this.endY = y;
        } else {
            var config = x;
            this.startX = GetAdvancedValue$5(config, 'startX', undefined);
            this.startY = GetAdvancedValue$5(config, 'startY', undefined);
            this.endX = GetAdvancedValue$5(config, 'endX', undefined);
            this.endY = GetAdvancedValue$5(config, 'endY', undefined);
        }

        this.hasMoveX = (this.startX !== undefined) && (this.endX !== undefined);
        this.hasMoveY = (this.startY !== undefined) && (this.endY !== undefined);
        return this;
    }

    start() {
        if (this.timer.isRunning) {
            return this;
        }

        var gameObject = this.parent;
        if (this.hasMoveX) {
            gameObject.x = this.startX;
        }
        if (this.hasMoveY) {
            gameObject.y = this.startY;
        }

        this.timer
            .setDelay(this.delay)
            .setDuration(this.duration)
            .setRepeat((this.mode === 2) ? -1 : 0);

        super.start();
        return this;
    }

    updateGameObject(gameObject, timer) {
        var t = timer.t;
        if (timer.isOddIteration) {   // Yoyo
            t = 1 - t;
        }
        t = this.easeFn(t);

        if (this.hasMoveX) {
            gameObject.x = Linear$7(this.startX, this.endX, t);
        }
        if (this.hasMoveY) {
            gameObject.y = Linear$7(this.startY, this.endY, t);
        }
    }

    complete() {
        super.complete();

        if (this.mode === 1) {
            this.parent.destroy();
            // Will also destroy this behavior
        }
        return this;
    }
}

const MODE$3 = {
    stop: 0,
    destroy: 1,
    yoyo: 2
};

var ParseValue$1 = function (propertyValue, startValue) {
    // propertyValue : number or string
    if (typeof (propertyValue) === 'number') {
        return propertyValue;
    } else {
        var op = propertyValue[0];
        var num = parseFloat(propertyValue.substr(2));
        switch (op) {
            case '+': return startValue + num;
            case '-': return startValue - num;
            case '*': return startValue * num;
            case '/': return startValue / num;
        }
    }
};

var EaseMoveTo = function (gameObject, duration, endX, endY, ease, destroyMode, easeMove) {
    if (destroyMode instanceof EaseMove) {
        easeMove = destroyMode;
        destroyMode = undefined;
    }

    if (destroyMode === undefined) {
        destroyMode = false;
    }

    var config = {};
    config.mode = (destroyMode) ? 1 : 0;
    if (endX !== undefined) {
        config.startX = gameObject.x;
        config.endX = ParseValue$1(endX, gameObject.x);
    }
    if (endY !== undefined) {
        config.startY = gameObject.y;
        config.endY = ParseValue$1(endY, gameObject.y);
    }
    config.duration = duration;
    config.ease = (ease === undefined) ? 'Linear' : ease;

    if (easeMove === undefined) {
        easeMove = new EaseMove(gameObject, config);
    } else {
        easeMove.resetFromJSON(config);
    }
    easeMove.restart();

    return easeMove;
};

var EaseMoveFrom = function (gameObject, duration, startX, startY, ease, destroyMode, easeMove) {
    if (destroyMode instanceof EaseMove) {
        easeMove = destroyMode;
        destroyMode = undefined;
    }

    if (destroyMode === undefined) {
        destroyMode = false;
    }

    var config = {};
    config.mode = (destroyMode) ? 1 : 0;
    if (startX !== undefined) {
        config.startX = ParseValue$1(startX, gameObject.x);
        config.endX = gameObject.x;
    }
    if (startY !== undefined) {
        config.startY = ParseValue$1(startY, gameObject.y);
        config.endY = gameObject.y;
    }
    config.duration = duration;
    config.ease = (ease === undefined) ? 'Linear' : ease;

    if (easeMove === undefined) {
        easeMove = new EaseMove(gameObject, config);
    } else {
        easeMove.resetFromJSON(config);
    }
    easeMove.restart();

    return easeMove;
};

const IsPlainObject$a = Phaser.Utils.Objects.IsPlainObject;
const DistanceBetween$1 = Phaser.Math.Distance.Between;

var OnInitEaseMove = function (gameObject, easeMove) {
    // Route 'complete' of easeMove to gameObject
    easeMove.completeEventName = undefined;
    easeMove.on('complete', function () {
        if (easeMove.completeEventName) {
            gameObject.emit(easeMove.completeEventName, gameObject);
            easeMove.completeEventName = undefined;
        }
    });

    // Update local state
    easeMove.on('update', function () {
        var parent = gameObject.getParentSizer();
        if (parent) {
            parent.resetChildPositionState(gameObject);
        }
    });
};

var EaseMoveMethods = {
    moveFrom(duration, x, y, ease, destroyMode) {
        if (IsPlainObject$a(duration)) {
            var config = duration;
            x = config.x;
            y = config.y;
            if (config.hasOwnProperty('speed')) {
                duration = (DistanceBetween$1(x, y, this.x, this.y) * 1000) / config.speed;
            } else {
                duration = config.duration;
            }

            ease = config.ease;
        }

        var isInit = (this._easeMove === undefined);

        this._easeMove = EaseMoveFrom(this, duration, x, y, ease, destroyMode, this._easeMove);

        if (isInit) {
            OnInitEaseMove(this, this._easeMove);
        }

        this._easeMove.completeEventName = 'movefrom.complete';

        return this;
    },

    moveFromPromise(duration, x, y, ease, destroyMode) {
        this.moveFrom(duration, x, y, ease, destroyMode);
        return WaitComplete(this._easeMove);
    },

    moveFromDestroy(duration, x, y, ease) {
        this.moveFrom(duration, x, y, ease, true);
        return this;
    },

    moveFromDestroyPromise(duration, x, y, ease) {
        this.moveFromDestroy(duration, x, y, ease);
        return WaitComplete(this._easeMove);
    },

    moveTo(duration, x, y, ease, destroyMode) {
        if (IsPlainObject$a(duration)) {
            var config = duration;
            x = config.x;
            y = config.y;
            if (config.hasOwnProperty('speed')) {
                duration = (DistanceBetween$1(x, y, this.x, this.y) * 1000) / config.speed;
            } else {
                duration = config.duration;
            }

            ease = config.ease;
        }

        var isInit = (this._easeMove === undefined);

        this._easeMove = EaseMoveTo(this, duration, x, y, ease, destroyMode, this._easeMove);

        if (isInit) {
            OnInitEaseMove(this, this._easeMove);
        }

        this._easeMove.completeEventName = 'moveto.complete';

        return this;
    },

    moveToPromise(duration, x, y, ease, destroyMode) {
        this.moveTo(duration, x, y, ease, destroyMode);
        return WaitComplete(this._easeMove);
    },

    moveToDestroy(duration, x, y, ease) {
        this.moveTo(duration, x, y, ease, true);
        return this;
    },

    moveToDestroyPromise(duration, x, y, ease) {
        this.moveToDestroy(duration, x, y, ease, true);
        return WaitComplete(this._easeMove);
    }
};

var Show = function (gameObject) {
    _hide(gameObject, false);
};

var Hide = function (gameObject) {
    _hide(gameObject, true);
};

var IsShown = function (gameObject) {
    if (!gameObject) {
        return false;
    }
    var config = GetSizerConfig(gameObject);
    return !config.hidden;
};

var _hide = function (gameObject, hidden) {
    if (!gameObject) {
        return;
    }
    var config = GetSizerConfig(gameObject);
    config.hidden = hidden;
    gameObject.rexContainer.parent.setChildVisible(gameObject, !hidden);
};

var HideMethods = {
    show(gameObject) {
        if (gameObject === undefined) {
            gameObject = this;
        }
        Show(gameObject);
        return this;
    },

    hide(gameObject) {
        if (gameObject === undefined) {
            gameObject = this;
        }
        Hide(gameObject);
        return this;
    },

    isShow(gameObject) {
        if (gameObject === undefined) {
            gameObject = this;
        }
        return IsShown(gameObject);
    }
};

var IsPointInBounds = function (gameObject, x, y, preTest, postTest) {
    // Can't get bounds
    if (!gameObject || !gameObject.getBounds) {
        return false;
    }

    if (preTest && !preTest(gameObject, x, y)) {
        return false;
    }

    globRect$1 = gameObject.getBounds(globRect$1);

    if (!globRect$1.contains(x, y)) {
        return false;
    }

    if (postTest && !postTest(gameObject, x, y)) {
        return false;
    }

    return true;
};

var globRect$1 = undefined;

var IsPointerInBounds = function (gameObject, pointer, preTest, postTest) {
    if (pointer) {
        return IsPointInBounds(gameObject, pointer.x, pointer.y, preTest, postTest);

    } else {
        var inputManager = gameObject.scene.input.manager;
        var pointersTotal = inputManager.pointersTotal;
        var pointers = inputManager.pointers;
        for (var i = 0; i < pointersTotal; i++) {
            pointer = pointers[i];
            if (IsPointInBounds(gameObject, pointer.x, pointer.y, preTest, postTest)) {
                return true;
            }
        }
        return false;

    }

};

var IsInTouching = function (pointer, gameObject) {
    if (gameObject === undefined) {
        gameObject = this;
    }
    return IsPointerInBounds(gameObject, pointer);
};

var IsFunction = function (obj) {    
    return obj && (typeof(obj) === 'function');
};

var ContainsPoint = function (gameObject, x, y, preTest, postTest) {
    return IsPointInBounds(
        gameObject,
        x, y,
        GetPreTestCallback(preTest),
        GetPostTestCallback(postTest)
    );
};

var IsNotHiddenSizer = function (gameObject) {
    var isHiddenSizer = gameObject.rexSizer && gameObject.rexSizer.hidden;
    return !isHiddenSizer;
};

var GetPreTestCallback = function (preTest) {
    if (!preTest) {
        return IsNotHiddenSizer;
    }

    return function (gameObject, x, y) {
        if (!IsNotHiddenSizer(gameObject)) {
            return false;
        }
        preTest(gameObject, x, y);
        return true;
    }
};

var GetPostTestCallback = function (postTest) {
    return postTest;
};

var PointToChild = function (x, y, preTest, postTest, children) {
    if (!IsFunction(preTest)) {
        children = preTest;
        preTest = undefined;
        postTest = undefined;
    }

    if (children === undefined) {
        if (this.sizerChildren) {
            children = this.sizerChildren;
        } else {
            children = this.children;
        }
    }

    if (IsArray(children)) {
        var child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (ContainsPoint(child, x, y, preTest, postTest)) {
                return child;
            }
        }
    } else {
        var child;
        for (var key in children) {
            child = children[key];
            if (ContainsPoint(child, x, y, preTest, postTest)) {
                return child;
            }
        }
    }

    return null;
};

var GetParentSizerMethods = {
    getParentSizer(gameObject) {
        return this.getParent(gameObject);
    },

    getTopmostSizer(gameObject) {
        return this.getTopmostParent(gameObject);
    }
};

var ResizeGameObject = function (gameObject, newWidth, newHeight) {
    if (!gameObject || ((newWidth === undefined) && (newHeight === undefined))) {
        return;
    }
    if (gameObject.resize) { // Has `resize` method
        if (newWidth === undefined) {
            newWidth = gameObject.width;
        }
        if (newHeight === undefined) {
            newHeight = gameObject.height;
        }
        gameObject.resize(newWidth, newHeight);
    } else { // Set display width/height
        if (newWidth !== undefined) {
            gameObject.displayWidth = newWidth;
        }
        if (newHeight !== undefined) {
            gameObject.displayHeight = newHeight;
        }
    }
};

var CopyState = function (gamObject, out) {
    if (out === undefined) {
        out = {};
    } else if (out === true) {
        out = GlobState;
    }

    out.x = gamObject.x;
    out.y = gamObject.y;
    out.scaleX = gamObject.scaleX;
    out.scaleY = gamObject.scaleY;
    out.width = gamObject.width;
    out.height = gamObject.height;
    out.displayWidth = gamObject.displayWidth;
    out.displayHeight = gamObject.displayHeight;

    return out;
};

var GlobState = {};

var PreLayoutChild = function (child) {
    if (this.sizerEventsEnable) {
        CopyState(child, this.getChildPrevState(child));
        this.layoutedChildren.push(child);
    }
};

var LayoutChild = function (child, x, y, width, height, align, offsetX, offsetY) {
    AlignIn(child, x, y, width, height, align);

    if (offsetX !== undefined) {
        child.x += offsetX;
    }
    if (offsetY !== undefined) {
        child.y += offsetY;
    }

    this.resetChildPositionState(child);

    if (this.sizerEventsEnable) {
        child.emit('sizer.postlayout', child, this);
    }
};

const ALIGN_CENTER = Phaser.Display.Align.CENTER;

var LayoutBackgrounds = function () {
    if (this.backgroundChildren === undefined) {
        return;
    }
    var backgrounds = this.backgroundChildren;

    var startX = this.left,
        startY = this.top;
    var parentWidth = this.width,
        parentHeight = this.height;
    var child, childConfig, padding,
        x, y, width, height;
    for (var i = 0, cnt = backgrounds.length; i < cnt; i++) {
        child = backgrounds[i];
        childConfig = child.rexSizer;
        if (childConfig.hidden) {
            continue;
        }

        padding = childConfig.padding;

        PreLayoutChild.call(this, child);

        x = startX + padding.left;
        y = startY + padding.top;
        width = parentWidth - padding.left - padding.right;
        height = parentHeight - padding.top - padding.bottom;

        ResizeGameObject(child, width, height);

        LayoutChild.call(this, child, x, y, width, height, ALIGN_CENTER);
    }
};

var SetDraggable = function (senser, draggable) {
    var senserType = typeof (senser);
    if (senserType === 'string') {
        senser = this.getElement(senser);
    } else if ((senser === undefined) || (senserType != 'object')) {
        draggable = senser;
        senser = this;
    }
    if (draggable === undefined) {
        draggable = true;
    }

    if (senser.input && senser.input.hasOwnProperty('draggable')) {
        // Draggable is already registered
        senser.input.draggable = draggable;
    } else if (draggable) {
        // Register draggable
        senser.setInteractive();
        senser.scene.input.setDraggable(senser);
        senser.on('drag', function (pointer, dragX, dragY) {
            var topmostParent = this.getTopmostSizer();
            topmostParent.x += (dragX - senser.x);
            topmostParent.y += (dragY - senser.y);
        }, this);
    } else ;
    return this;
};

const GetValue$1d = Phaser.Utils.Objects.GetValue;

class Button extends ComponentBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;

        this._enable = undefined;
        gameObject.setInteractive(GetValue$1d(config, "inputConfig", undefined));
        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        this.pointer = undefined;
        this.lastClickTime = undefined;
        this.setEnable(GetValue$1d(o, "enable", true));
        this.setMode(GetValue$1d(o, "mode", 1));
        this.setClickInterval(GetValue$1d(o, "clickInterval", 100));
        this.setDragThreshold(GetValue$1d(o, 'threshold', undefined));
        return this;
    }

    boot() {
        var gameObject = this.parent;
        gameObject.on('pointerdown', this.onPress, this);
        gameObject.on('pointerup', this.onRelease, this);
        gameObject.on('pointerout', this.onPointOut, this);
        gameObject.on('pointermove', this.onMove, this);
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        // GameObject events will be removed when this gameObject destroyed 
        // this.parent.on('pointerdown', this.onPress, this);
        // this.parent.on('pointerup', this.onRelease, this);
        // this.parent.on('pointerout', this.onPointOut, this);
        // this.parent.on('pointermove', this.onMove, this);
        this.pointer = null;

        super.shutdown(fromScene);
    }

    get enable() {
        return this._enable;
    }

    set enable(e) {
        if (this._enable === e) {
            return;
        }

        if (!e) {
            this.cancel();
        }
        this._enable = e;

        var eventName = (e) ? 'enable' : 'disable';
        this.emit(eventName, this, this.parent);
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }

        this.enable = e;
        return this;
    }

    toggleEnable() {
        this.setEnable(!this.enable);
        return this;
    }

    setMode(m) {
        if (typeof (m) === 'string') {
            m = CLICKMODE[m];
        }
        this.mode = m;
        return this;
    }

    setClickInterval(interval) {
        this.clickInterval = interval; // ms
        return this;
    }

    setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
    }

    // internal
    onPress(pointer, localX, localY, event) {
        if (this.pointer !== undefined) {
            return;
        }
        this.pointer = pointer;
        if (this.mode === 0) {
            this.click(pointer.downTime, pointer, event);
        }
    }

    onRelease(pointer, localX, localY, event) {
        if (this.pointer !== pointer) {
            return;
        }
        if (this.mode === 1) {
            this.click(pointer.upTime, pointer, event);
        }
        this.pointer = undefined;
    }

    onPointOut(pointer, event) {
        if (this.pointer !== pointer) {
            return;
        }
        this.cancel();
    }

    onMove(pointer, localX, localY, event) {
        if (this.pointer !== pointer) {
            return;
        }

        if (this.dragThreshold === undefined) {
            return;
        }

        if (pointer.getDistance() >= this.dragThreshold) {
            this.cancel();
        }
    }

    click(nowTime, pointer, event) {
        if (!this.enable) {
            return this;
        }

        if (nowTime === undefined) {
            // fires 'click' event manually
            this.emit('click', this, this.parent, pointer, event);
            return this;
        }

        this.pointer = undefined;
        var lastClickTime = this.lastClickTime;
        if ((lastClickTime !== undefined) &&
            ((nowTime - lastClickTime) <= this.clickInterval)) {
            return this;
        }
        this.lastClickTime = nowTime;
        this.emit('click', this, this.parent, pointer, event);
        return this;
    }

    cancel() {
        this.pointer = undefined;
        return this;
    }
}

const CLICKMODE = {
    press: 0,
    pointerdown: 0,
    release: 1,
    pointerup: 1,
};

var ClickMethods = {
    onClick(callback, scope, config) {
        if (!callback) {
            return this;
        }
        if (this._click === undefined) {
            this._click = new Button(this, config);
        }
        this._click.on('click', callback, scope);
        return this;
    },

    offClick(callback, scope) {
        if (this._click === undefined) {
            return this;
        }

        this._click.off('click', callback, scope);
        return this;
    },

    enableClick(enabled) {
        if (this._click === undefined) {
            return this;
        }

        this._click.setEnable(enabled);
        return this;
    },

    disableClick() {
        if (this._click === undefined) {
            return this;
        }

        this._click.setEnable(false);
        return this;
    }
};

var BroadcastEvent = function () {
    var gameObjects = this.getAllChildren([this]);
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        var gameObject = gameObjects[i];
        gameObject.emit.apply(gameObject, arguments);
    }
    return this;
};

var methods$3 = {
    getSizerConfig: GetSizerConfig,
    getChildPrevState: GetChildPrevState,
    pushIntoBounds: PushIntoBounds,
    drawBounds: DrawBounds,
    resolveWidth: ResolveWidth,
    resolveChildrenWidth: ResolveChildrenWidth,
    resolveHeight: ResolveHeight,
    getChildWidth: GetChildWidth,
    getChildHeight: GetChildHeight,
    getExpandedChildWidth: GetExpandedChildWidth,
    getExpandedChildHeight: GetExpandedChildHeight,

    getChildrenWidth: GetChildrenWidth,
    getChildrenHeight: GetChildrenHeight,
    addChildrenMap: AddChildrenMap,
    addElement: AddChildrenMap,
    getElement: GetElement,
    getAllChildrenSizers: GetAllChildrenSizers,
    getChildrenSizers: GetChildrenSizers,
    preLayout: PreLayout,
    layout: Layout,
    runLayout: RunLayout,
    layoutChildren: LayoutChildren,
    runWidthWrap: RunWidthWrap,
    layoutBackgrounds: LayoutBackgrounds,
    postLayout: PostLayout,

    setAnchor: SetAnchor,
    isInTouching: IsInTouching,
    pointToChild: PointToChild,
    setDraggable: SetDraggable,
    broadcastEvent: BroadcastEvent,

};

Object.assign(
    methods$3,
    PaddingMethods,
    AddChildMethods,
    GetParentSizerMethods,
    ScaleMethods,
    FadeMethods,
    EaseMoveMethods,
    ClickMethods,
    HideMethods,
    GetShownChildrenMethods,
);

const GetValue$1e = Phaser.Utils.Objects.GetValue;

class Base$2 extends ContainerLite {
    constructor(scene, x, y, minWidth, minHeight, config) {
        super(scene, x, y, 2, 2);

        this.isRexSizer = true;
        this.setMinSize(minWidth, minHeight);
        this.setName(GetValue$1e(config, 'name', ''));
        this.rexSizer = {};
        this.space = {};
        this.backgroundChildren = undefined;
        this.sizerChildren = undefined; // [] or {}
        this.layoutedChildren = undefined;

        var anchorConfig = GetValue$1e(config, 'anchor', undefined);
        if (anchorConfig) {
            this.setAnchor(anchorConfig);
        }

        this.setInnerPadding(GetValue$1e(config, 'space', 0));
        this.setDraggable(GetValue$1e(config, 'draggable', false));
        this.setSizerEventsEnable(GetValue$1e(config, 'sizerEvents', false));
        this.setDirty(true);
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        if (fromScene) {
            // In this case, children will be cleared and destroy in scene level
            var sizers = this.getAllChildrenSizers([this]);
            for (var i = 0, cnt = sizers.length; i < cnt; i++) {
                sizers[i].sizerEventsEnable = false;
            }
        }

        super.destroy(fromScene);

        this.backgroundChildren = undefined;
        this.sizerChildren = undefined;
        this.childrenMap = undefined;
        this.space = undefined;
        this.rexSizer = undefined;
        this.layoutedChildren = undefined;
    }

    setMinSize(minWidth, minHeight) {
        this.setMinWidth(minWidth).setMinHeight(minHeight);
        return this;
    }

    setMinWidth(minWidth) {
        if (minWidth == null) {
            minWidth = 0;
        }
        this.minWidth = minWidth;
        return this;
    }

    setMinHeight(minHeight) {
        if (minHeight == null) {
            minHeight = 0;
        }
        this.minHeight = minHeight;
        return this;
    }

    setDirty(dirty) {
        if (dirty === undefined) {
            dirty = true;
        }
        this.dirty = dirty;
        return this;
    }

    setSizerEventsEnable(enable) {
        if (enable === undefined) {
            enable = true;
        }

        this.sizerEventsEnable = enable;
        return this;
    }

    get ignoreLayout() {
        // Skip hidden or !dirty sizer
        return this.rexSizer.hidden || (!this.dirty);
    }

    get childrenWidth() {
        if (this._childrenWidth === undefined) {
            this._childrenWidth = this.getChildrenWidth();
        }
        return this._childrenWidth;
    }

    get childrenHeight() {
        if (this._childrenHeight === undefined) {
            this._childrenHeight = this.getChildrenHeight();
        }
        return this._childrenHeight;
    }

    get left() {
        return this.x - (GetDisplayWidth(this) * this.originX);
    }

    set left(value) {
        this.x += (value - this.left);
    }

    alignLeft(value) {
        this.left = value;
        return this;
    }

    get right() {
        return this.left + GetDisplayWidth(this);
    }

    set right(value) {
        this.x += (value - this.right);
    }

    alignRight(value) {
        this.right = value;
        return this;
    }

    get centerX() {
        return this.left + (GetDisplayWidth(this) / 2);
    }

    set centerX(value) {
        this.x += (value - this.centerX);
    }

    alignCenterX(value) {
        this.centerX = value;
        return this;
    }

    get top() {
        return this.y - (GetDisplayHeight(this) * this.originY);
    }

    set top(value) {
        this.y += (value - this.top);
    }

    alignTop(value) {
        this.top = value;
        return this;
    }

    get bottom() {
        return this.top + GetDisplayHeight(this);
    }

    set bottom(value) {
        this.y += (value - this.bottom);
    }

    alignBottom(value) {
        this.bottom = value;
        return this;
    }

    get centerY() {
        return this.top + (GetDisplayHeight(this) / 2);
    }

    set centerY(value) {
        this.y += (value - this.centerY);
    }

    alignCenterY(value) {
        this.centerY = value;
        return this;
    }

    get innerLeft() {
        return this.left + this.space.left;
    }

    get innerRight() {
        return this.right - this.space.right;
    }

    get innerTop() {
        return this.top + this.space.top;
    }

    get innerBottom() {
        return this.bottom - this.space.bottom;
    }

    get innerWidth() {
        return this.width - this.space.left - this.space.right;
    }

    get innerHeight() {
        return this.height - this.space.top - this.space.bottom;
    }

    get minInnerWidth() {
        var result = this.minWidth - this.space.left - this.space.right;
        return Math.max(result, 0);
    }

    get minInnerHeight() {
        var result = this.minHeight - this.space.top - this.space.bottom;
        return Math.max(result, 0);
    }
}

Object.assign(
    Base$2.prototype,
    methods$3
);

var GetChildrenWidth$1 = function () {
    if (this.rexSizer.hidden) {
        return 0;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childWidth;
    for (var key in children) {
        child = children[key];

        padding = child.rexSizer.padding;
        childWidth = this.getChildWidth(child) + padding.left + padding.right;
        result = Math.max(childWidth, result);
    }
    return result + this.space.left + this.space.right;
};

var GetChildrenHeight$1 = function () {
    if (this.rexSizer.hidden) {
        return 0;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childHeight;
    for (var key in children) {
        child = children[key];
        childHeight = (child.isRexSizer) ?
            Math.max(child.minHeight, child.childrenHeight) :
            (child.minHeight !== undefined) ? child.minHeight : GetDisplayHeight(child);

        padding = child.rexSizer.padding;
        childHeight += (padding.top + padding.bottom);
        result = Math.max(childHeight, result);
    }
    return result + this.space.top + this.space.bottom;
};

var GetExpandedChildWidth$1 = function (child, parentWidth) {
    if (parentWidth === undefined) {
        parentWidth = this.width;
    }

    var childWidth;
    var childConfig = child.rexSizer;    
    if (childConfig.expandWidth) {        
        var innerWidth = parentWidth - this.space.left - this.space.right;
        var padding = childConfig.padding;
        childWidth = innerWidth - padding.left - padding.right;
    }
    return childWidth;
};

var GetExpandedChildHeight$1 = function (child, parentHeight) {
    if (parentHeight === undefined) {
        parentHeight = this.height;
    }

    var childHeight;
    var childConfig = child.rexSizer;
    if (childConfig.expandHeight) {
        var innerHeight = parentHeight - this.space.top - this.space.bottom;
        var padding = childConfig.padding;
        childHeight = innerHeight - padding.top - padding.bottom;
    }
    return childHeight;
};

var GetChildrenSizers$1 = function (out) {
    if (out === undefined) {
        out = [];
    }
    var children = this.sizerChildren,
        child;
    for (var key in children) {
        child = children[key];
        if (child.isRexSizer) {
            out.push(child);
        }
    }
    return out;
};

var CheckSize = function (child, parent) {
    if (child.width < child.childrenWidth) {
        // Warning
        console.warn(`Layout width error: Parent=${parent.constructor.name}, Child=${child.constructor.name}`);
    }
    if (child.height < child.childrenHeight) {
        // Warning
        console.warn(`Layout height error: Parent=${parent.constructor.name}, Child=${child.constructor.name}`);
    }
};

var LayoutChildren$1 = function () {
    var child, childConfig, padding;
    var startX = this.innerLeft,
        startY = this.innerTop;
    var innerWidth = this.innerWidth,
        innerHeight = this.innerHeight;
    var x, y, width, height; // Align zone
    var childWidth, childHeight;
    // Layout current page
    var children = this.sizerChildren;
    for (var key in children) {
        child = children[key];
        if (child.rexSizer.hidden) {
            continue;
        }

        childConfig = child.rexSizer;
        padding = childConfig.padding;

        PreLayoutChild.call(this, child);

        // Set size
        if (child.isRexSizer) {
            child.runLayout(
                this,
                this.getExpandedChildWidth(child),
                this.getExpandedChildHeight(child)
            );
            CheckSize(child, this);
        } else {
            childWidth = undefined;
            childHeight = undefined;
            if (childConfig.expandWidth) { // Expand width
                childWidth = innerWidth - padding.left - padding.right;
            }
            if (childConfig.expandHeight) { // Expand height
                childHeight = innerHeight - padding.top - padding.bottom;
            }
            ResizeGameObject(child, childWidth, childHeight);
        }

        // Set position
        x = (startX + padding.left);
        width = innerWidth - padding.left - padding.right;
        y = (startY + padding.top);
        height = innerHeight - padding.top - padding.bottom;

        LayoutChild.call(this,
            child, x, y, width, height, childConfig.align,
            childConfig.alignOffsetX, childConfig.alignOffsetY
        );
    }
};

const IsPlainObject$b = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1f = Phaser.Utils.Objects.GetValue;
const ALIGN_CENTER$1 = Phaser.Display.Align.CENTER;
const UUID = Phaser.Utils.String.UUID;

var Add$1 = function (gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY) {
    AddChild$1.call(this, gameObject);

    if (IsPlainObject$b(childKey)) {
        var config = childKey;
        childKey = GetValue$1f(config, 'key', undefined);
        align = GetValue$1f(config, 'align', ALIGN_CENTER$1);
        offsetX = GetValue$1f(config, 'offsetX', 0);
        offsetY = GetValue$1f(config, 'offsetY', 0);
        padding = GetValue$1f(config, 'padding', 0);
        expand = GetValue$1f(config, 'expand', true);

        if (!gameObject.isRexSizer) {
            // Get minWidth,minHeight from config
            minWidth = GetValue$1f(config, 'minWidth', gameObject._minWidth);
            minHeight = GetValue$1f(config, 'minHeight', gameObject._minHeighted);
        }
    }

    var hasValidKey = (childKey !== undefined);
    if (!hasValidKey) {
        childKey = UUID();
    }

    if (typeof (align) === 'string') {
        align = ALIGNMODE[align];
    }

    if (align === undefined) {
        align = ALIGN_CENTER$1;
    }
    if (offsetX === undefined) {
        offsetX = 0;
    }
    if (offsetY === undefined) {
        offsetY = 0;
    }
    if (padding === undefined) {
        padding = 0;
    }
    if (expand === undefined) {
        expand = true;
    }
    if (!gameObject.isRexSizer) {
        // Get minWidth,minHeight from game object
        if (minWidth === undefined) {
            minWidth = gameObject._minWidth;
        }
        if (minHeight === undefined) {
            minHeight = gameObject._minHeight;
        }
    }

    var config = this.getSizerConfig(gameObject);
    config.align = align;
    config.alignOffsetX = offsetX;
    config.alignOffsetY = offsetY;
    config.padding = GetBoundsConfig(padding);

    if (IsPlainObject$b(expand)) {
        config.expandWidth = GetValue$1f(expand, 'width', false);
        config.expandHeight = GetValue$1f(expand, 'height', false);
    } else {
        config.expandWidth = expand;
        config.expandHeight = expand;
    }

    if (!gameObject.isRexSizer) {  // Expand normal game object
        if (config.expandWidth) {
            // minWidth is still undefined, uses current display width
            gameObject.minWidth = (minWidth === undefined) ? GetDisplayWidth(gameObject) : minWidth;
        } else {
            gameObject.minWidth = undefined;
        }
        if (config.expandHeight) {
            // minHeight is still undefined, uses current display height
            gameObject.minHeight = (minHeight === undefined) ? GetDisplayHeight(gameObject) : minHeight;
        } else {
            gameObject.minHeight = undefined;
        }
    }

    if (this.sizerChildren.hasOwnProperty(childKey)) {
        this.sizerChildren[childKey].destroy();
    }
    this.sizerChildren[childKey] = gameObject;

    if (hasValidKey) {
        this.addChildrenMap(childKey, gameObject);
    }
    return this;
};

var AddChildMethods$1 = {
    add: Add$1
};

const RemoveItem$4 = Phaser.Utils.Array.Remove;
const ContainerRemove = ContainerLite.prototype.remove;

var RemoveChild$1 = function (gameObject, destroyChild) {
    if (this.isBackground(gameObject)) {
        RemoveItem$4(this.backgroundChildren, gameObject);
    }
    ContainerRemove.call(this, gameObject, destroyChild);

    if (!destroyChild && this.sizerEventsEnable) {
        gameObject.emit('sizer.remove', gameObject, this);
        this.emit('remove', gameObject, this);
    }
    return this;
};

const ContainerClear = ContainerLite.prototype.clear;

var ClearChildren = function (destroyChild) {
    if (this.backgroundChildren) {
        this.backgroundChildren.length = 0;
    }

    var fireRemoveEvent = !destroyChild && this.sizerEventsEnable;
    var children;
    if (fireRemoveEvent) {
        children = this.getChildren([]);
    }

    ContainerClear.call(this, destroyChild);

    if (fireRemoveEvent) {
        var gameObject;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            gameObject = children[i];
            gameObject.emit('sizer.remove', gameObject, this);
            this.emit('remove', gameObject, this);
        }
    }
    return this;
};

var RemoveChildMethods = {
    remove(gameObject, destroyChild) {
        var key;
        if (typeof (gameObject) === 'string') {
            key = gameObject;
            gameObject = this.sizerChildren[key];
            if (!gameObject) {
                return this;
            }
        } else if (this.getParentSizer(gameObject) !== this) {
            return this;
        } else {
            key = this.childToKey(gameObject);
        }

        if (key) {
            delete this.sizerChildren[key];
            if (this.childrenMap.hasOwnProperty(key)) {
                delete this.childrenMap[key];
            }
        }
        RemoveChild$1.call(this, gameObject, destroyChild);
        return this;
    },

    removeAll(destroyChild) {
        for (var key in this.sizerChildren) {
            this.remove(key, destroyChild);
        }
        return this;
    },

    clear(destroyChild) {
        for (var key in this.sizerChildren) {
            delete this.sizerChildren[key];
            if (this.childrenMap.hasOwnProperty(key)) {
                delete this.childrenMap[key];
            }
        }
        ClearChildren.call(this, destroyChild);
        return this;
    }
};

var methods$4 = {
    getChildrenWidth: GetChildrenWidth$1,
    getChildrenHeight: GetChildrenHeight$1,
    getExpandedChildWidth: GetExpandedChildWidth$1,
    getExpandedChildHeight: GetExpandedChildHeight$1,
    getChildrenSizers: GetChildrenSizers$1,
    layoutChildren: LayoutChildren$1,
};

Object.assign(
    methods$4,
    AddChildMethods$1,
    RemoveChildMethods
);

var IndexOf = function (obj, child) {
    if (Array.isArray(obj)) {
        return obj.indexOf(child);
    } else {
        for (var key in obj) {
            if (obj[key] === child) {
                return key;
            }
        }
        return null;
    }
};

const IsPlainObject$c = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1g = Phaser.Utils.Objects.GetValue;

class OverlapSizer extends Base$2 {
    constructor(scene, x, y, minWidth, minHeight, config) {
        if (IsPlainObject$c(x)) {
            config = x;
            x = GetValue$1g(config, 'x', 0);
            y = GetValue$1g(config, 'y', 0);
            minWidth = GetValue$1g(config, 'width', undefined);
            minHeight = GetValue$1g(config, 'height', undefined);
        } else if (IsPlainObject$c(minWidth)) {
            config = minWidth;
            minWidth = GetValue$1g(config, 'width', undefined);
            minHeight = GetValue$1g(config, 'height', undefined);
        }

        super(scene, x, y, minWidth, minHeight, config);

        this.type = 'rexOverlapSizer';
        this.sizerChildren = {};

        this.addChildrenMap('items', this.sizerChildren);
    }

    childToKey(gameObject) {
        if (typeof (gameObject) === 'string') {
            var key = gameObject;
            if (this.sizerChildren.hasOwnPropery(key)) {
                return key;
            }
        } else {
            return IndexOf(this.sizerChildren, gameObject);
        }
        return null;
    }
}

Object.assign(
    OverlapSizer.prototype,
    methods$4
);

var GetDistance = Phaser.Math.Distance.Between;

var IsLocalPointInKnob = function (knob, localX, localY) {
    var centerX = knob.width / 2;
    return GetDistance(centerX, centerX, localX, localY) <= centerX;
};

const GetAngle = Phaser.Math.Angle.Between;
const NormalizeAngle = Phaser.Math.Angle.Normalize;

var OnTouchPad = function (pointer, localX, localY) {
    if (!this.enable) {
        return;
    }
    if (!pointer.isDown) {
        return;
    }
    var knob = this.sizerChildren.knob;
    if (!IsLocalPointInKnob(knob, localX, localY)) {
        return;
    }

    var centerX = knob.width / 2;
    var startAngle = knob.startAngle;
    var endAngle = GetAngle(centerX, centerX, localX, localY);
    var deltaAngle = (knob.anticlockwise) ? (startAngle - endAngle) : (endAngle - startAngle);
    var value = NormalizeAngle(deltaAngle) / (2 * Math.PI);

    this.stopEaseValue();
    if ((this.easeValueDuration === 0) || (Math.abs(this.value - value) < 0.1)) {
        this.value = value;
    } else {
        this.easeValueTo(value);
    }
};

var InstallEvents = function () {
    var knob = this.sizerChildren.knob;
    knob.setInteractive()
        .on('pointerdown', OnTouchPad, this)
        .on('pointermove', OnTouchPad, this);
};

const GetAngle$1 = Phaser.Math.Angle.Between;
const WrapAngle = Phaser.Math.Angle.Wrap;

var OnPointerDown = function (pointer, localX, localY) {
    if ((!this.enable) || (this.panPointer)) {
        return;
    }
    var knob = this.sizerChildren.knob;
    if (!IsLocalPointInKnob(knob, localX, localY)) {
        return;
    }

    OnPanStart.call(this, pointer);
};

var OnPointerMove = function (pointer, localX, localY) {
    if (!this.enable) {
        return;
    }
    if (!pointer.isDown) {
        return;
    }

    var knob = this.sizerChildren.knob;
    switch (this.panState) {
        case TOUCH0:
            if (IsLocalPointInKnob(knob, localX, localY)) {
                OnPanStart.call(this, pointer);
            }
            break;

        case TOUCH1:
            if (IsLocalPointInKnob(knob, localX, localY)) {
                OnPan.call(this);
            } else {
                OnPanEnd.call(this);
            }
            break;
    }
};

var OnPointerUp = function (pointer, localX, localY) {
    if ((!this.enable) || (this.panPointer !== pointer)) {
        return;
    }

    OnPanEnd.call(this);
};

var OnPanStart = function (pointer) {
    this.panPointer = pointer;
    this.panState = TOUCH1;
};

var OnPanEnd = function () {
    this.panPointer = undefined;
    this.panState = TOUCH0;
};

var OnPan = function () {
    var p0 = this.panPointer.prevPosition,
        p1 = this.panPointer.position;
    var knob = this.sizerChildren.knob;
    var startAngle = GetAngle$1(knob.x, knob.y, p0.x, p0.y),
        endAngle = GetAngle$1(knob.x, knob.y, p1.x, p1.y);
    var deltaAngle = (knob.anticlockwise) ? (startAngle - endAngle) : (endAngle - startAngle);
    var deltaValue = WrapAngle(deltaAngle) / (Math.PI * 2);

    this.stopEaseValue();
    this.value += deltaValue;
};

const TOUCH0 = 0;
const TOUCH1 = 1;

var InstallEvents$1 = function () {
    var knob = this.sizerChildren.knob;
    knob.setInteractive()
        .on('pointerdown', OnPointerDown, this)
        .on('pointermove', OnPointerMove, this)
        .on('pointerup', OnPointerUp, this);

    this.panPointer = undefined;
    this.panState = TOUCH0;
};

var SetTextFormatCallback = function (callback, scope) {
    this.textFormatCallback = callback;
    this.textFormatCallbackScope = scope;
    return this;
};

var GetFormatText = function (value) {
    if (value === undefined) {
        value = this.value;
    }

    var text;
    if (this.textFormatCallbackScope) {
        text = this.textFormatCallback(value);
    } else {
        text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
    }
    return text;
};

var UpdateText = function () {
    var textObject = this.sizerChildren.text;
    if (textObject) {
        textObject.setText(GetFormatText.call(this));
        if (textObject.layout) {
            textObject.layout();
        }
    }
    return this;
};

var TextObjectMethods = {
    setTextFormatCallback: SetTextFormatCallback,
    getFormatText: GetFormatText,
    updateText: UpdateText
};

const GetValue$1h = Phaser.Utils.Objects.GetValue;
const Linear$8 = Phaser.Math.Linear;
const Percent$3 = Phaser.Math.Percent;
const SnapTo = Phaser.Math.Snap.To;

class Knob extends OverlapSizer {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        // Create sizer
        super(scene, config);
        this.type = 'rexKnob';
        this.eventEmitter = GetValue$1h(config, 'eventEmitter', this);

        // Add elements
        var background = GetValue$1h(config, 'background', undefined);
        var textObject = GetValue$1h(config, 'text', undefined);

        if (background) {
            this.addBackground(background);
        }
        // Get text object
        if (textObject) {
            // Don't draw text on knob directly
            config.textColor = undefined;
            config.textStrokeColor = undefined;
            this.setTextFormatCallback(
                GetValue$1h(config, 'textFormatCallback', undefined),
                GetValue$1h(config, 'textFormatCallbackScope', undefined)
            );
        }
        // Create circular progress object
        var knob = new CircularProgress$1(scene, config);
        knob.setDepth(GetValue$1h(config, 'knobDepth', 0));
        knob._value = -1; // To trigger text updating
        scene.add.existing(knob);

        this.add(knob, 'knob');
        if (textObject) {
            this.add(textObject, 'text', 'center', 0, false);
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('knob', knob);
        this.addChildrenMap('text', textObject);

        var callback = GetValue$1h(config, 'valuechangeCallback', null);
        if (callback !== null) {
            var scope = GetValue$1h(config, 'valuechangeCallbackScope', undefined);
            this.eventEmitter.on('valuechange', callback, scope);
        }
        this.setEnable(GetValue$1h(config, 'enable', undefined));

        this
            .setEaseValuePropName('value')
            .setEaseValueDuration(GetValue$1h(config, 'easeValue.duration', 0))
            .setEaseValueFunction(GetValue$1h(config, 'easeValue.ease', 'Linear'));

        this.setGap(GetValue$1h(config, 'gap', undefined));
        this.setValue(GetValue$1h(config, 'value', 0), GetValue$1h(config, 'min', undefined), GetValue$1h(config, 'max', undefined));

        // Input
        var inputMode = GetValue$1h(config, 'input', 0);
        if (typeof (inputMode) === 'string') {
            inputMode = INPUTMODE[inputMode];
        }
        switch (inputMode) {
            case 0: // 'pan'
                InstallEvents$1.call(this);
                break;
            case 1: // 'click'
                InstallEvents.call(this);
                break;
        }
    }

    setEnable(enable) {
        if (enable === undefined) {
            enable = true;
        }
        this.enable = enable;
        return this;
    }

    setGap(gap) {
        this.gap = gap;
        return this;
    }

    get value() {
        return this.sizerChildren.knob.value;
    }

    set value(value) {
        if (this.gap !== undefined) {
            value = SnapTo(value, this.gap);
        }
        var oldValue = this.value;
        this.sizerChildren.knob.value = value;

        var newValue = this.value;
        if (oldValue !== newValue) {
            this.updateText();
            this.eventEmitter.emit('valuechange', newValue, oldValue, this.eventEmitter);
        }
    }

    setValue(value, min, max) {
        if ((value === undefined) || (value === null)) {
            return this;
        }

        if (min !== undefined) {
            value = Percent$3(value, min, max);
        }
        this.value = value;
        return this;
    }

    addValue(inc, min, max) {
        if (min !== undefined) {
            inc = Percent$3(inc, min, max);
        }
        this.value += inc;
        return this;
    }

    getValue(min, max) {
        var value = this.value;
        if (min !== undefined) {
            value = Linear$8(min, max, value);
        }
        return value;
    }
}

const INPUTMODE = {
    pan: 0,
    drag: 0,
    click: 1,
    none: -1,
};

Object.assign(
    Knob.prototype,
    TextObjectMethods,
    EaseValueMethods
);

const ShapeClasses = {
    arc: Arc,
    circle: Circle,
    curve: Curve,
    ellipse: Ellipse,
    line: Line,
    lines: Lines,
    rectangle: Rectangle$1,
    triangle: Triangle
};

const GetValue$1i = Phaser.Utils.Objects.GetValue;
const IsPlainObject$d = Phaser.Utils.Objects.IsPlainObject;

const ClearAll = function () {
    var shapes = this.getShapes();
    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
        shapes[i].lineStyle().fillStyle();
    }
};

var ShapesUpdateMethods = {
    createShape(shapeType, name) {
        var ShapeClass = ShapeClasses[shapeType];
        var shape = new ShapeClass();
        if (name) {
            shape.setName(name);
        }
        return shape;
    },

    buildShapes(config) {
        var createCallback = GetValue$1i(config, 'create', undefined);

        if (IsPlainObject$d(createCallback)) {
            var shapes = createCallback;
            for (var shapeType in shapes) {
                var name = shapes[shapeType];
                switch (typeof (name)) {
                    case 'number':
                        for (var i = 0; i < name; i++) {
                            this.addShape(this.createShape(shapeType));
                        }
                        break;

                    case 'string':
                        this.addShape(this.createShape(shapeType, name));
                        break;

                    default: //Array
                        var names = name;
                        for (var i = 0, cnt = names.length; i < cnt; i++) {
                            this.addShape(this.createShape(shapeType, names[i]));
                        }
                        break;
                }
            }
        } else if (Array.isArray(createCallback)) {
            var shapes = createCallback;
            for (var i = 0, cnt = shapes.length; i < cnt; i++) {
                var shape = shapes[i];
                this.addShape(this.createShape(shape.type, shape.name));
            }

        } else if (typeof (createCallback) === 'function') {
            createCallback.call(this);

        }

        this.setUpdateShapesCallback(GetValue$1i(config, 'update'));
    },

    setUpdateShapesCallback(callback) {
        if (callback === undefined) {
            callback = ClearAll;
        }
        this.dirty = this.dirty || (this.updateCallback !== callback);
        this.updateCallback = callback;
        return this;
    },

    updateShapes() {
        this.updateCallback.call(this);
    }
};

const GetValue$1j = Phaser.Utils.Objects.GetValue;
const IsPlainObject$e = Phaser.Utils.Objects.IsPlainObject;

class CustomShapes extends BaseShapes {
    constructor(scene, x, y, width, height, config) {
        if (IsPlainObject$e(x)) {
            config = x;
            x = GetValue$1j(config, 'x', 0);
            y = GetValue$1j(config, 'y', 0);
            width = GetValue$1j(config, 'width', 2);
            height = GetValue$1j(config, 'height', 2);
        }
        super(scene, x, y, width, height);
        this.type = GetValue$1j(config, 'type', 'rexCustomShapes');
        this.buildShapes(config);
    }
}

Object.assign(
    CustomShapes.prototype,
    ShapesUpdateMethods
);

const GetValue$1k = Phaser.Utils.Objects.GetValue;
const IsPlainObject$f = Phaser.Utils.Objects.IsPlainObject;
const Clamp$4 = Phaser.Math.Clamp;
const Linear$9 = Phaser.Math.Linear;
const Percent$4 = Phaser.Math.Percent;

class CustomProgress extends CustomShapes {
    constructor(scene, x, y, width, height, config) {
        if (IsPlainObject$f(x)) {
            config = x;
            x = GetValue$1k(config, 'x', 0);
            y = GetValue$1k(config, 'y', 0);
            width = GetValue$1k(config, 'width', 2);
            height = GetValue$1k(config, 'height', 2);
        }
        if (config === undefined) {
            config = {};
        }
        if (!config.type) {
            config.type = 'rexCustomProgress';
        }
        super(scene, x, y, width, height, config);
        this.eventEmitter = GetValue$1k(config, 'eventEmitter', this);

        var callback = GetValue$1k(config, 'valuechangeCallback', null);
        if (callback !== null) {
            var scope = GetValue$1k(config, 'valuechangeCallbackScope', undefined);
            this.eventEmitter.on('valuechange', callback, scope);
        }

        this
            .setEaseValuePropName('value')
            .setEaseValueDuration(GetValue$1k(config, 'easeValue.duration', 0))
            .setEaseValueFunction(GetValue$1k(config, 'easeValue.ease', 'Linear'));

        this.setValue(GetValue$1k(config, 'value', 0));
    }

    get centerX() {
        return this.width / 2;    }

    get centerY() {
        return this.height / 2;
    }

    get radius() {
        return Math.min(this.centerX, this.centerY);
    }

    get value() {
        return this._value;
    }

    set value(value) {
        value = Clamp$4(value, 0, 1);

        var oldValue = this._value;
        var valueChanged = (oldValue != value);
        this.dirty = this.dirty || valueChanged;
        this._value = value;

        if (valueChanged) {
            this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
    }

    setValue(value, min, max) {
        if ((value === undefined) || (value === null)) {
            return this;
        }

        if (min !== undefined) {
            value = Percent$4(value, min, max);
        }
        this.value = value;
        return this;
    }

    addValue(inc, min, max) {
        if (min !== undefined) {
            inc = Percent$4(inc, min, max);
        }
        this.value += inc;
        return this;
    }

    getValue(min, max) {
        var value = this.value;
        if (min !== undefined) {
            value = Linear$9(min, max, value);
        }
        return value;
    }

}

Object.assign(
    CustomProgress.prototype,
    EaseValueMethods
);

var SetTransitionCallbackMethods = {
    setTransitionStartCallback(callback, scope) {
        this.onStartCallback = callback;
        this.onStartCallbackScope = scope;
        return this;
    },

    setTransitionProgressCallback(callback, scope) {
        this.onProgressCallback = callback;
        this.onProgressCallbackScope = scope;
        return this;
    },

    setTransitionCompleteCallback(callback, scope) {
        this.onCompleteCallback = callback;
        this.onCompleteCallbackScope = scope;
        return this;
    },
};

const IsPlainObject$g = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1l = Phaser.Utils.Objects.GetValue;

var DirMode = {
    out: 0,
    in: 1
};

var TransitionMethods = {
    setTransitionDirection(dir) {
        if (typeof (dir) === 'string') {
            dir = DirMode[dir];
        }
        this.dir = dir;
        return this;
    },

    setDuration(duration) {
        this.duration = duration;
        return this;
    },

    setEaseFunction(ease) {
        this.easeFunction = ease;
        return this;
    },

    setNextTexture(texture, frame) {
        this.nextImage.setTexture(texture, frame);
        return this;
    },

    transit(texture, frame) {        
        if (this.isRunning) {
            this.ignoreCompleteEvent = true;
            this.stop();
            this.ignoreCompleteEvent = false;
        }

        if (IsPlainObject$g(texture)) {
            var config = texture;
            texture = GetValue$1l(config, 'key', undefined);
            frame = GetValue$1l(config, 'frame', undefined);

            this
                .setDuration(GetValue$1l(config, 'duration', this.duration))
                .setEaseFunction(GetValue$1l(config, 'ease', this.easeFunction))
                .setTransitionDirection(GetValue$1l(config, 'dir', this.dir));

            var maskGameObject = GetValue$1l(config, 'mask', undefined);
            if (maskGameObject) {
                this.setMaskGameObject(maskGameObject);
            }
            this.setMaskEnable(maskGameObject === true);

            var onStart = GetValue$1l(config, 'onStart', undefined);
            var onProgress = GetValue$1l(config, 'onProgress', undefined);
            var onComplete = GetValue$1l(config, 'onComplete', undefined);
            if ((onStart !== undefined) || (onProgress !== undefined) || (onComplete !== undefined)) {
                this
                    .setTransitionStartCallback(
                        onStart,
                        GetValue$1l(config, 'onStartScope', undefined)
                    )
                    .setTransitionProgressCallback(
                        onProgress,
                        GetValue$1l(config, 'onProgressScope', undefined)
                    )
                    .setTransitionCompleteCallback(
                        onComplete,
                        GetValue$1l(config, 'onCompleteScope', undefined)
                    );
            }
        }

        this.setNextTexture(texture, frame);

        this.start();
        return this;
    },

    start() {
        if (this.easeValueTask === undefined) {
            this.easeValueTask = new EaseValueTask(this, { eventEmitter: null });
        }
        this.easeValueTask.restart({
            key: 't', from: 0, to: 1,
            duration: this.duration,
            ease: this.easeFunction
        });
        return this;
    },

    pause() {
        if (this.easeValueTask) {
            this.easeValueTask.pause();
        }
        return this;
    },

    resume() {
        if (this.easeValueTask) {
            this.easeValueTask.resume();
        }
        return this;
    },

    stop() {
        if (this.easeValueTask) {
            this.easeValueTask.stop();
        }
        this.setT(1);
        return this;
    },
};

var DrawShape = function (width, height, padding, originX, originY) {
    this.clear().fillStyle(0xffffff);
    switch (this.shape) {
        case 1: // circle
            var radius = Math.min(width, height) / 2;
            this.fillCircle(
                -width * (originX - 0.5),
                -height * (originY - 0.5),
                radius + padding
            );
            break;
        default: // 0|'rectangle'
            this.fillRect(
                -(width * originX) - padding,
                -(height * originY) - padding,
                width + (2 * padding),
                height + (2 * padding)
            );
            break;
    }
};

const Graphics = Phaser.GameObjects.Graphics;

class DefaultMaskGraphics extends Graphics {
    constructor(parent, shape, padding) {
        if (shape === undefined) {
            shape = 0;
        }
        if (typeof (shape) === 'string') {
            shape = SHAPEMODE[shape];
        }
        if (padding === undefined) {
            padding = 0;
        }

        super(parent.scene);
        this.parent = parent;
        this.shape = shape;
        this.padding = padding;
        this.setPosition().resize().setVisible(false);
        // Don't add it to display list
    }

    destroy() {
        this.parent = undefined;
        super.destroy();
        return this;
    }

    setPosition(x, y) {
        var parent = this.parent;
        if (x === undefined) {
            x = parent.x;
        }
        if (y === undefined) {
            y = parent.y;
        }
        super.setPosition(x, y);
        return this;
    }

    resize(width, height, padding) {
        var parent = this.parent;
        if (width === undefined) {
            width = parent.width;
        }
        if (height === undefined) {
            height = parent.height;
        }
        if (padding === undefined) {
            padding = this.padding;
        }
        if ((this.widthSave === width) && (this.heightSave === height) && (this.paddingSave === padding)) {
            return this;
        }

        this.widthSave = width;
        this.heightSave = height;
        this.paddingSave = padding;
        this.originXSave = parent.originX;
        this.originYSave = parent.originY;

        DrawShape.call(this,
            width, height, padding,
            parent.originX, parent.originY
        );

        return this;
    }

    setOrigin(originX, originY) {
        if (originY === undefined) {
            originY = originX;
        }

        var parent = this.parent;
        if (originX === undefined) {
            originX = parent.originX;
        }
        if (originY === undefined) {
            originY = parent.originY;
        }
        if ((this.originXSave === originX) && (this.originYSave === originY)) {
            return this;
        }

        this.originXSave = originX;
        this.originYSave = originY;

        DrawShape.call(this,
            this.widthSave, this.heightSave, this.paddingSave,
            originX, originY,
        );
        return this;
    }
}

const SHAPEMODE = {
    rectangle: 0,
    circle: 1,
};

var MaskMethods = {
    setMaskGameObject(gameObject) {
        if (!gameObject) {
            this.removeMaskGameObject();
            return this;
        }

        if (this.maskGameObject) {
            if ((gameObject === true) && (this.maskGameObject instanceof DefaultMaskGraphics)) {
                return this;
            }
            if (this.maskGameObject === gameObject) {
                return this;
            }

            // Remove previous Mask Game Object
            this.removeMaskGameObject();
        }

        // Add new Mask Game Object
        if (gameObject === true) {
            gameObject = new DefaultMaskGraphics(this);
        }

        this.maskGameObject = gameObject;
        this.maskGameObject
            .resize(this.width, this.height)
            .setOrigin(this.originX, this.originY)
            .setPosition(0, 0)
            .setScale(1)
            .setVisible(false);
        this.addLocal(this.maskGameObject);

        this.childrenMask = this.maskGameObject.createGeometryMask();
        return this;
    },

    removeMaskGameObject() {
        this.backImage.clearMask();
        this.frontImage.clearMask();
        this.childrenMask = undefined;
        this.remove(this.maskGameObject, true);
        this.maskGameObject = undefined;
        return this;
    },

    setImageMaskEnable(gameObject, enable, invertAlpha) {
        if (enable === undefined) {
            enable = true;
        }

        // Use DefaultMaskGraphics if not given
        if (!this.childrenMask) {
            this.setMaskGameObject(true);
        }

        if (enable) {
            gameObject.setMask(this.childrenMask);
            if (invertAlpha) {
                this.childrenMask.setInvertAlpha();
            }
        } else {
            gameObject.clearMask();
        }

        return this;
    },

    setCurrentImageMaskEnable(enable, invertAlpha) {
        this.setImageMaskEnable(this.currentImage, enable, invertAlpha);
        return this;
    },

    setNextImageMaskEnable(enable, invertAlpha) {
        this.setImageMaskEnable(this.nextImage, enable, invertAlpha);
        return this;
    },

    setCellImagesMaskEnable(enable, invertAlpha) {
        var cellImages = this.getCellImages();
        for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
            this.setImageMaskEnable(cellImages[i], enable, invertAlpha);
        }
        return this;
    },

    setMaskEnable(enable, invertAlpha) {
        this.setImageMaskEnable(this.backImage, enable, invertAlpha);
        this.setImageMaskEnable(this.frontImage, enable, invertAlpha);
        this.setCellImagesMaskEnable(enable, invertAlpha);
        return this;
    }
};

var GetFrameNameCallback$1 = function (baseFrameName, delimiter) {
    if (delimiter === undefined) {
        delimiter = ',';
    }

    var callback;
    if (baseFrameName === '__BASE') {
        callback = function (colIndex, rowIndex) {
            return `${colIndex}${delimiter}${rowIndex}`;
        };
    } else {
        callback = function (colIndex, rowIndex) {
            return `${baseFrameName}_${colIndex}${delimiter}${rowIndex}`;
        };
    }

    return callback;
};

var GridCut = function (scene, key, frame, columns, rows, getFrameNameCallback) {
    if (frame == null) {
        frame = '__BASE';
    }
    if (!IsFunction(getFrameNameCallback)) {
        getFrameNameCallback = GetFrameNameCallback$1(frame, getFrameNameCallback);
    }

    var texture = scene.textures.get(key);
    var baseFrame = texture.frames[frame];
    var cellWidth = baseFrame.width / columns,
        cellHeight = baseFrame.height / rows;
    var offsetX = 0,
        offsetY = 0;
    var frameName;
    for (var y = 0; y < rows; y++) {
        offsetX = 0;
        for (var x = 0; x < columns; x++) {
            frameName = getFrameNameCallback(x, y);
            texture.add(
                frameName, 0,
                (offsetX + baseFrame.cutX), (offsetY + baseFrame.cutY),
                cellWidth, cellHeight
            );
            offsetX += cellWidth;
        }
        offsetY += cellHeight;
    }

    return {
        getFrameNameCallback: getFrameNameCallback,
        cellWidth: cellWidth,
        cellHeight: cellHeight,
        columns: columns,
        rows: rows
    }
};

const GetValue$1m = Phaser.Utils.Objects.GetValue;
const DefaultImageClass = Phaser.GameObjects.Image;
const IsPlainObject$h = Phaser.Utils.Objects.IsPlainObject;
const RotateAround$3 = Phaser.Math.RotateAround;

var GridCutImage = function (gameObject, columns, rows, config) {
    if (IsPlainObject$h(columns)) {
        config = columns;
        columns = GetValue$1m(config, 'columns', 1);
        rows = GetValue$1m(config, 'rows', 1);
    }
    var ImageClass = GetValue$1m(config, 'ImageClass', DefaultImageClass);
    var originX = GetValue$1m(config, 'originX', 0.5);
    var originY = GetValue$1m(config, 'originY', 0.5);
    var addToScene = GetValue$1m(config, 'add', true);
    var align = GetValue$1m(config, 'align', addToScene);
    var imageObjectPool = GetValue$1m(config, 'objectPool', undefined);

    var scene = gameObject.scene;
    var key = gameObject.texture.key;
    var frame = gameObject.frame.name;

    var result = GridCut(scene, key, frame, columns, rows);
    var getFrameNameCallback = result.getFrameNameCallback;
    var scaleX = gameObject.scaleX,
        scaleY = gameObject.scaleY;
    var rotation = gameObject.rotation;
    var topLeft = gameObject.getTopLeft(),
        startX = topLeft.x,
        startY = topLeft.y;

    var cellGameObjects = [];
    var cellWidth = result.cellWidth * scaleX,
        cellHeight = result.cellHeight * scaleY;
    for (var y = 0; y < rows; y++) {
        for (var x = 0; x < columns; x++) {
            var cellGameObject;

            var frameName = getFrameNameCallback(x, y);
            if (imageObjectPool && (imageObjectPool.length > 0)) {
                cellGameObject = (imageObjectPool.pop()).setTexture(key, frameName);
            } else {
                cellGameObject = new ImageClass(scene, 0, 0, key, frameName);
            }

            if (addToScene) {
                scene.add.existing(cellGameObject);
            }

            var cellTLX = startX + (cellWidth * x);
            var cellTLY = startY + (cellHeight * y);
            var cellX = cellTLX + (originX * cellWidth);
            var cellY = cellTLY + (originY * cellHeight);

            if (align) {
                cellGameObject
                    .setOrigin(originX, originY)
                    .setPosition(cellX, cellY)
                    .setScale(scaleX, scaleY)
                    .setRotation(rotation);
                RotateAround$3(cellGameObject, startX, startY, rotation);
            }

            cellGameObjects.push(cellGameObject);
        }
    }

    return cellGameObjects;
};

var GridCutMethods = {
    gridCutImage(gameObject, columns, rows, config) {
        if (config === undefined) {
            config = {};
        }
        config.objectPool = this.imagesPool;
        var cellImages = GridCutImage(gameObject, columns, rows, config),
            cellImage;
        for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
            cellImage = cellImages[i];
            cellImage.setVisible(true);
            this.add(cellImage);
        }

        this.cellImages = cellImages;
        this.setChildLocalVisible(gameObject, false);  // Set cut target to invisible
        return cellImages;
    },

    gridCutCurrentImage(columns, rows, config) {
        return this.gridCutImage(this.currentImage, columns, rows, config);
    },

    gridCutNextImage(columns, rows, config) {
        return this.gridCutImage(this.nextImage, columns, rows, config);
    },

    getCellImages() {
        return this.cellImages;
    },

    freeCellImages() {
        if (this.cellImages.length === 0) {
            return this;
        }

        var texture = this.cellImages[0].texture;
        var cellImages = this.cellImages,
            cellImage, frameName;
        for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
            cellImage = cellImages[i];

            // Reset property of cell image
            this
                .setChildLocalAlpha(cellImage, 1)
                .setChildLocalScale(cellImage, 1)
                .setChildLocalVisible(cellImage, false);

            cellImage.clearMask();

            // Remove frame object
            frameName = cellImage.frame.name;
            cellImage.setTexture();
            texture.remove(frameName);
        }

        this.imagesPool.push(...cellImages);
        cellImages.length = 0;

        return this;
    }
};

var methods$5 = {
};

Object.assign(
    methods$5,
    SetTransitionCallbackMethods,
    TransitionMethods,
    MaskMethods,
    GridCutMethods
);

var OnStart = function (parent, currentImage, nextImage, t) {
};

var OnProgress = function (parent, currentImage, nextImage, t) {
    parent
        .setChildLocalAlpha(currentImage, 1 - t)
        .setChildLocalAlpha(nextImage, t);
};

var OnComplete = function (parent, currentImage, nextImage, t) {
    parent.setChildLocalAlpha(currentImage, 1);
};

const IsPlainObject$i = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1n = Phaser.Utils.Objects.GetValue;
const Clamp$5 = Phaser.Math.Clamp;

class TransitionImage extends ContainerLite {
    constructor(scene, x, y, texture, frame, config) {
        if (IsPlainObject$i(x)) {
            config = x;
            x = GetValue$1n(config, 'x', 0);
            y = GetValue$1n(config, 'y', 0);
            texture = GetValue$1n(config, 'key', undefined);
            frame = GetValue$1n(config, 'frame', undefined);
        } else if (IsPlainObject$i(frame)) {
            config = frame;
            frame = undefined;
        }

        var backImage = GetValue$1n(config, 'back', undefined);
        var frontImage = GetValue$1n(config, 'front', undefined);
        if (!backImage) {
            backImage = scene.add.image(x, y, texture, frame);
        }
        if (!frontImage) {
            frontImage = scene.add.image(x, y, texture, frame);
        }
        var width = GetValue$1n(config, 'width', frontImage.width);
        var height = GetValue$1n(config, 'height', frontImage.height);

        super(scene, x, y, width, height);

        backImage.setVisible(false);
        this.addMultiple([backImage, frontImage]);

        this.type = 'rexTransitionImage';
        this.backImage = backImage;
        this.frontImage = frontImage;
        this.maskGameObject = undefined;
        this.cellImages = [];
        this.imagesPool = [];

        // Transition parameters
        var onStart = GetValue$1n(config, 'onStart', undefined);
        var onProgress = GetValue$1n(config, 'onProgress', undefined);
        var onComplete = GetValue$1n(config, 'onComplete', undefined);
        var dir = GetValue$1n(config, 'dir', 0);
        if ((onStart === undefined) && (onProgress === undefined) && (onComplete === undefined)) {
            onStart = OnStart;
            onProgress = OnProgress;
            onComplete = OnComplete;
            dir = 0;
        }

        this
            .setTransitionStartCallback(
                onStart,
                GetValue$1n(config, 'onStartScope', undefined)
            )
            .setTransitionProgressCallback(
                onProgress,
                GetValue$1n(config, 'onProgressScope', undefined)
            )
            .setTransitionCompleteCallback(
                onComplete,
                GetValue$1n(config, 'onCompleteScope', undefined)
            )
            .setTransitionDirection(dir)
            .setDuration(GetValue$1n(config, 'duration', 1000))
            .setEaseFunction(GetValue$1n(config, 'ease', 'Linear'));

        var maskGameObject = GetValue$1n(config, 'mask', undefined);
        if (maskGameObject) {
            this.setMaskGameObject(maskGameObject);
        }
        this.setMaskEnable(false);

        this.ignoreCompleteEvent = false;
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        if (this.childrenMask) {
            this.childrenMask.destroy();
            this.childrenMask = undefined;
        }
        this.backImage = undefined;
        this.frontImage = undefined;
        this.maskGameObject = undefined;
        this.cellImages.length = 0;
        this.imagesPool.length = 0;

        super.destroy(fromScene);

        this.onStartCallback = undefined;
        this.onStartCallbackScope = undefined;
        this.onProgressCallback = undefined;
        this.onProgressCallbackScope = undefined;
        this.onCompleteCallback = undefined;
        this.onCompleteCallbackScope = undefined;
        this.easeValueTask = undefined;
    }

    get currentImage() {
        return (this.dir === 0) ? this.frontImage : this.backImage;
    }

    get nextImage() {
        return (this.dir === 0) ? this.backImage : this.frontImage;
    }

    get texture() {
        return this.nextImage.texture;
    }

    get frame() {
        return this.nextImage.frame;
    }

    get t() {
        return this._t;
    }

    set t(value) {
        value = Clamp$5(value, 0, 1);
        if (this._t === value) {
            return;
        }
        this._t = value;

        var currentImage = this.currentImage;
        var nextImage = this.nextImage;

        // Start
        if (value === 0) {
            this
                .setChildVisible(this.frontImage, true)
                .setChildVisible(this.backImage, true);

            RunCallback(
                this.onStartCallback, this.onStartCallbackScope,
                this, currentImage, nextImage, value
            );
        }

        // Progress
        RunCallback(
            this.onProgressCallback, this.onProgressCallbackScope,
            this, currentImage, nextImage, value
        );

        // Complete
        if (value === 1) {
            RunCallback(
                this.onCompleteCallback, this.onCompleteCallbackScope,
                this, currentImage, nextImage, value
            );

            var key = nextImage.texture.key,
                frame = nextImage.frame.name;
            this.frontImage.setTexture(key, frame);
            this.backImage.setTexture(key, frame);

            this
                .setChildVisible(this.frontImage, true)
                .setChildVisible(this.backImage, false)
                .setMaskEnable(false)
                .freeCellImages();
        }

        if ((value === 1) && (!this.ignoreCompleteEvent)) {
            this.emit('complete');
        }
    }

    setT(value) {
        this.t = value;
        return this;
    }

    get isRunning() {
        return (this.easeValueTask) ? this.easeValueTask.isRunning : false;
    }

    setOrigin(originX, originY) {
        super.setOrigin(originX, originY);

        this.backImage.setOrigin(originX, originY);
        this.frontImage.setOrigin(originX, originY);

        if (this.maskGameObject) {
            this.maskGameObject.setOrigin(originX, originY);
        }

        return this;
    }

    setTexture(texture, frame) {
        // Without transition
        this.frontImage.setTexture(texture, frame);
        this.backImage.setTexture(texture, frame).setVisible(false);
        return this;
    }
}

var RunCallback = function (callback, scope, parent, currentImage, nextImage, t) {
    if (!callback) {
        return;
    }

    if (scope) {
        callback.call(scope, parent, currentImage, nextImage, t);
    } else {
        callback(parent, currentImage, nextImage, t);
    }
};

// mixin
Object.assign(
    TransitionImage.prototype,
    methods$5
);

const Rectangle$3 = Phaser.GameObjects.Rectangle;

class FullWindowRectangle extends Rectangle$3 {
    constructor(scene, color, alpha) {
        super(scene, 0, 0, 2, 2, color, 1);

        this.setAlpha(alpha);
        this.setScrollFactor(0);
        this.boot();
    }

    boot() {
        var scene = this.scene;
        scene.events.on('prerender', this.resize, this);
    }

    destroy(fromScene) {  // preDestroy method does not have fromScene parameter
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        this.scene.events.off('prerender', this.resize, this);

        super.destroy(fromScene);
    }

    get tint() {
        return this.fillColor;
    }

    set tint(value) {
        this.setFillStyle(value, this.fillAlpha);
    }

    resize() {
        var scene = this.scene;
        var gameSize = scene.scale.gameSize;
        var camera = scene.cameras.main;

        var gameWidth = gameSize.width,
            gameHeight = gameSize.height,
            scale = 1 / camera.zoom;

        var x = gameWidth / 2,
            y = gameHeight / 2,
            width = gameWidth * scale,
            height = gameHeight * scale;

        if ((this.x !== x) || (this.y !== y)) {
            this.setPosition(x, y);
        }

        if ((this.width !== width) || (this.height !== height)) {
            this.setSize(width, height).setOrigin(0.5);
        }

    }

}

const GetValue$1o = Phaser.Utils.Objects.GetValue;

class TouchEventStop extends ComponentBase {
    constructor(gameObject, config) {
        super(gameObject, { eventEmitter: false });
        // No event emitter
        // this.parent = gameObject;

        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        this.setHitAreaMode(GetValue$1o(o, 'hitAreaMode', 0));
        this.setEnable(GetValue$1o(o, "enable", true));
        return this;
    }

    boot() {
        this.parent
            .on('pointerdown', function (pointer, localX, localY, event) {
                event.stopPropagation();
            })
            .on('pointerup', function (pointer, localX, localY, event) {
                event.stopPropagation();
            })
            .on('pointermove', function (pointer, localX, localY, event) {
                event.stopPropagation();
            })
            .on('pointerover', function (pointer, localX, localY, event) {
                event.stopPropagation();
            })
            .on('pointerout', function (pointer, event) {
                event.stopPropagation();
            });
    }

    setHitAreaMode(mode) {
        if (typeof (mode) === 'string') {
            mode = HitAreaMode[mode];
        }

        var gameObject = this.parent;
        if (gameObject.input) {
            gameObject.removeInteractive();
        }

        if (mode === 0) {
            gameObject.setInteractive();
        } else {
            gameObject.setInteractive({
                hitArea: {},
                hitAreaCallback: function () { return true; }
            });
        }

        return this;
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }

        if (e) {
            this.parent.setInteractive();
        } else {
            this.parent.disableInteractive();
        }

        this.enable = e;
        return this;
    }

    toggleEnable() {
        this.setEnable(!this.enable);
        return this;
    }
}

var HitAreaMode = {
    default: 0,
    fullWindow: 1
};

const GetValue$1p = Phaser.Utils.Objects.GetValue;

class Cover extends FullWindowRectangle {
    constructor(scene, config) {
        var fillColor = GetValue$1p(config, 'color', 0x0);
        var fillAlpha = GetValue$1p(config, 'alpha', 0.8);
        super(scene, fillColor, fillAlpha);

        this.touchEventStop = new TouchEventStop(this, { hitAreaMode: 1 });
    }
}

var SetChart = function (config) {
    if (!window.Chart) {
        var msg = `Can not find chartjs! Load chartjs in preload stage.
scene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.min.js');`;
        console.error(msg);
        return this;
    }

    if (this.chart) {
        this.chart.destroy();        
    }
    this.chart = new Chart(this.context, FillConfig(this, config));
    return this;
};

var FillConfig = function (canvas, config) {
    // Get options
    if (config === undefined) {
        config = {};
    }
    if (config.options === undefined) {
        config.options = {};
    }
    var options = config.options;

    // Fill options
    options.responsive = false;
    options.maintainAspectRatio = false;
    if (!options.hasOwnProperty('devicePixelRatio')) {
        options.devicePixelRatio = 1;
    }

    // Get animation config
    var noAnimation = false;
    if (options.animation === undefined) {
        options.animation = {};
    } else if (options.animation === false) {
        noAnimation = true;
        options.animation = {};
    }
    var animationConfig = options.animation;

    // Fill animation config
    if (noAnimation) {
        animationConfig.duration = 0;
    }

    var onProgress = animationConfig.onProgress;
    animationConfig.onProgress = function (animation) {
        if (onProgress) {
            onProgress(animation);
        }
        canvas.needRedraw();
    };

    var onComplete = animationConfig.onComplete;
    animationConfig.onComplete = function (animation) {
        if (onComplete) {
            onComplete(animation);
        }
        canvas.needRedraw();
    };
    return config;
};

var GetChartDataset = function (datasetIndex) {
    if (this.chart === undefined) {
        return undefined;
    }

    if (typeof (datasetIndex) === 'string') {
        var datasets = this.chart.data.datasets, dataset;
        for (var i = 0, cnt = datasets.length; i < cnt; i++) {
            dataset = datasets[i];
            if (dataset.label === datasetIndex) {
                return dataset;
            }
        }
    } else {
        return this.chart.data.datasets[datasetIndex];
    }

    return undefined;
};

var GetChartData = function (datasetIndex, dataIndex) {
    var dataset = this.getChartDataset(datasetIndex);
    if (dataset === undefined) {
        return undefined;
    }
    if (typeof (dataIndex) === 'string') {
        var labels = this.chart.data.labels;
        dataIndex = labels.indexOf(dataIndex);
        if (dataIndex === -1) {
            return undefined;
        }
    }
    return dataset.data[dataIndex];
};

var SetChartData = function (datasetIndex, dataIndex, value) {
    if (this.chart === undefined) {
        return this;
    }

    var dataset = this.getChartDataset(datasetIndex);
    if (typeof (dataIndex) === 'string') {
        var labels = this.chart.data.labels;
        dataIndex = labels.indexOf(dataIndex);
        if (dataIndex === -1) {
            return this;
        }
    }
    dataset.data[dataIndex] = value;
    return this;
};

var UpdateChart = function () {
    if (this.chart === undefined) {
        return this;
    }
    this.chart.update();
};

// This plugin does not contain chart.js
// Load chart.js in preload stage -
// scene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.min.js');

class Chart$1 extends Canvas {
    constructor(scene, x, y, width, height, config) {
        super(scene, x, y, width, height);
        this.type = 'rexChart';
        this.chart = undefined;

        if (config !== undefined) {
            this.setChart(config);
        }
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }
        if (this.chart) {
            this.chart.destroy();
            this.chart = undefined;
        }
        super.destroy(fromScene);
    }

    resize(width, height) {
        if ((width === this.width) && (height === this.height)) {
            return this;
        }

        super.resize(width, height);

        if (this.chart) {
            var chart = this.chart;
            chart.height = this.canvas.height;
            chart.width = this.canvas.width;
            chart.aspectRatio = (chart.height) ? chart.width / chart.height : null;
            chart.update();
        }
        return this;
    }
}

var methods$6 = {
    setChart: SetChart,
    getChartDataset: GetChartDataset,
    getChartData: GetChartData,
    setChartData: SetChartData,
    updateChart: UpdateChart,
};
Object.assign(
    Chart$1.prototype,
    methods$6
);

var GetChildrenWidth$2 = function (minimumMode) {
    if (this.rexSizer.hidden) {
        return 0;
    }

    if (minimumMode === undefined) {
        minimumMode = true;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childWidth;
    if (this.orientation === 0) { // x
        // Get summation of minimum width
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.rexSizer.hidden) {
                continue;
            }

            if (
                (child.rexSizer.proportion === 0) ||
                (minimumMode && (child.rexSizer.proportion > 0))
            ) {
                childWidth = this.getChildWidth(child);
            } else {
                childWidth = 0;
            }
            padding = child.rexSizer.padding;
            childWidth += (padding.left + padding.right);
            if (i > 0) {
                childWidth += this.space.item;
            }
            result += childWidth;
        }
    } else {
        // Get maximun width
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (!child.hasOwnProperty('rexSizer')) {
                continue;
            }
            if (child.rexSizer.hidden) {
                continue;
            }

            padding = child.rexSizer.padding;
            childWidth = this.getChildWidth(child) + padding.left + padding.right;
            result = Math.max(childWidth, result);
        }
    }
    return result + this.space.left + this.space.right;
};

var GetChildrenHeight$2 = function (minimumMode) {
    if (this.rexSizer.hidden) {
        return 0;
    }

    if (minimumMode === undefined) {
        minimumMode = true;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childHeight;
    if (this.orientation === 0) { // x
        // Get maximun height
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (child.rexSizer.hidden) {
                continue;
            }

            padding = child.rexSizer.padding;
            childHeight = this.getChildHeight(child) + padding.top + padding.bottom;
            result = Math.max(childHeight, result);
        }
    } else {
        // Get summation of minimum height
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = children[i];
            if (!child.hasOwnProperty('rexSizer')) {
                continue;
            }
            if (child.rexSizer.hidden) {
                continue;
            }

            padding = child.rexSizer.padding;
            if (
                (child.rexSizer.proportion === 0) ||
                (minimumMode && (child.rexSizer.proportion > 0))
            ) {
                childHeight = this.getChildHeight(child);
            } else {
                childHeight = 0;
            }
            childHeight += (padding.top + padding.bottom);
            if (i > 0) {
                childHeight += this.space.item;
            }
            result += childHeight;
        }
    }
    return result + this.space.top + this.space.bottom;
};

var GetExpandedChildWidth$2 = function (child, parentWidth) {
    if (parentWidth === undefined) {
        parentWidth = this.width;
    }

    var childWidth;
    var childConfig = child.rexSizer;
    var padding = childConfig.padding;
    if (this.orientation === 0) { // x
        if ((childConfig.proportion > 0) && (this.proportionLength > 0)) {
            childWidth = (childConfig.proportion * this.proportionLength);
        }
    } else { // y
        if (childConfig.expand) {
            var innerWidth = parentWidth - this.space.left - this.space.right;
            childWidth = innerWidth - padding.left - padding.right;
        }
    }
    return childWidth;
};

var GetExpandedChildHeight$2 = function (child, parentHeight) {
    if (parentHeight === undefined) {
        parentHeight = this.height;
    }

    var childHeight;
    var childConfig = child.rexSizer;
    var padding = childConfig.padding;
    if (this.orientation === 0) { // x
        if (childConfig.expand) {
            var innerHeight = parentHeight - this.space.top - this.space.bottom;
            childHeight = innerHeight - padding.top - padding.bottom;
        }
    } else { // y
        if ((childConfig.proportion > 0) && (this.proportionLength > 0)) {
            childHeight = (childConfig.proportion * this.proportionLength);
        }
    }
    return childHeight;
};

var GetChildrenSizers$2 = function(out) {
    if (out === undefined) {
        out = [];
    }
    var children = this.sizerChildren,
        child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.isRexSizer) {
            out.push(child);
        }
    }
    return out;
};

var PreLayout$1 = function () {
    this._childrenProportion = undefined;
    this.proportionLength = undefined;
    PreLayout.call(this);
    return this;
};

var LayoutChildren$2 = function () {
    var children = this.sizerChildren;
    var child, childConfig, padding;
    var startX = this.innerLeft,
        startY = this.innerTop;
    var innerWidth = this.innerWidth;
    var innerHeight = this.innerHeight;
    var itemX = startX,
        itemY = startY;
    var x, y, width, height; // Align zone
    var childWidth, childHeight;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = (!this.rtl) ? children[i] : children[cnt - i - 1];
        if (child.rexSizer.hidden) {
            continue;
        }

        childConfig = child.rexSizer;
        padding = childConfig.padding;

        PreLayoutChild.call(this, child);

        // Set size
        if (child.isRexSpace) {
            childWidth = 0;
            childHeight = 0;
        } else {
            childWidth = this.getExpandedChildWidth(child);
            childHeight = this.getExpandedChildHeight(child);
        }
        if (child.isRexSizer) {
            child.runLayout(this, childWidth, childHeight);
            CheckSize(child, this);
        } else {
            ResizeGameObject(child, childWidth, childHeight);
        }

        if (childWidth === undefined) {
            childWidth = GetDisplayWidth(child);
        }
        if (childHeight === undefined) {
            childHeight = GetDisplayHeight(child);
        }

        // Set position
        if (this.orientation === 0) { // x
            x = (itemX + padding.left);
            if ((childConfig.proportion === 0) || (this.proportionLength === 0)) {
                width = childWidth;
            } else {
                width = (childConfig.proportion * this.proportionLength);
            }

            y = (itemY + padding.top);
            height = (innerHeight - padding.top - padding.bottom);
        } else { // y
            x = (itemX + padding.left);
            width = (innerWidth - padding.left - padding.right);

            y = (itemY + padding.top);
            if ((childConfig.proportion === 0) || (this.proportionLength === 0)) {
                height = childHeight;
            } else {
                height = (childConfig.proportion * this.proportionLength);
            }
        }

        LayoutChild.call(this, child, x, y, width, height, childConfig.align);

        if (this.orientation === 0) { // x
            itemX += (width + padding.left + padding.right + this.space.item);
        } else { // y
            itemY += (height + padding.top + padding.bottom + this.space.item);
        }
    }

};

var ResolveWidth$1 = function (width) {
    var width = ResolveWidth.call(this, width);

    // Calculate proportionLength
    if ((this.proportionLength === undefined) && (this.orientation === 0)) {
        var remainder = width - this.childrenWidth;
        if (remainder > 0) {
            remainder = width - this.getChildrenWidth(false);
            this.proportionLength = remainder / this.childrenProportion;
        } else {
            this.proportionLength = 0;
        }
    }

    return width;
};

var ResolveHeight$1 = function (parent, height) {
    var height = ResolveHeight.call(this, parent, height);

    // Get proportionLength
    if ((this.proportionLength === undefined) && (this.orientation === 1)) {
        var remainder = height - this.childrenHeight;
        if (remainder > 0) {
            remainder = height - this.getChildrenHeight(false);
            this.proportionLength = remainder / this.childrenProportion;
        } else {
            this.proportionLength = 0;
        }
    }

    return height;
};

const Zone$1 = Phaser.GameObjects.Zone;

class Space extends Zone$1 {
    constructor(scene) {
        super(scene, 0, 0, 1, 1);
        // Don't add Zone into scene
        this.isRexSpace = true;
    }
}

const IsPlainObject$j = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1q = Phaser.Utils.Objects.GetValue;
const ALIGN_CENTER$2 = Phaser.Display.Align.CENTER;
const PROPORTIONMODE = {
    min: 0,
    full: -1,
};

var Add$2 = function (gameObject, proportion, align, paddingConfig, expand, childKey, index, minSize) {
    AddChild$1.call(this, gameObject);

    var proportionType = typeof (proportion);
    if (proportion === null) {
        return this;
    } else if (proportionType === 'number') ; else if (proportionType === 'string') {
        proportion = PROPORTIONMODE[proportion];
    } else if (IsPlainObject$j(proportion)) {
        var config = proportion;
        proportion = GetValue$1q(config, 'proportion', 0);
        align = GetValue$1q(config, 'align', ALIGN_CENTER$2);
        paddingConfig = GetValue$1q(config, 'padding', 0);
        expand = GetValue$1q(config, 'expand', false);
        childKey = GetValue$1q(config, 'key', undefined);
        index = GetValue$1q(config, 'index', undefined);

        if (!gameObject.isRexSizer) {
            // Get minSize from config
            if (this.orientation === 0) { // x
                minSize = GetValue$1q(config, 'minWidth', undefined);
            } else {  // y
                minSize = GetValue$1q(config, 'minHeight', undefined);
            }
        }
    }

    if (typeof (align) === 'string') {
        align = ALIGNMODE[align];
    }

    if (proportion === undefined) {
        proportion = 0;
    }
    if (align === undefined) {
        align = ALIGN_CENTER$2;
    }
    if (paddingConfig === undefined) {
        paddingConfig = 0;
    }
    if (expand === undefined) {
        expand = false;
    }
    if (!gameObject.isRexSizer && (minSize === undefined)) {
        // Get minSize from game object
        if (this.orientation === 0) { // x
            minSize = gameObject._minWidth;
        } else {  // y
            minSize = gameObject._minHeight;
        }
    }

    var config = this.getSizerConfig(gameObject);
    config.proportion = proportion;
    config.align = align;
    config.padding = GetBoundsConfig(paddingConfig);
    config.expand = expand;
    if ((index === undefined) || (index >= this.sizerChildren.length)) {
        this.sizerChildren.push(gameObject);
    } else {
        this.sizerChildren.splice(index, 0, gameObject);
    }

    if (!gameObject.isRexSizer && (proportion > 0)) { // Expand normal game object
        if (this.orientation === 0) { // x
            // minSize is still undefined, uses current display width
            gameObject.minWidth = (minSize === undefined) ? GetDisplayWidth(gameObject) : minSize;
            gameObject.minHeight = undefined;
        } else {
            gameObject.minWidth = undefined;
            // minSize is still undefined, uses current display height
            gameObject.minHeight = (minSize === undefined) ? GetDisplayHeight(gameObject) : minSize;
        }
    }

    if (childKey !== undefined) {
        this.addChildrenMap(childKey, gameObject);
    }
    return this;
};

var AddChildMethods$2 = {
    add: Add$2, // sizer.add could be override

    addSpace(proportion) {
        this.insertSpace(undefined, proportion);
        return this;
    },

    insertSpace(index, proportion) {
        if (proportion === undefined) {
            proportion = 1;
        }
        Add$2.call(this, new Space(this.scene),
            {
                proportion: proportion,
                minWidth: 0,
                minHeight: 0,
                index: index
            }
        );
        // No problem if sizer.add is override
        return this;
    },

    insert(index, gameObject, proportion, align, paddingConfig, expand, childKey) {
        Add$2.call(this, gameObject, proportion, align, paddingConfig, expand, childKey, index);
        // No problem if sizer.add is override
        return this;
    }
};

const RemoveItem$5 = Phaser.Utils.Array.Remove;

var RemoveChildMethods$1 = {
    remove(gameObject, destroyChild) {
        if (this.getParentSizer(gameObject) !== this) {
            return this;
        }

        RemoveItem$5(this.sizerChildren, gameObject);
        RemoveChild$1.call(this, gameObject, destroyChild);
        return this;
    },

    removeAll(destroyChild) {
        for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
            this.remove(this.sizerChildren[i], destroyChild);
        }
        return this;
    },

    clear(destroyChild) {
        this.sizerChildren.length = 0;
        ClearChildren.call(this, destroyChild);
        return this;
    }
};

var methods$7 = {
    getChildrenWidth: GetChildrenWidth$2,
    getChildrenHeight: GetChildrenHeight$2,
    getExpandedChildWidth: GetExpandedChildWidth$2,
    getExpandedChildHeight: GetExpandedChildHeight$2,
    getChildrenSizers: GetChildrenSizers$2,
    preLayout: PreLayout$1,
    layoutChildren: LayoutChildren$2,
    resolveWidth: ResolveWidth$1,
    resolveHeight: ResolveHeight$1,
};

Object.assign(
    methods$7,
    AddChildMethods$2,
    RemoveChildMethods$1
);

var GetChildrenProportion = function () {
    var result = 0;
    var children = this.sizerChildren;
    var child, proportion;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.rexSizer.hidden) {
            continue;
        }
        proportion = child.rexSizer.proportion;
        if (proportion > 0) {
            result += proportion;
        }
    }
    return result;
};

var OrientationMode = {
    x: 0,
    h: 0,
    horizontal: 0,
    'left-to-right': 0,

    y: 1,
    v: 1,
    vertical: 1,
    'top-to-bottom': 1
};

var GetOrientationMode = function (orientation) {
    if (typeof (orientation) === 'string') {
        orientation = OrientationMode[orientation];
    }
    return orientation;
};

const IsPlainObject$k = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1r = Phaser.Utils.Objects.GetValue;

class Sizer extends Base$2 {
    constructor(scene, x, y, minWidth, minHeight, orientation, config) {
        if (IsPlainObject$k(x)) {
            config = x;
            x = GetValue$1r(config, 'x', 0);
            y = GetValue$1r(config, 'y', 0);
            minWidth = GetValue$1r(config, 'width', undefined);
            minHeight = GetValue$1r(config, 'height', undefined);
            orientation = GetValue$1r(config, 'orientation', 0);
        } else if (IsPlainObject$k(minWidth)) {
            config = minWidth;
            minWidth = GetValue$1r(config, 'width', undefined);
            minHeight = GetValue$1r(config, 'height', undefined);
            orientation = GetValue$1r(config, 'orientation', 0);
        } else if (IsPlainObject$k(orientation)) {
            config = orientation;
            orientation = GetValue$1r(config, 'orientation', 0);
        }

        if (orientation === undefined) {
            orientation = 0;
        }
        super(scene, x, y, minWidth, minHeight, config);

        this.type = 'rexSizer';
        this.sizerChildren = [];
        this.setOrientation(orientation);
        this.setItemSpacing(GetValue$1r(config, 'space.item', 0));
        this.setRTL(GetValue$1r(config, 'rtl', false));

        this.addChildrenMap('items', this.sizerChildren);
    }

    setOrientation(orientation) {
        this.orientation = GetOrientationMode(orientation);
        return this;
    }

    setItemSpacing(space) {
        this.space.item = space;
        return this;
    }

    setRTL(enable) {
        if (enable === undefined) {
            enable = true;
        }
        this.rtl = enable;
        return this;
    }

    get childrenProportion() {
        if (this._childrenProportion === undefined) {
            this._childrenProportion = GetChildrenProportion.call(this);
        }
        return this._childrenProportion;
    }
}

Object.assign(
    Sizer.prototype,
    methods$7
);

var Sum = function () {
    return Array.prototype.reduce.call(arguments, Add$3, 0);
};

var Add$3 = function (a, b) {
    return a + b;
};

var GetChildrenWidth$3 = function () {
    if (this.rexSizer.hidden) {
        return 0;
    }

    var result = 0,
        columnWidth;
    var children = this.sizerChildren;
    var child, padding, childWidth, proportion;

    for (var i = 0; i < this.columnCount; i++) {
        proportion = this.columnProportions[i];
        columnWidth = 0;
        if (proportion === 0) {
            for (var j = 0; j < this.rowCount; j++) {
                child = children[(j * this.columnCount) + i];
                if (!child) {
                    continue;
                }
                if (child.rexSizer.hidden) {
                    continue;
                }

                padding = child.rexSizer.padding;
                childWidth = this.getChildWidth(child) + padding.left + padding.right;
                columnWidth = Math.max(columnWidth, childWidth);
            }
            result += columnWidth;
        }
        // else,(proportion > 0) : columnWidth is 0
        this.columnWidth[i] = columnWidth;
    }
    return result + Sum(this.space.left, ...this.space.column, this.space.right);
};

var GetChildrenHeight$3 = function () {
    if (this.rexSizer.hidden) {
        return 0;
    }

    var result = 0,
        rowHeight;
    var children = this.sizerChildren;
    var child, padding, childHeight, proportion;

    for (var i = 0; i < this.rowCount; i++) {
        proportion = this.rowProportions[i];
        rowHeight = 0;
        if (proportion === 0) {
            for (var j = 0; j < this.columnCount; j++) {
                child = children[(i * this.columnCount) + j];
                if (!child) {
                    continue;
                }
                if (child.rexSizer.hidden) {
                    continue;
                }

                childHeight = (child.isRexSizer) ?
                    Math.max(child.minHeight, child.childrenHeight) :
                    (child.hasOwnProperty('minHeight')) ? child.minHeight : GetDisplayHeight(child);
                padding = child.rexSizer.padding;
                childHeight += (padding.top + padding.bottom);
                rowHeight = Math.max(rowHeight, childHeight);
            }
            result += rowHeight;
        }
        // else,(proportion > 0) : rowHeight is 0
        this.rowHeight[i] = rowHeight;
    }
    return result + Sum(this.space.top, ...this.space.row, this.space.bottom);
};

var GetExpandedChildWidth$3 = function (child, colWidth) {
    var childWidth;
    var childConfig = child.rexSizer;
    if (childConfig.expand) {
        var padding = childConfig.padding;
        childWidth = colWidth - padding.left - padding.right;
    }
    return childWidth;
};

var GetExpandedChildHeight$3 = function (child, rowHeight) {
    var childHeight;
    var childConfig = child.rexSizer;
    if (childConfig.expand) {
        var padding = childConfig.padding;
        childHeight = rowHeight - padding.top - padding.bottom;
    }
    return childHeight;
};

var GetChildrenSizers$3 = function (out) {
    if (out === undefined) {
        out = [];
    }
    var children = this.sizerChildren,
        child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child && child.isRexSizer) {
            out.push(child);
        }
    }
    return out;
};

var PreLayout$2 = function () {
    this._totalColumnProportions = undefined;
    this._totalRowProportions = undefined;
    this.proportionWidthLength = undefined;
    this.proportionHeightLength = undefined;
    PreLayout.call(this);
    return this;
};

var LayoutChildren$3 = function () {
    var child, childConfig, padding;
    var startX = this.innerLeft,
        startY = this.innerTop;
    var itemX = startX,
        itemY = startY;
    var x, y, width, height; // Align zone
    var childWidth, childHeight;
    // Layout grid children
    var columnSpace = this.space.column;
    var rowSpace = this.space.row;
    var colWidth, rowHeight;
    for (var rowIndex = 0; rowIndex < this.rowCount; rowIndex++) {
        rowHeight = this.getRowHeight(rowIndex);

        itemX = startX;
        for (var columnIndex = 0; columnIndex < this.columnCount; columnIndex++) {
            colWidth = this.getColumnWidth(columnIndex);

            child = this.getChildAt(columnIndex, rowIndex);
            if ((!child) || (child.rexSizer.hidden)) {
                itemX += (colWidth + columnSpace[columnIndex]);
                continue;
            }

            PreLayoutChild.call(this, child);

            childWidth = this.getExpandedChildWidth(child, colWidth);
            childHeight = this.getExpandedChildHeight(child, rowHeight);
            if (child.isRexSizer) {
                child.runLayout(this, childWidth, childHeight);
                CheckSize(child, this);
            } else {
                ResizeGameObject(child, childWidth, childHeight);
            }

            childConfig = child.rexSizer;
            padding = childConfig.padding;
            x = (itemX + padding.left);
            width = colWidth - padding.left - padding.right;
            y = (itemY + padding.top);
            height = rowHeight - padding.top - padding.bottom;

            LayoutChild.call(this, child, x, y, width, height, childConfig.align);

            itemX += (colWidth + columnSpace[columnIndex]);
        }

        itemY += (rowHeight + rowSpace[rowIndex]);
    }
};

var ResolveWidth$2 = function (width) {
    var width = ResolveWidth.call(this, width);

    // Get proportionLength
    if (this.proportionWidthLength === undefined) {
        var totalColumnProportions = this.totalColumnProportions;
        if (totalColumnProportions > 0) {
            var remainder = width - this.childrenWidth;
            if (remainder >= 0) {
                this.proportionWidthLength = remainder / totalColumnProportions;
            }
        } else {
            this.proportionWidthLength = 0;
        }
    }

    return width;
};

var ResolveHeight$2 = function (parent, height) {
    var height = ResolveHeight.call(this, parent, height);

    // Get proportionLength    
    if (this.proportionHeightLength === undefined) {
        var totalRowProportions = this.totalRowProportions;
        if (totalRowProportions > 0) {
            var remainder = height - this.childrenHeight;
            if (remainder >= 0) {
                this.proportionHeightLength = remainder / totalRowProportions;
            }
        } else {
            this.proportionHeightLength = 0;
        }
    }

    return height;
};

var ResolveChildrenWidth$1 = function (width) {
    // Resolve width of sizer children
    var child, childWidth;
    var colWidth;
    for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (!child) {
            continue;
        }
        
        colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
        if (child.isRexSizer) {
            childWidth = this.getExpandedChildWidth(child, colWidth);
            childWidth = child.resolveWidth(childWidth);
            child.resolveChildrenWidth(childWidth);
        }
    }
};

// Default method
var RunWidthWrap$1 = function (width) {
    var child, childWidth;
    var colWidth;
    for (var i in this.sizerChildren) {
        child = this.sizerChildren[i];
        if (!child) {
            continue;
        }

        colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
        childWidth = this.getExpandedChildWidth(child, colWidth);
        if (childWidth === undefined) {
            childWidth = this.resolveWidth(childWidth);
        }
        if (child.runWidthWrap) {
            child.runWidthWrap(childWidth);
        }
    }
    return this;
};

const IsPlainObject$l = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1s = Phaser.Utils.Objects.GetValue;
const ALIGN_CENTER$3 = Phaser.Display.Align.CENTER;


var GetEmptyItemIndex = function (columnIndex, rowIndex, items, columnCount, rowCount) {
    if ((typeof (columnIndex) === 'number') || (typeof (rowIndex) === 'number')) {
        if (columnIndex === undefined) {
            var idx;
            for (var i = 0; i < columnCount; i++) {
                idx = (rowIndex * columnCount) + i;
                if (!items[idx]) {
                    return idx;
                }
            }
        } else if (rowIndex === undefined) {
            var idx;
            for (var i = 0; i < rowCount; i++) {
                idx = (i * columnCount) + columnIndex;
                if (!items[idx]) {
                    return idx;
                }
            }
        } else {
            var idx = (rowIndex * columnCount) + columnIndex;
            if (!items[idx]) {
                return idx;
            }
        }

    } else if (rowIndex === true) {
        var idx;
        for (var i = 0; i < columnCount; i++) {
            for (var j = 0; j < rowCount; j++) {
                idx = (j * columnCount) + i;
                if (!items[idx]) {
                    return idx;
                }
            }
        }
    } else {
        for (var i = 0, cnt = items.length; i < cnt; i++) {
            if (!items[i]) {
                return i;
            }
        }
    }
    return null;
};

var Add$4 = function (gameObject, columnIndex, rowIndex, align, paddingConfig, expand, childKey) {
    AddChild$1.call(this, gameObject);
    if (IsPlainObject$l(columnIndex)) {
        var config = columnIndex;
        columnIndex = GetValue$1s(config, 'column', undefined);
        rowIndex = GetValue$1s(config, 'row', undefined);
        align = GetValue$1s(config, 'align', ALIGN_CENTER$3);
        paddingConfig = GetValue$1s(config, 'padding', 0);
        expand = GetValue$1s(config, 'expand', false);
        childKey = GetValue$1s(config, 'key', undefined);
    }

    // Get insert index
    var itemIndex = GetEmptyItemIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
    if (itemIndex === null) {
        return this;
    }

    if (typeof (align) === 'string') {
        align = ALIGNMODE[align];
    }
    if (align === undefined) {
        align = ALIGN_CENTER$3;
    }
    if (paddingConfig === undefined) {
        paddingConfig = 0;
    }
    if (expand === undefined) {
        expand = true;
    }

    var config = this.getSizerConfig(gameObject);
    config.align = align;
    config.padding = GetBoundsConfig(paddingConfig);
    config.expand = expand;
    this.sizerChildren[itemIndex] = gameObject;

    if (childKey !== undefined) {
        this.addChildrenMap(childKey, gameObject);
    }
    return this;
};

var AddChildMethods$3 = {
    add: Add$4
};

var Fill = function (arr, value, startIdx, endIdx) {
    if (startIdx === undefined) {
        startIdx = 0;
    }
    if (endIdx === undefined) {
        endIdx = arr.length - 1;
    }
    for (var i = startIdx; i <= endIdx; i++) {
        arr[i] = value;
    }
    return arr;
};

var RemoveChildMethods$2 = {
    remove(gameObject, destroyChild) {
        if (this.getParentSizer(gameObject) !== this) {
            return this;
        }

        var idx = this.sizerChildren.indexOf(gameObject);
        if (idx !== -1) {
            this.sizerChildren[idx] = null;
        }

        RemoveChild$1.call(this, gameObject, destroyChild);
        return this;
    },

    removeAt(columnIndex, rowIndex, destroyChild) {
        var child = this.getChildAt(columnIndex, rowIndex);
        if (child) {
            this.remove(child, destroyChild);
        }
        return this;
    },

    removeAll(destroyChild) {
        for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
            var child = this.sizerChildren[i];
            if (!child) {
                continue;
            }

            this.remove(child, destroyChild);
        }
        return this;
    },

    clear(destroyChild) {
        Fill(this.sizerChildren, null);
        ClearChildren.call(this, destroyChild);
        return this;
    }
};

const GetValue$1t = Phaser.Utils.Objects.GetValue;

var ResetGrid = function (columnCount, rowCount, columnProportions, rowProportions, space) {
    if (columnProportions === undefined) {
        columnProportions = 0;
    }
    if (rowProportions === undefined) {
        rowProportions = 0;
    }

    this.columnCount = columnCount;
    this.rowCount = rowCount;
    this.gridCount = columnCount * rowCount;

    // children
    if (this.sizerChildren === undefined) {
        this.sizerChildren = [];
    } else {
        this.removeAll();
    }
    this.sizerChildren.length = columnCount * rowCount;
    Fill(this.sizerChildren, null);

    // proportions
    this.columnProportions = [];
    this.columnProportions.length = columnCount;
    if (typeof (columnProportions) === 'number') {
        Fill(this.columnProportions, columnProportions);
    } else {
        for (var i = 0; i < columnCount; i++) {
            this.columnProportions[i] = columnProportions[i] || 0;
        }
    }
    this.rowProportions = [];
    this.rowProportions.length = rowCount;
    if (typeof (rowProportions) === 'number') {
        Fill(this.rowProportions, rowProportions);
    } else {
        for (var i = 0; i < rowCount; i++) {
            this.rowProportions[i] = rowProportions[i] || 0;
        }
    }

    // width & height
    this.columnWidth = [];
    this.columnWidth.length = columnCount;
    this.rowHeight = [];
    this.rowHeight.length = rowCount;

    // space
    this.space.column = [];
    this.space.column.length = columnCount - 1;
    var columnSpace = GetValue$1t(space, 'column', 0);
    if (typeof (columnSpace) === 'number') {
        Fill(this.space.column, columnSpace);
    } else {
        for (var i = 0, cnt = this.space.column.length; i < cnt; i++) {
            this.space.column[i] = columnSpace[i] || 0;
        }
    }
    this.space.row = [];
    this.space.row.length = rowCount - 1;
    var rowSpace = GetValue$1t(space, 'row', 0);
    if (typeof (rowSpace) === 'number') {
        Fill(this.space.row, rowSpace);
    } else {
        for (var i = 0, cnt = this.space.row.length; i < cnt; i++) {
            this.space.row[i] = rowSpace[i] || 0;
        }
    }

    return this;
};

var methods$8 = {
    getChildrenWidth: GetChildrenWidth$3,
    getChildrenHeight: GetChildrenHeight$3,
    getExpandedChildWidth: GetExpandedChildWidth$3,
    getExpandedChildHeight: GetExpandedChildHeight$3,
    getChildrenSizers: GetChildrenSizers$3,
    preLayout: PreLayout$2,
    layoutChildren: LayoutChildren$3,
    resolveWidth: ResolveWidth$2,
    resolveHeight: ResolveHeight$2,
    resolveChildrenWidth: ResolveChildrenWidth$1,
    runWidthWrap: RunWidthWrap$1,

    resetGrid: ResetGrid
};

Object.assign(
    methods$8,
    AddChildMethods$3,
    RemoveChildMethods$2
);

var GetTotalColumnProportions = function () {
    var result = 0,
        proportion;
    for (var i = 0; i < this.columnCount; i++) {
        proportion = this.columnProportions[i];
        if (proportion > 0) {
            result += proportion;
        }
    }
    return result;
};

var GetTotalRowProportions = function () {
    var result = 0,
        proportion;
    for (var i = 0; i < this.rowCount; i++) {
        proportion = this.rowProportions[i];
        if (proportion > 0) {
            result += proportion;
        }
    }
    return result;
};

const IsPlainObject$m = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1u = Phaser.Utils.Objects.GetValue;

class GridSizer extends Base$2 {
    constructor(scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportions, config) {
        if (IsPlainObject$m(x)) {
            config = x;
            x = GetValue$1u(config, 'x', 0);
            y = GetValue$1u(config, 'y', 0);
            minWidth = GetValue$1u(config, 'width', undefined);
            minHeight = GetValue$1u(config, 'height', undefined);
            columnCount = GetValue$1u(config, 'column', 0);
            rowCount = GetValue$1u(config, 'row', 0);
            columnProportions = GetValue$1u(config, 'columnProportions', 0);
            rowProportions = GetValue$1u(config, 'rowProportions', 0);
        } else if (IsPlainObject$m(minWidth)) {
            config = minWidth;
            minWidth = GetValue$1u(config, 'width', undefined);
            minHeight = GetValue$1u(config, 'height', undefined);
            columnCount = GetValue$1u(config, 'column', 0);
            rowCount = GetValue$1u(config, 'row', 0);
            columnProportions = GetValue$1u(config, 'columnProportions', 0);
            rowProportions = GetValue$1u(config, 'rowProportions', 0);
        } else if (IsPlainObject$m(columnCount)) {
            config = columnCount;
            columnCount = GetValue$1u(config, 'column', 0);
            rowCount = GetValue$1u(config, 'row', 0);
            columnProportions = GetValue$1u(config, 'columnProportions', 0);
            rowProportions = GetValue$1u(config, 'rowProportions', 0);
        } else if (IsPlainObject$m(columnProportions)) {
            config = columnProportions;
            columnProportions = GetValue$1u(config, 'columnProportions', 0);
            rowProportions = GetValue$1u(config, 'rowProportions', 0);
        }
        super(scene, x, y, minWidth, minHeight, config);

        this.type = 'rexGridSizer';
        this.resetGrid(
            columnCount, rowCount,
            columnProportions, rowProportions,
            GetValue$1u(config, 'space', undefined)
        );

        this.addChildrenMap('items', this.sizerChildren);

        var createCellContainerCallback = GetValue$1u(config, 'createCellContainerCallback');
        if (createCellContainerCallback) {
            for (var y = 0, ycnt = this.rowCount; y < ycnt; y++) {
                for (var x = 0, xcnt = this.columnCount; x < xcnt; x++) {
                    var addConfig = { column: x, row: y };
                    var child = createCellContainerCallback(scene, x, y, addConfig);
                    if (child) {
                        this.add(child, addConfig);
                    }
                }
            }
        }
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        super.destroy(fromScene);

        // More free resources
        this.columnProportions = undefined;
        this.rowProportions = undefined;
        this.columnWidth = undefined;
        this.rowHeight = undefined;
    }

    setColumnProportion(columnIndex, proportion) {
        if (columnIndex >= this.columnProportions.length) {
            return this;
        }
        this.columnProportions[columnIndex] = proportion;
        return this;
    }

    setRowProportion(rowIndex, proportion) {
        if (rowIndex >= this.rowProportions.length) {
            return this;
        }
        this.rowProportions[rowIndex] = proportion;
        return this;
    }

    get totalColumnProportions() {
        if (this._totalColumnProportions === undefined) {
            this._totalColumnProportions = GetTotalColumnProportions.call(this);
        }
        return this._totalColumnProportions;
    }

    get totalRowProportions() {
        if (this._totalRowProportions === undefined) {
            this._totalRowProportions = GetTotalRowProportions.call(this);
        }
        return this._totalRowProportions;
    }

    getChildAt(columnIndex, rowIndex) {
        return this.sizerChildren[(rowIndex * this.columnCount) + columnIndex];
    }

    childToGridIndex(child, out) {
        if (!child) {
            return null;
        }

        var index = this.sizerChildren.indexOf(child);
        if (index === -1) {
            return null;
        }

        if (out === undefined) {
            out = {};
        }
        out.x = index % this.columnCount;
        out.y = Math.floor(index / this.columnCount);
        return out;
    }

    getColumnWidth(columnIndex) {
        var colProportion = this.columnProportions[columnIndex];
        var colWidth = (colProportion === 0) ? this.columnWidth[columnIndex] : (colProportion * this.proportionWidthLength);
        return colWidth;
    }

    getRowHeight(rowIndex) {
        var rowProportion = this.rowProportions[rowIndex];
        var rowHeight = (rowProportion === 0) ? this.rowHeight[rowIndex] : (rowProportion * this.proportionHeightLength);
        return rowHeight;
    }
}

Object.assign(
    GridSizer.prototype,
    methods$8
);

var GetChildrenWidth$4 = function () {
    if (this.rexSizer.hidden) {
        return 0;
    }

    // Before RunChildrenWrap
    return this.maxChildWidth + this.space.left + this.space.right;
};

var GetChildrenHeight$4 = function () {
    if (this.rexSizer.hidden) {
        return 0;
    }

    // After RunChildrenWrap
    return this.widthWrapResult.height + this.space.top + this.space.bottom;
};

var GetChildrenSizers$4 = function (out) {
    if (out === undefined) {
        out = [];
    }
    var children = this.sizerChildren, child;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === '\n') {
            continue;
        }
        if (child.isRexSizer) {
            out.push(child);
        }
    }
    return out;
};

var PreLayout$3 = function () {
    this._maxChildWidth = undefined;
    this._maxChildHeight = undefined;
    PreLayout.call(this);
    return this;
};

var LayoutChildren$4 = function () {
    var innerLineWidth = this.innerWidth;
    var justifyPercentage = this.justifyPercentage;
    var child, childConfig, padding, justifySpace = 0;
    var startX = this.innerLeft,
        startY = this.innerTop;
    var itemX = startX,
        itemY = startY;
    var x, y, width, height; // Align zone
    var lines = this.widthWrapResult.lines;
    var line, lineChlidren, remainderLineWidth;
    for (var i = 0, icnt = lines.length; i < icnt; i++) {
        line = lines[i];
        lineChlidren = line.children;

        if (this.rtl) {
            lineChlidren.reverse();
        }

        remainderLineWidth = (innerLineWidth - line.width);
        switch (this.align) {
            case 0: // left
                break;
            case 1: // right
                itemX += remainderLineWidth;
                break;
            case 2: // center
                itemX += remainderLineWidth / 2;
                break;
            case 3: // justify-left
                justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
                break;
            case 4: // justify-right
                justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
                if (justifySpace === 0) {
                    // Align right
                    itemX += remainderLineWidth;
                }
                break;
            case 5: // justify-center
                justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
                if (justifySpace === 0) {
                    // Align center
                    itemX += remainderLineWidth / 2;
                }
                break;
        }


        for (var j = 0, jcnt = lineChlidren.length; j < jcnt; j++) {
            child = lineChlidren[j];
            if (child.rexSizer.hidden) {
                continue;
            }

            childConfig = child.rexSizer;
            padding = childConfig.padding;

            PreLayoutChild.call(this, child);

            x = (itemX + padding.left);
            if (j > 0) {
                x += this.space.item;
            }

            y = (itemY + padding.top);
            width = GetDisplayWidth(child);
            height = GetDisplayHeight(child);
            itemX = x + width + padding.right + justifySpace;

            LayoutChild.call(this, child, x, y, width, height, childConfig.align);
        }

        itemX = startX;
        itemY += line.height + this.space.line;
    }
};

var GetJustifySpace = function (total, remainder, justifyPercentage, childCount) {
    return ((remainder / total) <= justifyPercentage) ? (remainder / (childCount - 1)) : 0;
};

var RunChildrenWrap = function (lineWidth, out) {
    if (out === undefined) {
        out = {
            lines: [],
            width: 0,
            height: 0
        };
    } else {
        out.lines.length = 0;
        out.width = 0;
        out.height = 0;
    }

    var children = this.sizerChildren;
    var child, childWidth, childHeight, remainder = 0;
    var lastLine, lines = out.lines, newLine;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === '\n') {
            child = undefined;
            childWidth = 0;
            newLine = true;
        } else {
            if (child.rexSizer.hidden) {
                continue;
            }

            if (child.isRexSizer) {
                child.layout(); // Use original size
            }

            childWidth = GetChildWidth$1(child);
            newLine = (remainder < childWidth);
        }
        // New line
        if (newLine) {
            if (lastLine) {
                lastLine.width = lineWidth - (remainder + this.space.item);
                out.width = Math.max(out.width, lastLine.width);
                out.height += lastLine.height + this.space.line;
            }

            lastLine = {
                children: [],
                // width: 0,
                height: 0
            };
            lines.push(lastLine);
            remainder = lineWidth;
        }

        remainder -= (childWidth + this.space.item);
        if (child) {
            lastLine.children.push(child);
            childHeight = GeChildHeight(child);
            lastLine.height = Math.max(lastLine.height, childHeight);
        }
    }

    if (lastLine) {
        lastLine.width = lineWidth - (remainder + this.space.item);
        out.width = Math.max(out.width, lastLine.width);
        out.height += lastLine.height;
    }
    return out;
};

var GetChildWidth$1 = function (child) {
    var padding = child.rexSizer.padding;
    return GetDisplayWidth(child) + padding.left + padding.right;
};

var GeChildHeight = function (child) {
    var padding = child.rexSizer.padding;
    return GetDisplayHeight(child) + padding.top + padding.bottom;
};

var RunWidthWrap$2 = function (width) {
    var innerWidth = width - this.space.left - this.space.right;
    this.widthWrapResult = RunChildrenWrap.call(this, innerWidth, this.widthWrapResult);
    RunWidthWrap.call(this, width);
};

const IsPlainObject$n = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1v = Phaser.Utils.Objects.GetValue;
const ALIGN_CENTER$4 = Phaser.Display.Align.CENTER;

var Add$5 = function (gameObject, paddingConfig, childKey, index) {
    if (gameObject === '\n') {
        this.addNewLine();
        return this;
    }

    AddChild$1.call(this, gameObject);

    if (IsPlainObject$n(paddingConfig)) {
        var config = paddingConfig;
        paddingConfig = GetValue$1v(config, 'padding', 0);
        childKey = GetValue$1v(config, 'key', undefined);
        index = GetValue$1v(config, 'index', undefined);
    }
    if (paddingConfig === undefined) {
        paddingConfig = 0;
    }

    var config = this.getSizerConfig(gameObject);
    config.align = ALIGN_CENTER$4;
    config.padding = GetBoundsConfig(paddingConfig);
    if ((index === undefined) || (index >= this.sizerChildren.length)) {
        this.sizerChildren.push(gameObject);
    } else {
        this.sizerChildren.splice(index, 0, gameObject);
    }

    if (childKey !== undefined) {
        this.addChildrenMap(childKey, gameObject);
    }
    return this;
};

var AddChildMethods$4 = {
    add(gameObject, paddingConfig, childKey) {
        if (IsArray(gameObject)) {
            var gameObjects = gameObject;
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                Add$5.call(this, gameObjects[i], paddingConfig);
            }
        } else {
            Add$5.call(this, gameObject, paddingConfig, childKey);
        }
        return this;
    },

    addNewLine() {
        this.sizerChildren.push('\n');
        return this;
    },

    insert(index, gameObject, paddingConfig, childKey) {
        Add$5.call(this, gameObject, paddingConfig, childKey, index);
        return this;
    }
};

const RemoveItem$6 = Phaser.Utils.Array.Remove;

var RemoveChildMethods$3 = {
    remove(gameObject, destroyChild) {
        if (this.getParentSizer(gameObject) !== this) {
            return this;
        }
        RemoveItem$6(this.sizerChildren, gameObject);
        RemoveChild$1.call(this, gameObject, destroyChild);
        return this;
    },

    removeAll(destroyChild) {
        for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
            this.remove(this.sizerChildren[i], destroyChild);
        }
        return this;
    },

    clear(destroyChild) {
        this.sizerChildren.length = 0;
        ClearChildren.call(this, destroyChild);
        return this;
    }
};

var methods$9 = {
    getChildrenWidth: GetChildrenWidth$4,
    getChildrenHeight: GetChildrenHeight$4,
    getChildrenSizers: GetChildrenSizers$4,
    preLayout: PreLayout$3,
    layoutChildren: LayoutChildren$4,
    runWidthWrap: RunWidthWrap$2,
};

Object.assign(
    methods$9,
    AddChildMethods$4,
    RemoveChildMethods$3
);

var GetMaxChildWidth = function (children) {
    if (children === undefined) {
        children = this.sizerChildren;
    }
    var result = 0;
    var child, childWidth;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === '\n') {
            continue;
        }

        childWidth = this.getChildWidth(child);
        result = Math.max(childWidth, result);
    }
    return result;
};

var GetMaxChildHeight = function (children) {
    if (children === undefined) {
        children = this.sizerChildren;
    }
    var result = 0;
    var child, childHeight;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child === '\n') {
            continue;
        }

        childHeight = (child.isRexSizer) ?
            Math.max(child.minHeight, child.childrenHeight) :
            (child.hasOwnProperty('minHeight')) ? child.minHeight : GetDisplayHeight(child);
        result = Math.max(childHeight, result);
    }
    return result;
};

const IsPlainObject$o = Phaser.Utils.Objects.IsPlainObject;
const GetValue$1w = Phaser.Utils.Objects.GetValue;

class FixWidthSizer extends Base$2 {
    constructor(scene, x, y, minWidth, minHeight, config) {
        if (IsPlainObject$o(x)) {
            config = x;
            x = GetValue$1w(config, 'x', 0);
            y = GetValue$1w(config, 'y', 0);
            minWidth = GetValue$1w(config, 'width', undefined);
            minHeight = GetValue$1w(config, 'height', undefined);
        } else if (IsPlainObject$o(minWidth)) {
            config = minWidth;
            minWidth = GetValue$1w(config, 'width', undefined);
            minHeight = GetValue$1w(config, 'height', undefined);
        }

        super(scene, x, y, minWidth, minHeight, config);

        this.type = 'rexFixWidthSizer';
        this.sizerChildren = [];
        this.setOrientation(GetValue$1w(config, 'orientation', 0));
        this.setItemSpacing(GetValue$1w(config, 'space.item', 0));
        this.setLineSpacing(GetValue$1w(config, 'space.line', 0));
        this.setAlign(GetValue$1w(config, 'align', 0));
        this.setJustifyPercentage(GetValue$1w(config, 'justifyPercentage', 0.25));
        this.setRTL(GetValue$1w(config, 'rtl', false));

        this.addChildrenMap('items', this.sizerChildren);
    }

    setOrientation(orientation) {
        this.orientation = GetOrientationMode(orientation);
        return this;
    }

    setItemSpacing(space) {
        this.space.item = space;
        return this;
    }

    setLineSpacing(space) {
        this.space.line = space;
        return this;
    }

    setAlign(align) {
        if (typeof (align) === 'string') {
            align = ALIGN$1[align];
        }
        this.align = align;
        return this;
    }

    setJustifyPercentage(value) {
        this.justifyPercentage = value;
        return this;
    }

    setRTL(enabled) {
        if (enabled === undefined) {
            enabled = true;
        }
        this.rtl = enabled;
        return this;
    }

    get maxChildWidth() {
        if (this._maxChildWidth === undefined) {
            this._maxChildWidth = GetMaxChildWidth.call(this);
        }
        return this._maxChildWidth;
    }

    get maxChildHeight() {
        if (this._maxChildHeight === undefined) {
            this._maxChildHeight = GetMaxChildHeight.call(this);
        }
        return this._maxChildHeight;
    }
}

const ALIGN$1 = {
    left: 0, top: 0,
    right: 1, bottom: 1,
    center: 2,
    justify: 3,
    'justify-left': 3, 'justify-top': 3,
    'justify-right': 4, 'justify-bottom': 4,
    'justify-center': 5
};

Object.assign(
    FixWidthSizer.prototype,
    methods$9
);

var AddChildMask = function (maskTarget, sizeTarget, shape, padding) {
    var maskGameObject = new DefaultMaskGraphics(sizeTarget, shape, padding); // A Graphics game object
    if (maskTarget && !maskTarget.isRexSizer) { // Sizer game object can't apply mask
        var mask = maskGameObject.createGeometryMask();
        maskTarget.setMask(mask);
        this.once('destroy', function () {
            maskTarget.setMask();
            mask.destroy();
        });
    }
    this.pin(maskGameObject);
    return maskGameObject;
};

const GetValue$1x = Phaser.Utils.Objects.GetValue;

class Label extends Sizer {
    constructor(scene, config) {
        // Create sizer
        super(scene, config);
        this.type = 'rexLabel';

        // Add elements
        var background = GetValue$1x(config, 'background', undefined);
        var icon = GetValue$1x(config, 'icon', undefined);
        var iconMask = GetValue$1x(config, 'iconMask', undefined);
        var text = GetValue$1x(config, 'text', undefined);
        var action = GetValue$1x(config, 'action', undefined);
        var actionMask = GetValue$1x(config, 'actionMask', undefined);
        // Align
        var align = GetValue$1x(config, 'align', undefined); // undefined/left/top: no space
        // Space
        var iconSpace = GetValue$1x(config, 'space.icon', 0);
        var textSpace = GetValue$1x(config, 'space.text', 0);

        if (background) {
            this.addBackground(background);
        }

        // Add space
        if (
            (align === 'right') ||
            (align === 'bottom') ||
            (align === 'center')
        ) {
            this.addSpace();
        }

        if (icon) {
            var padding;
            if (this.orientation === 0) {
                if (text || action) {
                    padding = { right: iconSpace };
                }
            } else {
                if (text || action) {
                    padding = { bottom: iconSpace };
                }
            }

            this.add(icon, 0, 'center', padding);

            if (iconMask) {
                iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
            }
        }

        if (text) {
            var expandTextWidth = GetValue$1x(config, 'expandTextWidth', false);
            var expandTextHeight = GetValue$1x(config, 'expandTextHeight', false);
            var proportion, padding, expand;
            if (this.orientation === 0) {
                proportion = (expandTextWidth) ? 1 : 0;
                if (action) {
                    padding = { right: textSpace };
                }
                expand = expandTextHeight;
            } else {
                proportion = (expandTextHeight) ? 1 : 0;
                if (action) {
                    padding = { bottom: textSpace };
                }
                expand = expandTextWidth;
            }
            this.add(text, proportion, 'center', padding, expand);
        }

        if (action) {
            this.add(action);

            if (actionMask) {
                actionMask = AddChildMask.call(this, action, action, 1); // Circle mask
            }
        }

        // Add space
        if (align === 'center') {
            this.addSpace();
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('icon', icon);
        this.addChildrenMap('iconMask', iconMask);
        this.addChildrenMap('text', text);
        this.addChildrenMap('action', action);
        this.addChildrenMap('actionMask', actionMask);
    }

    get text() {
        var textObject = this.childrenMap.text;
        if (textObject === undefined) {
            return '';
        }
        var value;
        if (textObject.text) {
            value = textObject.text;
        } else {
            value = textObject.getData('text');
        }
        return value;
    }

    set text(value) {
        var textObject = this.childrenMap.text;
        if (textObject === undefined) {
            return;
        }
        if (textObject.setText) {
            textObject.setText(value);
        } else {
            textObject.setData('text', value);
        }
    }

    setText(value) {
        this.text = value;
        return this;
    }

    appendText(value) {
        this.text += value;
        return this;
    }

    runLayout(parent, newWidth, newHeight) {
        if (this.ignoreLayout) {
            return this;
        }

        super.runLayout(parent, newWidth, newHeight);
        // Pin icon-mask to icon game object
        var iconMask = this.childrenMap.iconMask;
        if (iconMask) {
            iconMask.setPosition();
            this.resetChildPositionState(iconMask);
        }
        // Pin action-mask to action game object
        var actionMask = this.childrenMap.actionMask;
        if (actionMask) {
            actionMask.setPosition();
            this.resetChildPositionState(actionMask);
        }
        return this;
    }

    resize(width, height) {
        super.resize(width, height);
        // Resize icon-mask to icon game object
        var iconMask = this.childrenMap.iconMask;
        if (iconMask) {
            iconMask.resize();
        }
        // Resize action-mask to icon game object
        var actionMask = this.childrenMap.actionMask;
        if (actionMask) {
            actionMask.resize();
        }
        return this;
    }
}

const SizerAdd = Sizer.prototype.add;
const SizerAddSpace = Sizer.prototype.addSpace;

var Add$6 = function (gameObject) {
    var isNormalGameObject = !gameObject.isRexSpace;
    var proportion = (!isNormalGameObject || this.buttonsExpand) ? 1 : 0;

    if (this.sizerChildren.length === 0) {  // First element
        if (isNormalGameObject) {
            // Add space at head
            var hasHeadSpace = (!this.buttonsExpand) &&
                ((this.buttonsAlign === 'right') || (this.buttonsAlign === 'center') || (this.buttonsAlign === 'bottom'));
            if (hasHeadSpace) {
                SizerAddSpace.call(this);
            }

            SizerAdd.call(this,
                gameObject,
                { proportion: proportion, expand: true }
            );

            // Add space at tail
            var hasTailSpace = (!this.buttonsExpand) && (this.buttonsAlign === 'center');
            if (hasTailSpace) {
                SizerAddSpace.call(this);
            }
            this.hasTailSpace = hasTailSpace;

        } else { // A space
            SizerAdd.call(this,
                gameObject,
                { proportion: proportion, expand: true }
            );
            this.hasTailSpace = false;

        }

    } else {   // Others
        if (this.hasTailSpace) {
            var lastIndex = this.sizerChildren.length - 1;
            SizerAdd.call(this,
                gameObject,
                { index: lastIndex, proportion: proportion, expand: true }
            );

        } else {
            SizerAdd.call(this,
                gameObject,
                { proportion: proportion, expand: true }
            );
        }

    }

    // Space or other game object as button
    if (isNormalGameObject) {
        this.buttonGroup.add(gameObject);
    }

    return this;
};

var AddChildMethods$5 = {
    addButton(gameObject) {
        if (IsArray(gameObject)) {
            var gameObjects = gameObject;
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                Add$6.call(this, gameObjects[i]);
            }
        } else {
            Add$6.call(this, gameObject);
        }
        return this;
    },

    addButtons(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            Add$6.call(this, gameObjects[i]);
        }
        return this;
    }
};

const RemoveItem$7 = Phaser.Utils.Array.Remove;
const SizerRmove = Sizer.prototype.remove;
const SizerClear = Sizer.prototype.clear;

var Remove = function (gameObject, destroyChild) {
    if (this.getParentSizer(gameObject) !== this) {
        return this;
    }

    var buttons = this.buttonGroup.buttons;
    RemoveItem$7(buttons, gameObject);
    SizerRmove.call(this, gameObject, destroyChild);
    return this;
};

var RemoveChildMethods$4 = {
    remove(gameObject, destroyChild) {
        // Remove gameObject no matter it is a button or not
        if (IsArray(gameObject)) {
            var gameObjects = gameObject;
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                Remove.call(this, gameObjects[i], destroyChild);
            }
        } else {
            Remove.call(this, gameObject, destroyChild);
        }
        return this;
    },

    clear(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        buttons.length = 0;
        SizerClear.call(this, destroyChild);
        return this;
    },

    removeButton(gameObject, destroyChild) {
        var gameObject = this.getButton(gameObject);
        // Don't remove this gameObject, it is not a button
        if (!gameObject) {
            return this;
        }
        this.remove(gameObject, destroyChild);
        return this;
    },

    clearButtons(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        for (var i = buttons.length - 1; i >= 0; i--) {
            Remove.call(this, buttons[i], destroyChild);
        }
        return this;
    }
};

var AddMethods = {
    add(gameObject) {
        this.buttons.push(gameObject);

        //Default: Fire 'click' event when touch released after pressed.
        gameObject._buttonBehavior = new Button(gameObject, this.clickConfig);

        gameObject._buttonBehavior
            .on('click', function (buttonBehavior, gameObject, pointer, event) {
                this.fireEvent('button.click', gameObject, pointer, event);
            }, this)
            .on('enable', function (buttonBehavior, gameObject) {
                this.fireEvent('button.enable', gameObject);
            }, this)
            .on('disable', function (buttonBehavior, gameObject) {
                this.fireEvent('button.disable', gameObject);
            }, this);

        gameObject
            .on('pointerover', function (pointer, localX, localY, event) {
                this.fireEvent('button.over', gameObject, pointer, event);
            }, this)
            .on('pointerout', function (pointer, event) {
                this.fireEvent('button.out', gameObject, pointer, event);
            }, this);

        return this;
    },

    addMultiple(gameObjects) {
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            this.add(gameObject[i]);
        }
        return this;
    }
};

var FireEvent$2 = function (eventName, button, pointer, event) {
    var index;
    if (typeof (button) === 'number') {
        index = button;
        button = this.buttons[index];
        if (!button) {
            return;
        }
    } else {
        index = this.buttons.indexOf(button);
        if (index === -1) {
            return;
        }
    }

    // Buttons is a child. Fire internal events.
    if (this.eventEmitter !== this.parent) {
        this.parent.emit(eventName, button, index, pointer, event);
    }

    if (this.groupName !== undefined) {
        this.eventEmitter.emit(eventName, button, this.groupName, index, pointer, event);
    } else {
        this.eventEmitter.emit(eventName, button, index, pointer, event);
    }
};

const GetValue$1y = Phaser.Utils.Objects.GetValue;

var InitData = function (config, initialValue) {
    if (initialValue === undefined) {
        initialValue = false;
    }

    var dataManager = GetValue$1y(config, 'dataManager', undefined);
    var setValueCallback = GetValue$1y(config, 'setValueCallback', undefined);
    var setValueCallbackScope = GetValue$1y(config, 'setValueCallbackScope', undefined);

    if (dataManager === undefined) {
        var parent = this.parent;
        parent.setDataEnabled();
        dataManager = parent.data;
    }

    this.buttons.forEach(function (button) {
        var key = button.name;

        if (setValueCallback) {
            dataManager.events.on(`changedata-${key}`, function (parent, value, previousValue) {
                if (setValueCallbackScope) {
                    setValueCallback.call(setValueCallbackScope, button, value, previousValue);
                } else {
                    setValueCallback(button, value, previousValue);
                }
            });
        }

        dataManager.set(key, undefined);
        dataManager.set(key, initialValue); // Trigger data event 'changedata'
    });
    this.dataManager = dataManager;
};

var SetTypeMethods = {
    setType(config) {
        var type = GetValue$1y(config, 'type', undefined);
        switch (type) {
            case 'radio':
                this.setRadioType(config);
                break;
            case 'checkboxes':
                this.setCheckboxesType(config);
                break;
        }

        return this;
    },

    setRadioType(config) {
        InitData.call(this, config);

        var radioValue = undefined;
        var parent = this.parent,
            buttons = this.buttons,
            dataManager = this.dataManager;
        Object.defineProperty(parent, 'value', {
            get: function () {
                return radioValue;
            },
            set: function (newValue) {
                if (newValue === radioValue) {
                    return;
                }
                radioValue = newValue;
                // Update state of button -> Fire `changedata-btnName` event -> setValueCallback                
                buttons.forEach(function (button) {
                    var key = button.name;
                    var state = dataManager.get(key);
                    if (key === newValue) {
                        if (!state) {
                            dataManager.set(key, true);
                        }
                    } else {
                        if (state) {
                            dataManager.set(key, false);
                        }
                    }
                });
            },
            enumerable: true,
            configurable: true
        });

        parent.on('button.click', function (button) {
            parent.value = button.name;
        });

        return this;
    },

    setCheckboxesType(config) {
        InitData.call(this, config);

        var parent = this.parent,
            dataManager = this.dataManager;
        parent.on('button.click', function (button) {
            dataManager.toggle(button.name);
        });

        return this;
    }
};

var GetGameObjectByName = function (children, name) {
    if (!children) {
        return null;

    } else if (IsArray(children)) {
        var child;
        for (var i = 0, cnt = children.length; i < cnt; i++) {
            child = TestName(children[i], name);
            if (child) {
                return child;
            }
        }

    } else { // Is plain object
        var child;
        for (var key in children) {
            child = TestName(children[key], name);
            if (child) {
                return child;
            }
        }

    }
};

var TestName = function (gameObject, name) {
    if (!gameObject) {
        return null;
    } else if (gameObject.hasOwnProperty('name')) {
        return (gameObject.name === name) ? gameObject : null;
    } else { // Array, or plain object
        return GetElementByName(gameObject, name);
    }
};

var ButtonMethods = {
    getButton(index) {
        // buttonGroup and button-sizer have *buttons* member both
        var buttons = this.buttons,
            button;
        var indexType = typeof (index);
        switch (indexType) {
            case 'number':
                button = buttons[index];
                break;
            case 'string':
                button = GetGameObjectByName(buttons, index);
                break;
            default:
                button = index;
                if (buttons.indexOf(button) === -1) {
                    button = undefined;
                }
                break;
        }
        return button;
    },

    setButtonEnable(index, enabled) {
        // buttonGroup and button-sizer have *buttons* member both
        var buttons = this.buttons;
        if ((index === undefined) || (typeof (index) === 'boolean')) {
            enabled = index;
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                buttons[i]._buttonBehavior.setEnable(enabled);
            }
        } else {
            this.getButton(index)._buttonBehavior.setEnable(enabled);
        }
        return this;
    },

    toggleButtonEnable(index) {
        // buttonGroup and button-sizer have *buttons* member both
        var buttons = this.buttons;
        if ((index === undefined) || (typeof (index) === 'boolean')) {
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                buttons[i]._buttonBehavior.toggleEnable();
            }
        } else {
            this.getButton(index)._buttonBehavior.toggleEnable();
        }
        return this;
    },

    getButtonEnable(index) {
        if (index === undefined) {
            index = 0;
        }
        return this.getButton(index)._buttonBehavior.enable;
    },

    emitButtonClick(index) {
        // index or button game object
        // this: buttonGroup or button-sizer
        var buttonGroup = (this.buttonGroup) ? this.buttonGroup : this;
        buttonGroup.fireEvent('button.click', index);
        return this;
    },

    showButton(index) {
        Show(this.getButton(index));
        return this;
    },

    hideButton(index) {
        Hide(this.getButton(index));
        return this;
    },

    isButtonShown(index) {
        IsShown(this.getButton(index));
        return this;
    },

    forEachButtton(callback, scope) {
        // buttonGroup and button-sizer have *buttons* member both
        var buttons = this.buttons;
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
            if (scope) {
                callback.call(scope, buttons[i], i, buttons);
            } else {
                callback(buttons[i], i, buttons);
            }
        }
        return this;
    }
};

class ButtonGroup {
    constructor(config) {
        this.parent = config.parent;
        this.eventEmitter = config.eventEmitter;
        this.groupName = config.groupName;
        this.clickConfig = config.clickConfig;

        this.buttons = [];
    }

    destroy() {
        this.parent = undefined;
        this.eventEmitter = undefined;
        this.clickConfig = undefined;
        this.buttons = undefined; // GameObjects will be destroyed outside
    }
}

var methods$a = {
    fireEvent: FireEvent$2
};

Object.assign(
    ButtonGroup.prototype,
    AddMethods,
    SetTypeMethods,
    ButtonMethods,
    methods$a
);

const GetValue$1z = Phaser.Utils.Objects.GetValue;

class Buttons extends Sizer {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        var buttonSpace = config.space;
        if (typeof (buttonSpace) === 'number') {
            config.space = { item: buttonSpace };
        }

        // Create
        super(scene, config);
        this.type = 'rexButtons';
        this.buttonGroup = new ButtonGroup({
            parent: this,
            eventEmitter: GetValue$1z(config, 'eventEmitter', this),
            groupName: GetValue$1z(config, 'groupName', undefined),
            clickConfig: GetValue$1z(config, 'click', undefined)
        });

        // Add elements
        var background = GetValue$1z(config, 'background', undefined);
        var buttons = GetValue$1z(config, 'buttons', undefined);

        // Buttons properties
        this.buttonsExpand = GetValue$1z(config, 'expand', false);
        this.buttonsAlign = GetValue$1z(config, 'align', undefined); // undefined/left/top: no space                

        if (background) {
            this.addBackground(background);
        }

        if (buttons) {
            this.addButtons(buttons);
        }

        this.buttonGroup.setType(config);

        this.addChildrenMap('background', background);
        this.addChildrenMap('buttons', this.buttonGroup.buttons);
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        super.destroy(fromScene);
        this.buttonGroup.destroy();
        this.buttonGroup = undefined;
    }

    get buttons() {
        return this.buttonGroup.buttons;
    }

    get groupName() {
        return this.buttonGroup.groupName;
    }

    set groupName(value) {
        this.buttonGroup.groupName = value;
    }

    get eventEmitter() {
        return this.buttonGroup.eventEmitter;
    }
}

Object.assign(
    Buttons.prototype,
    AddChildMethods$5,
    RemoveChildMethods$4,
    ButtonMethods
);

const SizerAdd$1 = GridSizer.prototype.add;

var AddChildMethods$6 = {
    addButton(gameObject, columnIndex, rowIndex) {
        SizerAdd$1.call(this, gameObject, columnIndex, rowIndex, undefined, 0, this.buttonsExpand);
        this.buttonGroup.add(gameObject);
        return this;
    },

    addButtons(gameObjects, rowThenColumn) {
        for (var i = 0, cnt = gameObjects; i < cnt; i++) {
            this.addButton(gameObjects[i], undefined, rowThenColumn);
        }
        return this;
    }
};

const RemoveItem$8 = Phaser.Utils.Array.Remove;
const SizerRmove$1 = GridSizer.prototype.remove;
const SizerClear$1 = GridSizer.prototype.clear;

var Remove$1 = function (gameObject, destroyChild) {
    var gameObject = this.getButton(gameObject);
    if (!gameObject) {
        return this;
    }

    var buttons = this.buttonGroup.buttons;
    RemoveItem$8(buttons, gameObject);
    SizerRmove$1.call(this, gameObject, destroyChild);
    return this;
};

var RemoveChildMethods$5 = {
    remove(gameObject, destroyChild) {
        if (IsArray(gameObject)) {
            var gameObjects = gameObject;
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                Remove$1.call(this, gameObjects[i], destroyChild);
            }
        } else {
            Remove$1.call(this, gameObject, destroyChild);
        }
        return this;
    },

    clear(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        buttons.length = 0;
        SizerClear$1.call(this, destroyChild);
        return this;
    },

    removeButton(gameObject, destroyChild) {
        this.remove(gameObject, destroyChild);
        return this;
    },

    clearButtons(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        for (var i = buttons.length - 1; i >= 0; i--) {
            Remove$1.call(this, buttons[i], destroyChild);
        }
        return this;
    }
};

const GetValue$1A = Phaser.Utils.Objects.GetValue;

class GridButtons extends GridSizer {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }
        var row = GetValue$1A(config, 'row', 0);
        var col = GetValue$1A(config, 'col', 0);
        var createCellContainerCallback = GetValue$1A(config, 'createCellContainerCallback');
        var buttons = GetValue$1A(config, 'buttons', undefined);
        var buttonsExpand = GetValue$1A(config, 'expand', true);
        var buttonProportion = (buttonsExpand) ? 1 : 0;

        if (createCellContainerCallback) {
            config.createCellContainerCallback = undefined;
        }
        if (buttons !== undefined) {
            row = Math.max(row, buttons.length);
            for (var i = 0, cnt = buttons.length; i < cnt; i++) {
                col = Math.max(col, buttons[i].length);
            }
        }

        config.row = row;
        config.column = col;
        config.columnProportions = buttonProportion;
        config.rowProportions = buttonProportion;

        // Create
        super(scene, config);
        this.type = 'rexGridButtons';
        this.buttonGroup = new ButtonGroup({
            parent: this,
            eventEmitter: GetValue$1A(config, 'eventEmitter', this),
            groupName: GetValue$1A(config, 'groupName', undefined),
            clickConfig: GetValue$1A(config, 'click', undefined)
        });

        // Add elements
        var background = GetValue$1A(config, 'background', undefined);

        // Buttons properties
        this.buttonsExpand = buttonsExpand;
        var space = GetValue$1A(config, 'space', undefined);
        if (typeof (space) === 'number') {
            space = { itemX: space, itemY: space };
        }

        if (background) {
            this.addBackground(background);
        }

        if (buttons) {
            var rowButtons, button;
            for (var r = 0, rcnt = buttons.length; r < rcnt; r++) { // row
                rowButtons = buttons[r];
                for (var c = 0, ccnt = rowButtons.length; c < ccnt; c++) { // col
                    button = rowButtons[c];
                    if (button) {
                        this.addButton(button, c, r);
                    }
                }
            }
        } else if (createCellContainerCallback) {
            for (var y = 0; y < row; y++) {
                for (var x = 0; x < col; x++) {
                    var button = createCellContainerCallback(scene, x, y);
                    if (button) {
                        this.addButton(button, x, y);
                    }
                }
            }
        }

        this.buttonGroup.setType(config);

        this.addChildrenMap('background', background);
        this.addChildrenMap('buttons', this.buttonGroup.buttons);
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        super.destroy(fromScene);
        this.buttonGroup.destroy();
        this.buttonGroup = undefined;
    }

    get buttons() {
        return this.buttonGroup.buttons;
    }

    get groupName() {
        return this.buttonGroup.groupName;
    }

    set groupName(value) {
        this.buttonGroup.groupName = value;
    }

    get eventEmitter() {
        return this.buttonGroup.eventEmitter;
    }
}

Object.assign(
    GridButtons.prototype,
    AddChildMethods$6,
    RemoveChildMethods$5,
    ButtonMethods
);

const SizerAdd$2 = FixWidthSizer.prototype.add;

var Add$7 = function (gameObject) {
    SizerAdd$2.call(this, gameObject);
    this.buttonGroup.add(gameObject);
    return this;
};

var AddChildMethods$7 = {
    addButton(gameObject) {
        if (IsArray(gameObject)) {
            var gameObjects = gameObject;
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                Add$7.call(this, gameObjects[i]);
            }
        } else {
            Add$7.call(this, gameObject);
        }
        return this;
    },

    addButtons(gameObjects) {
        if (IsArray(gameObjects[0])) {
            // 2d array
            var lines = gameObjects, line;
            for (var lineIdx = 0, lastLineIdx = (lines.length - 1); lineIdx <= lastLineIdx; lineIdx++) {
                line = lines[lineIdx];
                for (var i = 0, cnt = line.length; i < cnt; i++) {
                    Add$7.call(this, line[i]);
                }
                if (lineIdx > lastLineIdx) {
                    SizerAdd$2.addNewLine(this);
                }
            }
        } else {
            // 1d array
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                Add$7.call(this, gameObjects[i]);
            }
        }
        return this;
    }
};

const RemoveItem$9 = Phaser.Utils.Array.Remove;
const SizerRmove$2 = FixWidthSizer.prototype.remove;
const SizerClear$2 = FixWidthSizer.prototype.clear;

var Remove$2 = function (gameObject, destroyChild) {
    var gameObject = this.getButton(gameObject);
    if (!gameObject) {
        return this;
    }

    var buttons = this.buttonGroup.buttons;
    RemoveItem$9(buttons, gameObject);
    SizerRmove$2.call(this, gameObject, destroyChild);
    return this;
};

var RemoveChildMethods$6 = {
    remove(gameObject, destroyChild) {
        if (IsArray(gameObject)) {
            var gameObjects = gameObject;
            for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
                Remove$2.call(this, gameObjects[i], destroyChild);
            }
        } else {
            Remove$2.call(this, gameObject, destroyChild);
        }
        return this;
    },

    clear(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        buttons.length = 0;
        SizerClear$2.call(this, destroyChild);
        return this;
    },

    removeButton(gameObject, destroyChild) {
        this.remove(gameObject, destroyChild);
        return this;
    },

    clearButtons(destroyChild) {
        var buttons = this.buttonGroup.buttons;
        for (var i = buttons.length - 1; i >= 0; i--) {
            Remove$2.call(this, buttons[i], destroyChild);
        }
        return this;
    }
};

const GetValue$1B = Phaser.Utils.Objects.GetValue;

class Buttons$1 extends FixWidthSizer {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        var buttonSpace = config.space;
        if (typeof (buttonSpace) === 'number') {
            config.space = { item: buttonSpace, line: buttonSpace };
        }

        // Create
        super(scene, config);
        this.type = 'rexFixWidthButtons';
        this.buttonGroup = new ButtonGroup({
            parent: this,
            eventEmitter: GetValue$1B(config, 'eventEmitter', this),
            groupName: GetValue$1B(config, 'groupName', undefined),
            clickConfig: GetValue$1B(config, 'click', undefined)
        });

        // Add elements
        var background = GetValue$1B(config, 'background', undefined);
        var buttons = GetValue$1B(config, 'buttons', undefined);

        // Buttons properties
        this.buttonsAlign = GetValue$1B(config, 'align', undefined);

        if (background) {
            this.addBackground(background);
        }

        if (buttons) {
            this.addButtons(buttons);
        }

        this.buttonGroup.setType(config);

        this.addChildrenMap('background', background);
        this.addChildrenMap('buttons', this.buttonGroup.buttons);
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        super.destroy(fromScene);
        this.buttonGroup.destroy();
        this.buttonGroup = undefined;
    }

    get buttons() {
        return this.buttonGroup.buttons;
    }

    get groupName() {
        return this.buttonGroup.groupName;
    }

    set groupName(value) {
        this.buttonGroup.groupName = value;
    }

    get eventEmitter() {
        return this.buttonGroup.eventEmitter;
    }
}

Object.assign(
    Buttons$1.prototype,
    AddChildMethods$7,
    RemoveChildMethods$6,
    ButtonMethods
);

var ButtonMethods$1 = {
    getChoice(index) {
        return this.childrenMap.choicesSizer.getButton(index);
    },

    getAction(index) {
        return this.childrenMap.actionsSizer.getButton(index);
    },

    getToolbar(index) {
        return this.childrenMap.toolbarSizer.getButton(index);
    },

    getLeftToolbar(index) {
        return this.childrenMap.leftToolbarSizer.getButton(index);
    },

    setChoiceEnable(index, enabled) {
        this.childrenMap.choicesSizer.setButtonEnable(index, enabled);
        return this;
    },

    setActionEnable(index, enabled) {
        this.childrenMap.actionsSizer.setButtonEnable(index, enabled);
        return this;
    },

    setToolbarEnable(index, enabled) {
        this.childrenMap.toolbarSizer.setButtonEnable(index, enabled);
        return this;
    },

    setLeftToolbarEnable(index, enabled) {
        this.childrenMap.leftToolbarSizer.setButtonEnable(index, enabled);
        return this;
    },

    toggleChoiceEnable(index) {
        this.childrenMap.choicesSizer.toggleButtonEnable(index);
        return this;
    },

    toggleActionEnable(index) {
        this.childrenMap.actionsSizer.toggleButtonEnable(index);
        return this;
    },

    toggleToolbarEnable(index) {
        this.childrenMap.toolbarSizer.toggleButtonEnable(index);
        return this;
    },

    toggleLeftToolbarEnable(index) {
        this.childrenMap.leftToolbarSizer.toggleButtonEnable(index);
        return this;
    },

    getChoiceEnable(index) {
        return this.childrenMap.choicesSizer.getButtonEnable(index);
    },

    getActionEnable(index) {
        return this.childrenMap.actionsSizer.getButtonEnable(index);
    },

    getToolbarEnable(index) {
        return this.childrenMap.toolbarSizer.getButtonEnable(index);
    },

    getLeftToolbarEnable(index) {
        return this.childrenMap.leftToolbarSizer.getButtonEnable(index);
    },

    emitChoiceClick(index) {
        this.childrenMap.choicesSizer.emitButtonClick(index);
        return this;
    },

    emitActionClick(index) {
        this.childrenMap.actionsSizer.emitButtonClick(index);
        return this;
    },

    emitToolbarClick(index) {
        this.childrenMap.toolbarSizer.emitButtonClick(index);
        return this;
    },

    emitLeftToolbarClick(index) {
        this.childrenMap.leftToolbarSizer.emitButtonClick(index);
        return this;
    },

    showChoice(index) {
        this.childrenMap.choicesSizer.showButton(index);
        return this;
    },

    showAction(index) {
        this.childrenMap.actionsSizer.showButton(index);
        return this;
    },

    showToolbar(index) {
        this.childrenMap.toolbarSizer.showButton(index);
        return this;
    },

    showLeftToolbar(index) {
        this.childrenMap.leftToolbarSizer.showButton(index);
        return this;
    },

    hideChoice(index) {
        this.childrenMap.choicesSizer.hideButton(index);
        return this;
    },

    hideAction(index) {
        this.childrenMap.actionsSizer.hideButton(index);
        return this;
    },

    hideToolbar(index) {
        this.childrenMap.toolbarSizer.hideButton(index);
        return this;
    },

    hideLeftToolbar(index) {
        this.childrenMap.leftToolbarSizer.hideButton(index);
        return this;
    },

    addChoice(gameObject) {
        this.childrenMap.choicesSizer.addButton(gameObject);
        return this;
    },

    addAction(gameObject) {
        this.childrenMap.actionsSizer.addButton(gameObject);
        return this;
    },

    addToolbar(gameObject) {
        this.childrenMap.toolbarSizer.addButton(gameObject);
        return this;
    },

    addLeftToolbar(gameObject) {
        this.childrenMap.leftToolbarSizer.addButton(gameObject);
        return this;
    },

    removeChoice(index, destroyChild) {
        this.childrenMap.choicesSizer.removeButton(index, destroyChild);
        return this;
    },

    removeAction(index, destroyChild) {
        this.childrenMap.actionsSizer.removeButton(index, destroyChild);
        return this;
    },

    removeToolbar(index, destroyChild) {
        this.childrenMap.toolbarSizer.removeButton(index, destroyChild);
        return this;
    },

    removeLeftToolbar(index, destroyChild) {
        this.childrenMap.leftToolbarSizer.removeButton(index, destroyChild);
        return this;
    },

    clearChoices(destroyChild) {
        this.childrenMap.choicesSizer.clearButtons(destroyChild);
        return this;
    },

    clearActions(destroyChild) {
        this.childrenMap.actionsSizer.clearButtons(destroyChild);
        return this;
    },

    clearToolbar(destroyChild) {
        this.childrenMap.toolbarSizer.clearButtons(destroyChild);
        return this;
    },

    clearLeftToolbar(destroyChild) {
        this.childrenMap.leftToolbarSizer.clearButtons(destroyChild);
        return this;
    },

    forEachChoice(callback, scope) {
        this.childrenMap.choicesSizer.forEachButtton(callback, scope);
        return this;
    },

    forEachAction(callback, scope) {
        this.childrenMap.actionsSizer.forEachButtton(callback, scope);
        return this;
    },

    forEachToolbar(callback, scope) {
        this.childrenMap.toolbarSizer.forEachButtton(callback, scope);
        return this;
    },

    forEachLeftToolbar(callback, scope) {
        this.childrenMap.leftToolbarSizer.forEachButtton(callback, scope);
        return this;
    }
};

const GetValue$1C = Phaser.Utils.Objects.GetValue;

class Dialog extends Sizer {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }
        // Create sizer        
        config.orientation = 1; // Top to bottom
        super(scene, config);
        this.type = 'rexDialog';
        this.eventEmitter = GetValue$1C(config, 'eventEmitter', this);

        // Add elements
        var background = GetValue$1C(config, 'background', undefined);
        var title = GetValue$1C(config, 'title', undefined);
        var toolbar = GetValue$1C(config, 'toolbar', undefined);
        var toolbarBackground = GetValue$1C(config, 'toolbarBackground', undefined);
        var leftToolbar = GetValue$1C(config, 'leftToolbar', undefined);
        var leftToolbarBackground = GetValue$1C(config, 'leftToolbarBackground', undefined);
        var content = GetValue$1C(config, 'content', undefined);
        var description = GetValue$1C(config, 'description', undefined);
        var choicesSizer;
        var choices = GetValue$1C(config, 'choices', undefined);
        var choicesBackground = GetValue$1C(config, 'choicesBackground', undefined);
        var actionsSizer;
        var actions = GetValue$1C(config, 'actions', undefined);
        var actionsBackground = GetValue$1C(config, 'actionsBackground', undefined);
        var clickConfig = GetValue$1C(config, 'click', undefined);

        if (background) {
            this.addBackground(background);
        }

        var toolbarSizer;
        if (toolbar) {
            toolbarSizer = new Buttons(scene, {
                groupName: 'toolbar',
                background: toolbarBackground,
                buttons: toolbar,
                orientation: 0, // Left-right
                space: { item: GetValue$1C(config, 'space.toolbarItem', 0) },
                click: clickConfig,
                eventEmitter: this.eventEmitter,
            });
        }

        var leftToolbarSizer;
        if (leftToolbar) {
            leftToolbarSizer = new Buttons(scene, {
                groupName: 'leftToolbar',
                background: leftToolbarBackground,
                buttons: leftToolbar,
                orientation: 0, // Left-right
                space: { item: GetValue$1C(config, 'space.leftToolbarItem', 0) },
                click: clickConfig,
                eventEmitter: this.eventEmitter,
            });
        }

        // title only
        if (title && !toolbar && !leftToolbar) {
            var align = GetValue$1C(config, 'align.title', 'center');
            var titleSpace = GetValue$1C(config, 'space.title', 0);
            var padding;
            if (content || description || choices || actions) {
                padding = { bottom: titleSpace };
            }
            var expand = GetValue$1C(config, 'expand.title', true);
            this.add(
                title,
                { align: align, padding: padding, expand: expand }
            );
        }

        // toolbar only
        if (toolbar && !title && !leftToolbar) {
            var titleSpace = GetValue$1C(config, 'space.title', 0);
            var padding;
            if (content || description || choices || actions) {
                padding = { bottom: titleSpace };
            }
            var expand = GetValue$1C(config, 'expand.toolbar', true);
            this.add(
                toolbarSizer,
                { align: 'right', padding: padding, expand: expand }
            );
        }

        // leftToolbar only
        if (leftToolbar && !title && !toolbar) {
            var titleSpace = GetValue$1C(config, 'space.title', 0);
            var padding;
            if (content || description || choices || actions) {
                padding = { bottom: titleSpace };
            }
            var expand = GetValue$1C(config, 'expand.leftToolbar', true);
            this.add(
                leftToolbarSizer,
                { align: 'left', padding: padding, expand: expand }
            );
        }

        // tilte and (toolbar or leftToolbar)
        if (title && (toolbar || leftToolbar)) {
            var titleSizer = new Sizer(scene, {
                orientation: 0
            });
            // Add leftToolbar
            if (leftToolbarSizer) {
                titleSizer.add(
                    leftToolbarSizer,
                    { align: 'right', expand: false }
                );
            }
            // Add title
            var align = GetValue$1C(config, 'align.title', 'left');
            var expand = GetValue$1C(config, 'expand.title', true);
            // Add space if not expand
            if (
                !expand &&
                ((align === 'right') || (align === 'center'))
            ) {
                titleSizer.addSpace();
            }
            var padding = {
                left: GetValue$1C(config, 'space.titleLeft', 0),
                right: GetValue$1C(config, 'space.titleRight', 0)
            };
            var proportion = (expand) ? 1 : 0;
            titleSizer.add(
                title,
                { proportion: proportion, align: 'center', padding: padding, expand: expand }
            );
            // Add space if not expand
            if (
                !expand &&
                ((align === 'left') || (align === 'center'))
            ) {
                titleSizer.addSpace();
            }
            // Add toolbar
            if (toolbarSizer) {
                titleSizer.add(
                    toolbarSizer,
                    { align: 'right', expand: false }
                );
            }
            // Add sizer to dialog
            var titleSpace = GetValue$1C(config, 'space.title', 0);
            var padding;
            if (content || description || choices || actions) {
                padding = { bottom: titleSpace };
            }
            this.add(
                titleSizer,
                { align: 'center', padding: padding, expand: true }
            );
        }

        if (content) {
            var align = GetValue$1C(config, 'align.content', 'center');
            var contentSpace = GetValue$1C(config, 'space.content', 0);
            var padding = {
                left: GetValue$1C(config, 'space.contentLeft', 0),
                right: GetValue$1C(config, 'space.contentRight', 0),
                bottom: ((description || choices || actions) ? contentSpace : 0)
            };
            var expand = GetValue$1C(config, 'expand.content', true);
            this.add(
                content,
                { align: align, padding: padding, expand: expand }
            );
        }

        if (description) {
            var align = GetValue$1C(config, 'align.description', 'center');
            var descriptionSpace = GetValue$1C(config, 'space.description', 0);
            var padding = {
                left: GetValue$1C(config, 'space.descriptionLeft', 0),
                right: GetValue$1C(config, 'space.descriptionRight', 0),
                bottom: ((choices || actions) ? descriptionSpace : 0)
            };
            var expand = GetValue$1C(config, 'expand.description', true);        
            this.add(
                description,
                { align: align, padding: padding, expand: expand }
            );
        }

        if (choices) {
            var align = GetValue$1C(config, 'align.choices', 'center');
            choicesSizer = new Buttons(scene, {
                groupName: 'choices',
                background: choicesBackground,
                buttons: choices,
                orientation: 1, // Top-Bottom
                space: { item: GetValue$1C(config, 'space.choice', 0) },
                click: clickConfig,
                eventEmitter: this.eventEmitter,
                type: GetValue$1C(config, 'choicesType', undefined),
                setValueCallback: GetValue$1C(config, 'choicesSetValueCallback', undefined),
                setValueCallbackScope: GetValue$1C(config, 'choicesSetValueCallbackScope', undefined)
            });
            var choicesSpace = GetValue$1C(config, 'space.choices', 0);
            var padding = {
                left: GetValue$1C(config, 'space.choicesLeft', 0),
                right: GetValue$1C(config, 'space.choicesRight', 0),
                bottom: ((actions) ? choicesSpace : 0)
            };
            var expand = GetValue$1C(config, 'expand.choices', true);
            this.add(
                choicesSizer,
                { align: align, padding: padding, expand: expand }
            );
        }

        if (actions) {
            actionsSizer = new Buttons(scene, {
                groupName: 'actions',
                background: actionsBackground,
                buttons: actions,
                orientation: 0, // Left-right
                space: { item: GetValue$1C(config, 'space.action', 0) },
                expand: GetValue$1C(config, 'expand.actions', false),
                align: GetValue$1C(config, 'align.actions', 'center'),
                click: clickConfig,
                eventEmitter: this.eventEmitter,
            });
            var padding = {
                left: GetValue$1C(config, 'space.actionsLeft', 0),
                right: GetValue$1C(config, 'space.actionsRight', 0)
            };
            this.add(
                actionsSizer,
                { align: 'center', padding: padding, expand: true }
            );
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('title', title);
        this.addChildrenMap('toolbar', toolbar);
        this.addChildrenMap('leftToolbar', leftToolbar);
        this.addChildrenMap('content', content);
        this.addChildrenMap('description', description);
        this.addChildrenMap('choices', choices);
        this.addChildrenMap('actions', actions);
        this.addChildrenMap('choicesSizer', choicesSizer);
        this.addChildrenMap('actionsSizer', actionsSizer);
        this.addChildrenMap('toolbarSizer', toolbarSizer);
        this.addChildrenMap('leftToolbarSizer', leftToolbarSizer);
    }
}

Object.assign(
    Dialog.prototype,
    ButtonMethods$1
);

var ButtonMethods$2 = {
    getButtonsSizer(groupName) {
        return this.childrenMap[`${groupName}ButtonsSizer`];
    },

    getButton(groupName, index) {
        var buttonsSizer = this.getButtonsSizer(groupName);
        return (buttonsSizer) ? buttonsSizer.getButton(index) : undefined;
    },

    setButtonEnable(groupName, index, enabled) {
        this.getButtonsSizer(groupName).setButtonEnable(index, enabled);
        return this;
    },

    setLeftButtonEnable(index, enabled) {
        this.childrenMap.leftButtonsSizer.setButtonEnable(index, enabled);
        return this;
    },

    setRightButtonEnable(index, enabled) {
        this.childrenMap.rightButtonsSizer.setButtonEnable(index, enabled);
        return this;
    },

    setTopButtonEnable(index, enabled) {
        this.childrenMap.topButtonsSizer.setButtonEnable(index, enabled);
        return this;
    },

    setBottomButtonEnable(index, enabled) {
        this.childrenMap.bottomButtonsSizer.setButtonEnable(index, enabled);
        return this;
    },

    toggleButtonEnable(groupName, index) {
        this.getButtonsSizer(groupName).toggleButtonEnable(index);
        return this;
    },

    toggleLeftButtonEnable(index) {
        this.childrenMap.leftButtonsSizer.toggleButtonEnable(index);
        return this;
    },

    toggleRightButtonEnable(index) {
        this.childrenMap.rightButtonsSizer.toggleButtonEnable(index);
        return this;
    },

    toggleTopButtonEnable(index) {
        this.childrenMap.topButtonsSizer.toggleButtonEnable(index);
        return this;
    },

    toggleBottomButtonEnable(index) {
        this.childrenMap.bottomButtonsSizer.toggleButtonEnable(index);
        return this;
    },

    getButtonEnable(groupName, index) {
        return this.getButtonsSizer(groupName).getButtonEnable(index);
    },

    getLeftButtonEnable(index) {
        return this.childrenMap.leftButtonsSizer.getButtonEnable(index);
    },

    getRightButtonEnable(index) {
        return this.childrenMap.rightButtonsSizer.getButtonEnable(index);
    },

    getTopButtonEnable(index) {
        return this.childrenMap.topButtonsSizer.getButtonEnable(index);
    },

    getBottomButtonEnable(index) {
        return this.childrenMap.bottomButtonsSizer.getButtonEnable(index);
    },

    emitButtonClick(groupName, index) {
        var buttonsSizer = this.getButtonsSizer(groupName);
        if (!buttonsSizer) {
            return this;
        }
        buttonsSizer.emitButtonClick(index);
        return this;
    },

    emitLeftButtonClick(index) {
        this.childrenMap.leftButtonsSizer.emitButtonClick(index);
        return this;
    },

    emitRightButtonClick(index) {
        this.childrenMap.rightButtonsSizer.emitButtonClick(index);
        return this;
    },

    emitTopButtonClick(index) {
        this.childrenMap.topButtonsSizer.emitButtonClick(index);
        return this;
    },

    emitBottomButtonClick(index) {
        this.childrenMap.bottomButtonsSizer.emitButtonClick(index);
        return this;
    },

    getLeftButton(index) {
        return this.childrenMap.leftButtonsSizer.getButton(index);
    },

    getRightButton(index) {
        return this.childrenMap.rightButtonsSizer.getButton(index);
    },

    getTopButton(index) {
        return this.childrenMap.topButtonsSizer.getButton(index);
    },

    getBottomButton(index) {
        return this.childrenMap.bottomButtonsSizer.getButton(index);
    },

    showButton(groupName, index) {
        Show(this.getButton(groupName, index));
        return this;
    },

    showLeftButton(index) {
        Show(this.getLeftButton(index));
        return this;
    },

    showRightButton(index) {
        Show(this.getRightButton(index));
        return this;
    },

    showTopButton(index) {
        Show(this.getTopButton(index));
        return this;
    },

    showBottomButton(index) {
        Show(this.getBottomButton(index));
        return this;
    },

    hideButton(groupName, index) {
        Hide(this.getButton(groupName, index));
        return this;
    },

    hideLeftButton(index) {
        Hide(this.getLeftButton(index));
        return this;
    },

    hideRightButton(index) {
        Hide(this.getRightButton(index));
        return this;
    },

    hideTopButton(index) {
        Hide(this.getTopButton(index));
        return this;
    },

    hideBottomButton(index) {
        Hide(this.getBottomButton(index));
        return this;
    },

    addButton(groupName, gameObject) {
        this.getButtonsSizer(groupName).addButton(gameObject);
        return this;
    },

    addLeftButton(gameObject) {
        this.addButton('left', gameObject);
        return this;
    },

    addRightButton(gameObject) {
        this.addButton('right', gameObject);
        return this;
    },

    addTopButton(gameObject) {
        this.addButton('top', gameObject);
        return this;
    },

    removeButton(groupName, index, destroyChild) {
        this.getButtonsSizer(groupName).removeButton(index, destroyChild);
        return this;
    },

    removeLeftButton(index, destroyChild) {
        this.removeButton('left', index, destroyChild);
        return this;
    },

    removeRightButton(index, destroyChild) {
        this.removeButton('right', index, destroyChild);
        return this;
    },

    removeTopButton(index, destroyChild) {
        this.removeButton('top', index, destroyChild);
        return this;
    },

    removeBottomButton(index, destroyChild) {
        this.removeButton('bottom', index, destroyChild);
        return this;
    },

    clearButtons(groupName, destroyChild) {
        this.getButtonsSizer(groupName).clearButtons(destroyChild);
        return this;
    },

    clearLeftButtons(destroyChild) {
        this.clearButtons('left', destroyChild);
        return this;
    },

    clearRightButtons(destroyChild) {
        this.clearButtons('right', destroyChild);
        return this;
    },

    clearTopButtons(destroyChild) {
        this.clearButtons('top', destroyChild);
        return this;
    },

    clearBottomButtonss(destroyChild) {
        this.clearButtons('bottom', destroyChild);
        return this;
    },

    forEachButton(groupName, callback, scope) {
        this.getButtonsSizer(groupName).forEachButtton(callback, scope);
        return this;
    },

    forEachLeftButton(callback, scope) {
        this.childrenMap.leftButtonsSizer.forEachButtton(callback, scope);
        return this;
    },

    forEachRightButton(callback, scope) {
        this.childrenMap.rightButtonsSizer.forEachButtton(callback, scope);
        return this;
    },

    forEachTopButton(callback, scope) {
        this.childrenMap.topButtonsSizer.forEachButtton(callback, scope);
        return this;
    },

    forEachBottomButton(callback, scope) {
        this.childrenMap.bottomButtonsSizer.forEachButtton(callback, scope);
        return this;
    },
};

const GetValue$1D = Phaser.Utils.Objects.GetValue;

class Tabs extends GridSizer {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }
        // Create sizer
        config.column = 3;
        config.row = 3;
        super(scene, config);
        this.type = 'rexTabs';
        this.eventEmitter = GetValue$1D(config, 'eventEmitter', this);

        // Add elements
        var background = GetValue$1D(config, 'background', undefined);
        var panel = GetValue$1D(config, 'panel', undefined);
        var leftButtons = GetValue$1D(config, 'leftButtons', undefined);
        var leftButtonsBackground = GetValue$1D(config, 'leftButtonsBackground', undefined);
        var leftButtonsSizer;
        var rightButtons = GetValue$1D(config, 'rightButtons', undefined);
        var rightButtonsBackground = GetValue$1D(config, 'rightButtonsBackground', undefined);
        var rightButtonsSizer;
        var topButtons = GetValue$1D(config, 'topButtons', undefined);
        var topButtonsBackground = GetValue$1D(config, 'topButtonsBackground', undefined);
        var topButtonsSizer;
        var bottomButtons = GetValue$1D(config, 'bottomButtons', undefined);
        var bottomButtonsBackground = GetValue$1D(config, 'bottomButtonsBackground', undefined);
        var bottomButtonsSizer;
        var clickConfig = GetValue$1D(config, 'click', undefined);

        if (background) {
            this.addBackground(background);
        }

        if (panel) {
            this.add(panel, 1, 1, 'center', 0, true);
        }

        if (leftButtons) {
            var leftButtonsOffset = GetValue$1D(config, 'space.leftButtonsOffset', 0);
            var leftButtonSpace = GetValue$1D(config, 'space.leftButton', 0);
            leftButtonsSizer = new Buttons(scene, {
                groupName: 'left',
                background: leftButtonsBackground,
                buttons: leftButtons,
                orientation: 1, // Top-Bottom
                space: { item: leftButtonSpace },
                align: GetValue$1D(config, 'align.leftButtons', undefined),
                click: clickConfig,
                eventEmitter: this.eventEmitter,
            });
            var padding = {
                top: leftButtonsOffset,
            };
            this.add(leftButtonsSizer, 0, 1, 'top', padding, false);
        }

        if (rightButtons) {
            var rightButtonsOffset = GetValue$1D(config, 'space.rightButtonsOffset', 0);
            var rightButtonSpace = GetValue$1D(config, 'space.rightButton', 0);
            rightButtonsSizer = new Buttons(scene, {
                groupName: 'right',
                background: rightButtonsBackground,
                buttons: rightButtons,
                orientation: 1, // Top-Bottom
                space: { item: rightButtonSpace },
                align: GetValue$1D(config, 'align.rightButtons', undefined),
                click: clickConfig,
                eventEmitter: this.eventEmitter,
            });
            var padding = {
                top: rightButtonsOffset,
            };
            this.add(rightButtonsSizer, 2, 1, 'top', padding, false);
        }

        if (topButtons) {
            var toptButtonsOffset = GetValue$1D(config, 'space.topButtonsOffset', 0);
            var topButtonSpace = GetValue$1D(config, 'space.topButton', 0);
            topButtonsSizer = new Buttons(scene, {
                groupName: 'top',
                background: topButtonsBackground,
                buttons: topButtons,
                orientation: 0, // Left-Right
                space: { item: topButtonSpace },
                align: GetValue$1D(config, 'align.topButtons', undefined),
                click: clickConfig,
                eventEmitter: this.eventEmitter,
            });
            var padding = {
                left: toptButtonsOffset,
            };
            this.add(topButtonsSizer, 1, 0, 'left', padding, false);
        }

        if (bottomButtons) {
            var bottomButtonsOffset = GetValue$1D(config, 'space.bottomButtonsOffset', 0);
            var bottomButtonSpace = GetValue$1D(config, 'space.bottomButton', 0);
            bottomButtonsSizer = new Buttons(scene, {
                groupName: 'bottom',
                background: bottomButtonsBackground,
                buttons: bottomButtons,
                orientation: 0, // Left-Right
                space: { item: bottomButtonSpace },
                align: GetValue$1D(config, 'align.bottomButtons', undefined),
                click: clickConfig,
                eventEmitter: this.eventEmitter,
            });
            var padding = {
                left: bottomButtonsOffset,
            };
            this.add(bottomButtonsSizer, 1, 2, 'left', padding, false);
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('panel', panel);
        this.addChildrenMap('leftButtons', leftButtons);
        this.addChildrenMap('rightButtons', rightButtons);
        this.addChildrenMap('topButtons', topButtons);
        this.addChildrenMap('bottomButtons', bottomButtons);
        this.addChildrenMap('leftButtonsSizer', leftButtonsSizer);
        this.addChildrenMap('rightButtonsSizer', rightButtonsSizer);
        this.addChildrenMap('topButtonsSizer', topButtonsSizer);
        this.addChildrenMap('bottomButtonsSizer', bottomButtonsSizer);
    }
}

Object.assign(
    Tabs.prototype,
    ButtonMethods$2
);

const Percent$5 = Phaser.Math.Percent;

var PositionToPercent = function (startPoint, endPoint, currentPoint) {
    var min, max, value;
    if (startPoint.y === endPoint.y) {
        min = Math.min(startPoint.x, endPoint.x);
        max = Math.max(startPoint.x, endPoint.x);
        value = Percent$5(currentPoint.x, min, max);
    } else if (startPoint.x === endPoint.x) {
        min = Math.min(startPoint.y, endPoint.y);
        max = Math.max(startPoint.y, endPoint.y);
        value = Percent$5(currentPoint.y, min, max);
    }
    return value
};

var OnDragThumb = function (pointer, dragX, dragY) {
    if (!this.enable) {
        return;
    }
    tmpPoint.x = dragX;
    tmpPoint.y = dragY;
    this.value = PositionToPercent(this.getStartPoint(), this.getEndPoint(), tmpPoint);
};
var tmpPoint = {};

var OnTouchTrack = function (pointer, localX, localY) {
    if (!this.enable) {
        return;
    }
    if (!pointer.isDown) {
        return;
    }

    tmpPoint$1.x = pointer.worldX;
    tmpPoint$1.y = pointer.worldY;
    var value = PositionToPercent(this.getStartPoint(), this.getEndPoint(), tmpPoint$1);

    this.stopEaseValue();
    if ((this.easeValueDuration === 0) || (Math.abs(this.value - value) < 0.1)) {
        this.value = value;
    } else {
        this.easeValueTo(value);
    }
};
var tmpPoint$1 = {};

var GetThumbAlignPoint = function (align, out) {
    if (out === undefined) {
        out = tmpPoint$2;
    }
    var thumb = this.childrenMap.thumb;
    var currentX = thumb.x;
    var currentY = thumb.y;

    AlignIn(thumb, this.innerLeft, this.innerTop, this.innerWidth, this.innerHeight, align);
    out.x = thumb.x;
    out.y = thumb.y;

    thumb.x = currentX;
    thumb.y = currentY;

    return out;
};

var tmpPoint$2 = {};

const AlignLeft = Phaser.Display.Align.LEFT_CENTER;
const AlignTop = Phaser.Display.Align.TOP_CENTER;

var GetStartPoint = function (out) {
    if (out === undefined) {
        out = tmpPoint$3;
    }
    if (this.childrenMap.thumb) {
        var align = (this.orientation === 0) ? AlignLeft : AlignTop;
        GetThumbAlignPoint.call(this, align, out);
    } else {
        if (this.orientation === 0) {
            out.x = this.innerLeft + 1; // Add 1 pixel margin
            out.y = this.centerY;
        } else {
            out.x = this.centerX;
            out.y = this.innerTop + 1; // Add 1 pixel margin
        }
    }
    return out;
};

var tmpPoint$3 = {};

const AlignRight = Phaser.Display.Align.RIGHT_CENTER;
const AlignBottom = Phaser.Display.Align.BOTTOM_CENTER;

var GetEndoint = function (out) {
    if (out === undefined) {
        out = tmpPoint$4;
    }
    if (this.childrenMap.thumb) {
        var align = (this.orientation === 0) ? AlignRight : AlignBottom;
        GetThumbAlignPoint.call(this, align, out);
    } else {
        if (this.orientation === 0) {
            out.x = this.innerRight - 1; // Add 1 pixel margin
            out.y = this.centerY;
        } else {
            out.x = this.centerX;
            out.y = this.innerBottom - 1; // Add 1 pixel margin
        }
    }
    return out;
};

var tmpPoint$4 = {};

const Linear$a = Phaser.Math.Linear;

var PercentToPosition = function (t, startPoint, endPoint, out) {
    if (out === undefined) {
        out = tmpOut;
    }
    out.x = Linear$a(startPoint.x, endPoint.x, t);
    out.y = Linear$a(startPoint.y, endPoint.y, t);
    return out;
};
var tmpOut = {};

var UpdateThumb = function (t) {
    var thumb = this.childrenMap.thumb;
    if (thumb === undefined) {
        return this;
    }

    if (t === undefined) {
        t = this.value;
    }
    PercentToPosition(t, this.getStartPoint(), this.getEndPoint(), thumb);
    this.resetChildPositionState(thumb);
    return this;
};

const AlignLeft$1 = Phaser.Display.Align.LEFT_CENTER;
const AlignTop$1 = Phaser.Display.Align.TOP_CENTER;

var UpdateIndicator = function (t) {
    var indicator = this.childrenMap.indicator;
    if (indicator === undefined) {
        return this;
    }

    if (t === undefined) {
        t = this.value;
    }

    var newWidth, newHeight;
    var thumb = this.childrenMap.thumb;
    if (thumb) {
        if (this.orientation === 0) { // x, extend width
            var thumbWidth = GetDisplayWidth(thumb);
            var thumbRight = (thumb.x - (thumbWidth * thumb.originX)) + thumbWidth;
            newWidth = thumbRight - this.left;
        } else { // y, extend height
            var thumbHeight = GetDisplayHeight(thumb);
            var thumbBottom = (thumb.y - (thumbHeight * thumb.originY)) + thumbHeight;
            newHeight = thumbBottom - this.top;
        }
    } else {
        if (this.orientation === 0) { // x, extend width
            newWidth = this.width * t;
        } else { // y, extend eight
            newHeight = this.height * t;
        }
    }
    ResizeGameObject(indicator, newWidth, newHeight);
    var align = (this.orientation === 0) ? AlignLeft$1 : AlignTop$1;
    QuickSet(indicator, this, align);
    this.resetChildPositionState(indicator);
};

const GetValue$1E = Phaser.Utils.Objects.GetValue;
const Clamp$6 = Phaser.Math.Clamp;
const Linear$b = Phaser.Math.Linear;
const Percent$6 = Phaser.Math.Percent;
const SnapTo$1 = Phaser.Math.Snap.To;

class Slider extends Sizer {
    constructor(scene, config) {
        // Create sizer
        super(scene, config);
        this.type = 'rexSlider';
        this.eventEmitter = GetValue$1E(config, 'eventEmitter', this);

        // Add elements
        var background = GetValue$1E(config, 'background', undefined);
        var track = GetValue$1E(config, 'track', undefined);
        var indicator = GetValue$1E(config, 'indicator', undefined);
        var thumb = GetValue$1E(config, 'thumb', undefined);

        if (background) {
            this.addBackground(background);
        }

        if (track) {
            this.add(track,
                {
                    proportion: 1,
                    expand: true,
                    minWidth: 0,
                    minHeight: 0
                });
        }

        if (indicator) {
            this.pin(indicator); // Put into container but not layout it
        }

        if (thumb) {
            this.pin(thumb); // Put into container but not layout it

        }

        // Input
        var inputMode = GetValue$1E(config, 'input', 0);
        if (typeof (inputMode) === 'string') {
            inputMode = INPUTMODE$1[inputMode];
        }
        switch (inputMode) {
            case 0: // 'drag'
                if (thumb) {
                    thumb.setInteractive();
                    this.scene.input.setDraggable(thumb);
                    thumb.on('drag', OnDragThumb, this);
                }
                break;
            case 1: // 'click'
                this.setInteractive()
                    .on('pointerdown', OnTouchTrack, this)
                    .on('pointermove', OnTouchTrack, this);
                break;
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('track', track);
        this.addChildrenMap('indicator', indicator);
        this.addChildrenMap('thumb', thumb);

        var callback = GetValue$1E(config, 'valuechangeCallback', null);
        if (callback !== null) {
            var scope = GetValue$1E(config, 'valuechangeCallbackScope', undefined);
            this.eventEmitter.on('valuechange', callback, scope);
        }
        this.setEnable(GetValue$1E(config, 'enable', undefined));
        this.setGap(GetValue$1E(config, 'gap', undefined));
        this.setValue(GetValue$1E(config, 'value', 0), GetValue$1E(config, 'min', undefined), GetValue$1E(config, 'max', undefined));

        this
            .setEaseValuePropName('value')
            .setEaseValueDuration(GetValue$1E(config, 'easeValue.duration', 0))
            .setEaseValueFunction(GetValue$1E(config, 'easeValue.ease', 'Linear'));
    }

    setEnable(enable) {
        if (enable === undefined) {
            enable = true;
        }
        this.enable = enable;
        return this;
    }

    setGap(gap) {
        this.gap = gap;
        return this;
    }

    get value() {
        return this._value;
    }

    set value(value) {
        if (this.gap !== undefined) {
            value = SnapTo$1(value, this.gap);
        }
        var oldValue = this._value;
        this._value = Clamp$6(value, 0, 1);

        if (oldValue !== this._value) {
            this.updateThumb(this._value);
            this.updateIndicator(this._value);
            this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
    }

    setValue(value, min, max) {
        if ((value === undefined) || (value === null)) {
            return this;
        }

        if (min !== undefined) {
            value = Percent$6(value, min, max);
        }
        this.value = value;
        return this;
    }

    addValue(inc, min, max) {
        if (min !== undefined) {
            inc = Percent$6(inc, min, max);
        }
        this.value += inc;
        return this;
    }

    getValue(min, max) {
        var value = this.value;
        if (min !== undefined) {
            value = Linear$b(min, max, value);
        }
        return value;
    }

    runLayout(parent, newWidth, newHeight) {
        // Skip hidden or !dirty sizer
        if (this.ignoreLayout) {
            return this;
        }

        super.runLayout(parent, newWidth, newHeight);
        this.updateThumb();
        this.updateIndicator();
        return this;
    }
}

const INPUTMODE$1 = {
    pan: 0,
    drag: 0,
    click: 1,
    none: -1,
};

var methods$b = {
    getStartPoint: GetStartPoint,
    getEndPoint: GetEndoint,
    updateThumb: UpdateThumb,
    updateIndicator: UpdateIndicator,
};

Object.assign(
    Slider.prototype,
    methods$b,
    EaseValueMethods
);

var SCROLLMODE = {
    v: 0,
    vertical: 0,
    h: 1,
    horizontal: 1
};

const GetValue$1F = Phaser.Utils.Objects.GetValue;

var GetScrollMode = function (config, key) {
    var scrollMode = GetValue$1F(config, 'scrollMode', 0); // Vertical
    if (typeof (scrollMode) === 'string') {
        scrollMode = SCROLLMODE[scrollMode];
    }
    return scrollMode;
};

class FSM {
    /*
    var config = {
        start: 'A',   // default: undefined
        states: {
            A: {
                next: 'B',  // function() { return 'B'; }
                enter: function() {},
                exit: function() {}
            },
            // ...
        },        
        extend: {
            i: 0,
            name: 'abc'
            // ...
        },
        init: function() {},
        enable: true,
        eventEmitter: true,
    };
    */
    constructor(config) {
        // Attach get-next-state function
        var states = GetValue$c(config, 'states', undefined);
        if (states) {
            this.addStates(states);
        }

        // Attach extend members
        var extend = GetValue$c(config, 'extend', undefined);
        if (extend) {
            for (var name in extend) {
                if (!this.hasOwnProperty(name) || this[name] === undefined) {
                    this[name] = extend[name];
                }
            }
        }

        // Event emitter
        var eventEmitter = GetValue$c(config, 'eventEmitter', undefined);
        var EventEmitterClass = GetValue$c(config, 'EventEmitterClass', undefined);
        this.setEventEmitter(eventEmitter, EventEmitterClass);

        this._stateLock = false;
        this.resetFromJSON(config);
    }

    shutdown() {
        this.destroyEventEmitter();
    }

    destroy() {
        this.shutdown();
    }

    resetFromJSON(o) {
        this.setEnable(GetValue$c(o, 'enable', true));
        this.start(GetValue$c(o, 'start', undefined));
        var init = GetValue$c(o, 'init', undefined);
        if (init) {
            init.call(this);
        }
        return this;
    }

    toJSON() {
        return {
            curState: this.state,
            prevState: this.prevState,

            enable: this.enable,
            start: this._start
        };
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }
        this.enable = e;
        return this;
    }

    toggleEnable() {
        this.setEnable(!this.enable);
        return this;
    }

    set state(newState) {
        if (!this.enable || this._stateLock) {
            return;
        }
        if (this._state === newState) {
            return;
        }
        this._prevState = this._state;
        this._state = newState;

        this._stateLock = true; // lock state

        this.emit('statechange', this);

        if (this._prevState != null) {
            var exitEventName = 'exit_' + this._prevState;
            var exitCallback = this[exitEventName];
            if (exitCallback) {
                exitCallback.call(this);
            }
            this.emit(exitEventName, this);
        }

        this._stateLock = false;

        if (this._state != null) {
            var enterEventName = 'enter_' + this._state;
            var enterCallback = this[enterEventName];
            if (enterCallback) {
                enterCallback.call(this);
            }
            this.emit(enterEventName, this);
        }
    }

    get state() {
        return this._state;
    }

    get prevState() {
        return this._prevState;
    }

    start(state) {
        this._start = state;
        this._prevState = undefined;
        this._state = state; // Won't fire statechange events
        return this;
    }

    goto(nextState) {
        if (nextState != null) {
            this.state = nextState;
        }
        return this;
    }

    next() {
        var nextState;
        var getNextState = this['next_' + this.state];
        if (getNextState) {
            if (typeof (getNextState) === 'string') {
                nextState = getNextState;
            } else {
                nextState = getNextState.call(this);
            }
        }

        this.goto(nextState);
        return this;
    }

    addState(name, config) {
        var getNextStateCallback = GetValue$c(config, 'next', undefined);
        if (getNextStateCallback) {
            this['next_' + name] = getNextStateCallback;
        }

        var exitCallback = GetValue$c(config, 'exit', undefined);
        if (exitCallback) {
            this['exit_' + name] = exitCallback;
        }

        var enterCallback = GetValue$c(config, 'enter', undefined);
        if (enterCallback) {
            this['enter_' + name] = enterCallback;
        }
        return this;
    }

    addStates(states) {
        for (var name in states) {
            this.addState(name, states[name]);
        }
        return this;
    }

    update(time, delta, key) {
        if (key === undefined) {
            key = 'update';
        }
        var fn = this[key + '_' + this.state];
        if (fn) {
            fn.call(this, time, delta);
        }
    }

    preupdate(time, delta) {
        this.update(time, delta, 'preupdate');
    }

    postupdate(time, delta) {
        this.update(time, delta, 'postupdate');
    }
}

Object.assign(
    FSM.prototype,
    EventEmitterMethods
);

class State extends FSM {
    constructor(parent, config) {
        super(config);
        this.parent = parent;
        this.init();
    }

    init() {
        this.start('IDLE');
    }

    // IDLE -> DRAGBEGIN|DRAG
    next_IDLE() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isDown) {
            nextState = (parent.dragThreshold === 0) ? 'DRAG' : 'DRAGBEGIN';
        }
        return nextState;
    }
    update_IDLE(time, delta) {
        this.next();
    }
    // IDLE

    // DRAGBEGIN -> DRAG|IDLE
    next_DRAGBEGIN() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isDown) {
            nextState = (dragState.pointer.getDistance() >= parent.dragThreshold) ? 'DRAG' : 'DRAGBEGIN';
        } else { // dragState.isUp
            nextState = 'IDLE';
        }
        return nextState;
    }
    update_DRAGBEGIN(time, delta) {
        this.next();
    }
    // DRAGBEGIN

    // DRAG -> BACK|SLIDE|IDLE
    next_DRAG() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isUp) {
            if (parent.outOfBounds) {
                nextState = 'BACK';
            } else if (parent.slidingEnable) {
                nextState = 'SLIDE';
            } else {
                nextState = 'IDLE';
            }
        }
        return nextState;
    }
    update_DRAG(time, delta) {
        var parent = this.parent,
            dragState = parent.dragState;
        if (dragState.justMoved) {
            parent.dragging();
        }
        this.next();
    }
    // DRAG    

    // SLIDE -> DRAG|IDLE
    next_SLIDE() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isDown) {
            nextState = 'DRAG';
        } else if (!parent.isSliding) {
            nextState = 'IDLE';
        }
        return nextState;
    }
    enter_SLIDE() {
        this.parent.onSliding();
    }
    exit_SLIDE() {
        this.parent.stop();
    }
    update_SLIDE(time, delta) {
        this.parent.sliding(time, delta);
        this.next();
    }
    // SLIDE    

    // BACK -> DRAG|IDLE
    next_BACK() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;
        if (dragState.isDown) {
            nextState = 'DRAG';
        } else if (!parent.isPullBack) {
            nextState = 'IDLE';
        }
        return nextState;
    }
    enter_BACK() {
        this.parent.onPullBack();
    }
    exit_BACK() {
        this.parent.stop();
    }
    update_BACK(time, delta) {
        this.parent.pullBack(time, delta);
        this.next();
    }
    // BACK
}

const GetValue$1G = Phaser.Utils.Objects.GetValue;
const DistanceBetween$2 = Phaser.Math.Distance.Between;

class DragSpeed extends ComponentBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;

        this._enable = undefined;
        gameObject.setInteractive(GetValue$1G(config, "inputConfig", undefined));
        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        this.pointer = undefined;
        this.isInTouched = false;
        this.holdStartTime = undefined;
        this.x = undefined;
        this.y = undefined;
        this.preX = undefined;
        this.preY = undefined;
        this.localX = undefined;
        this.localY = undefined;
        this.justMoved = false;
        this.setEnable(GetValue$1G(o, 'enable', true));
        this.holdThreshold = GetValue$1G(o, 'holdThreshold', 50); // ms
        this.pointerOutReleaseEnable = GetValue$1G(o, 'pointerOutRelease', true);
        return this;
    }

    boot() {
        // Drag start only when pointer down
        this.parent.on('pointerdown', this.onPointIn, this);
        // this.parent.on('pointerover', this.onPointIn, this);

        this.parent.on('pointerup', this.onPointOut, this);

        if (this.pointerOutReleaseEnable) {
            this.parent.on('pointerout', this.onPointOut, this);
        }

        this.parent.on('pointermove', this.onPointerMove, this);
        this.scene.events.on('preupdate', this.preupdate, this);
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        // GameObject events will be removed when this gameObject destroyed 
        // this.parent.off('pointerdown', this.onPointIn, this);
        // this.parent.off('pointerup', this.onPointOut, this);
        // this.parent.off('pointerout', this.onPointOut, this);
        // this.parent.off('pointermove', this.onPointerMove, this);

        this.scene.events.off('preupdate', this.preupdate, this);

        this.pointer = undefined;

        super.shutdown(fromScene);
    }

    get enable() {
        return this._enable;
    }

    set enable(e) {
        if (this._enable === e) {
            return;
        }

        if (!e) {
            this.isInTouched = false;
            this.pointer = undefined;
        }
        this._enable = e;
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }

        this.enable = e;
        return this;
    }

    toggleEnable() {
        this.setEnable(!this.enable);
        return this;
    }

    setPointerOutReleaseEnable(enable) {
        if (enable === undefined) {
            enable = true;
        }
        this.pointerOutReleaseEnable = enable;
        return this;
    }

    get isDown() {
        return this.pointer && this.pointer.isDown;
    }

    get isUp() {
        return !this.isDown;
    }

    get dx() {
        return this.x - this.preX;
    }

    get dy() {
        return this.y - this.preY;
    }

    get dt() {
        var game = this.scene.sys.game;
        var delta = game.loop.delta;
        return delta;
    }

    get speed() {
        if ((this.x === this.preX) && (this.y === this.preY)) {
            return 0;
        }
        var d = DistanceBetween$2(this.preX, this.preY, this.x, this.y);
        var speed = d / (this.dt * 0.001);
        return speed;
    }

    get speedX() {
        return this.dx / (this.dt * 0.001);
    }

    get speedY() {
        return this.dy / (this.dt * 0.001);
    }

    // internal
    onPointIn(pointer, localX, localY) {
        if ((!this.enable) ||
            (!pointer.isDown) ||
            (this.pointer !== undefined)) {
            return;
        }
        this.pointer = pointer;
        this.localX = localX;
        this.localY = localY;
    }

    onPointOut(pointer) {
        if ((!this.enable) ||
            (this.pointer !== pointer)) {
            return;
        }
        this.pointer = undefined;
    }

    onPointerMove(pointer, localX, localY) {
        if ((!this.enable) ||
            (!pointer.isDown) ||
            (this.pointer !== pointer)) {
            return;
        }
        this.localX = localX;
        this.localY = localY;
    }

    preupdate(time, delta) {
        if (!this.enable) {
            return;
        }

        var pointer = this.pointer;
        this.justMoved = false;
        if (pointer && (!this.isInTouched)) {
            // Touch start
            this.x = pointer.x;
            this.y = pointer.y;
            this.preX = pointer.x;
            this.preY = pointer.y;
            this.isInTouched = true;
            this.holdStartTime = undefined;
            this.emit('touchstart', pointer, this.localX, this.localY);

        } else if (pointer && this.isInTouched) {
            // In touch
            if ((this.x === pointer.x) && (this.y === pointer.y)) {
                // Hold
                if (this.holdStartTime === undefined) {
                    this.holdStartTime = time;
                } else if (time - this.holdStartTime > this.holdThreshold) {
                    this.preX = this.x;
                    this.preY = this.y;
                }
            } else {
                // Move
                this.preX = this.x;
                this.preY = this.y;
                this.x = pointer.x;
                this.y = pointer.y;
                this.holdStartTime = undefined;
                this.justMoved = true;
                this.emit('touchmove', pointer, this.localX, this.localY);
            }

        } else if ((!pointer) && this.isInTouched) {
            // Touch end
            this.isInTouched = false;
            this.holdStartTime = undefined;
            this.emit('touchend', pointer);

        }
    }
}

const GetValue$1H = Phaser.Utils.Objects.GetValue;

class Movement {
    constructor(config) {
        this.resetFromJSON(config);
    }

    resetFromJSON(o) {
        this.setValue(GetValue$1H(o, 'value', 0));
        this.setSpeed(GetValue$1H(o, 'speed', 0));
        this.setAcceleration(GetValue$1H(o, 'acceleration', 0));
        return this;
    }

    reset() {
        this.setValue(0);
        this.setSpeed(0);
        this.setAcceleration(0);
    }

    setValue(value) {
        this.value = value;
        return this;
    }

    setSpeed(speed) {
        // speed == 0 : stop
        // speed  > 0 : move
        this.speed = speed;
        return this;        
    }

    setAcceleration(acc) {
        // acc == 0 : constant speed
        // acc  > 0 : acceleration
        // acc  < 0 : deceleration
        this.acceleration = acc;
        return this;
    }

    updateSpeed(delta) {
        // delta in sec
        if (this.acceleration !== 0) {
            this.speed += (this.acceleration * delta);
            if (this.speed < 0) {
                this.speed = 0;
            }
        }
        return this;
    }

    getDeltaValue(delta) {
        // delta in sec
        this.updateSpeed(delta);
        if (this.speed <= 0) {
            return 0;
        }
        return (this.speed * delta);
    }

    update(delta) {
        // delta in sec
        this.updateSpeed(delta);
        if (this.speed > 0) {
            this.value += this.getDeltaValue(delta);
        }
        return this;
    }

    get isMoving() {
        return (this.speed > 0);
    }
}

class SlowDown {
    constructor() {
        this.value;
        this.dir; // true:+, false:-
        this.movement = new Movement();
    }

    init(start, dir, speed, dec, end) {
        this.value = start;
        this.end = end;
        if (end !== undefined) {
            this.dir = (start < end);
        } else {
            this.dir = dir;
        }

        this.movement
            .setSpeed(speed)
            .setAcceleration(-dec);
        return this;
    }

    stop() {
        this.movement.reset();
    }

    update(delta) {
        // delta in sec
        var d = this.movement.getDeltaValue(delta);
        if (!this.dir) {
            d = -d;
        }

        if (this.end === undefined) {
            this.value += d;
        } else {
            if (d === 0) {
                this.value = this.end;
            } else {
                this.value += d;
                if (this.dir) { // +
                    if (this.value > this.end) {
                        this.value = this.end;
                    }
                } else { // -
                    if (this.value < this.end) {
                        this.value = this.end;
                    }
                }
            }
        }
        return this;
    }

    get isMoving() {
        return this.movement.isMoving;
    }
}

const GetValue$1I = Phaser.Utils.Objects.GetValue;
const Clamp$7 = Phaser.Math.Clamp;

class Scroller extends ComponentBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;

        var enable = GetValue$1I(config, 'enable', true);
        this._state = new State(this, {
            enable: enable,
            eventEmitter: false,
        });

        var drapSpeedConfig = {
            inputConfig: GetValue$1I(config, 'inputConfig', undefined),
            enable: enable,
            pointerOutRelease: GetValue$1I(config, 'pointerOutRelease', true),
            eventEmitter: false,
        };
        this.dragState = new DragSpeed(gameObject, drapSpeedConfig);

        this._enable = undefined;
        this._value = undefined;
        this._slowDown = new SlowDown();

        var callback = GetValue$1I(config, 'valuechangeCallback', null);
        if (callback !== null) {
            var scope = GetValue$1I(config, 'valuechangeCallbackScope', undefined);
            this.on('valuechange', callback, scope);
        }
        callback = GetValue$1I(config, 'overmaxCallback', null);
        if (callback !== null) {
            var scope = GetValue$1I(config, 'overmaxCallbackScope', undefined);
            this.on('overmax', callback, scope);
        }
        callback = GetValue$1I(config, 'overminCallback', null);
        if (callback !== null) {
            var scope = GetValue$1I(config, 'overminCallbackScope', undefined);
            this.on('overmin', callback, scope);
        }

        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        this.setOrientationMode(GetValue$1I(o, 'orientation', 0));
        this.setDragThreshold(GetValue$1I(o, 'threshold', 10));
        this.setSlidingDeceleration(GetValue$1I(o, 'slidingDeceleration', 5000));
        this.setBackDeceleration(GetValue$1I(o, 'backDeceleration', 2000));

        var bounds = GetValue$1I(o, 'bounds', undefined);
        if (bounds) {
            this.setBounds(bounds);
        } else {
            this.setBounds(GetValue$1I(o, 'max', 0), GetValue$1I(o, 'min', 0));
        }
        this.setValue(GetValue$1I(o, 'value', this.maxValue || 0));
        this.setEnable(GetValue$1I(o, "enable", true));
        return this;
    }

    boot() {
        this.scene.events.on('update', this._state.update, this._state);
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        this.scene.events.off('update', this._state.update, this._state);
        this._state.destroy(fromScene);
        this.dragState.destroy(fromScene);
        this._state = undefined;
        this.dragState = undefined;

        super.shutdown(fromScene);
    }

    get enable() {
        return this._enable;
    }

    set enable(e) {
        if (this._enable === e) {
            return;
        }

        this._enable = e;
        this._state.setEnable(e);
        this.dragState.setEnable(e);

        return this;
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }

        this.enable = e;
        return this;
    }

    toggleEnable() {
        this.setEnable(!this.enable);
        return this;
    }

    setOrientationMode(m) {
        if (typeof (m) === 'string') {
            m = ORIENTATIONMODE[m];
        }
        this.orientationMode = m;
        return this;
    }

    setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
    }

    setSlidingDeceleration(dec) {
        this.slidingDeceleration = dec;
        return this;
    }

    setBackDeceleration(dec) {
        this.backDeceleration = dec;
        return this;
    }

    setBounds(value0, value1) {
        if (Array.isArray(value0)) {
            var bounds = value0;
            value0 = bounds[0];
            value1 = bounds[1];
        }
        if (value0 < value1) {
            this.minValue = value0;
            this.maxValue = value1;
        } else {
            this.minValue = value1;
            this.maxValue = value0;
        }
        return this;
    }

    get value() {
        return this._value;
    }

    set value(value) {
        if (value === this._value) {
            return;
        }

        var oldValue = this._value;
        var isOverMax = this.overMax(value);
        var isOverMin = this.overMin(value);
        if (isOverMax) {
            this.emit('overmax', value, oldValue);
        }
        if (isOverMin) {
            this.emit('overmin', value, oldValue);
        }
        if (!this.backEnable) {
            if (isOverMax) {
                value = this.maxValue;
            }
            if (isOverMin) {
                value = this.minValue;
            }
        }

        this._value = value;
        this.emit('valuechange', value, oldValue);
    }

    setValue(value, clamp) {
        if (clamp === undefined) {
            clamp = false;
        }

        if (clamp) {
            value = Clamp$7(value, this.minValue, this.maxValue);
        }

        this.value = value;
        return this;
    }

    addValue(inc, clamp) {
        this.setValue(this.value + inc, clamp);
        return this;
    }

    get state() {
        return this._state.state;
    }

    get isDragging() {
        return this.dragState.isInTouched;
    }

    get outOfMaxBound() {
        return this.overMax(this.value);
    }

    get outOfMinBound() {
        return this.overMin(this.value);
    }

    get outOfBounds() {
        return this.outOfMinBound || this.outOfMaxBound;
    }

    // internal
    overMax(value) {
        return (this.maxValue != null) && (value > this.maxValue);
    }

    overMin(value) {
        return (this.minValue != null) && (value < this.minValue);
    }

    get backEnable() {
        return (typeof (this.backDeceleration) === 'number');
    }

    get isPullBack() {
        return this._slowDown.isMoving;
    }

    get slidingEnable() {
        return (typeof (this.slidingDeceleration) === 'number');
    }

    get isSliding() {
        return this._slowDown.isMoving;
    }

    get dragDelta() {
        if (this.orientationMode === 0) { // y
            return this.dragState.dy;
        } else if (this.orientationMode === 1) { // x
            return this.dragState.dx;
        } else {
            return 0;
        }
    }

    get dragSpeed() {
        if (this.orientationMode === 0) { // y
            return this.dragState.speedY;
        } else if (this.orientationMode === 1) { // x
            return this.dragState.speedX;
        } else {
            return 0;
        }
    }

    // everyTick_DRAG
    dragging() {
        this.value += this.dragDelta;
    }

    // enter_SLIDE 
    onSliding() {
        var start = this.value;
        var speed = this.dragSpeed;
        if (speed === 0) {
            this._slowDown.stop();
            this._state.next();
            return;
        }
        var dec = this.slidingDeceleration;
        this._slowDown.init(start, (speed > 0), Math.abs(speed), dec);
    }

    // everyTick_SLIDE
    sliding(time, delta) {
        delta *= 0.001;
        var newValue = this._slowDown.update(delta).value;
        if (this.overMax(newValue)) {
            this.value = this.maxValue;
            this._slowDown.stop();
        } else if (this.overMin(newValue)) {
            this.value = this.minValue;
            this._slowDown.stop();
        } else {
            this.value = newValue;
        }
    }

    // enter_BACK
    onPullBack() {
        var start = this.value;
        var end = (this.outOfMinBound) ? this.minValue : this.maxValue;
        var dist = Math.abs(end - start);
        var dec = this.backDeceleration;
        var speed = Math.sqrt(2 * dec * dist);
        this._slowDown.init(start, undefined, speed, dec, end);
    }

    // everyTick_BACK
    pullBack(time, delta) {
        delta *= 0.001;
        this.value = this._slowDown.update(delta).value;

        if (!this._slowDown.isMoving) {
            this._state.next();
        }
    }

    // exit_SLIDE, exit_BACK
    stop() {
        this._slowDown.stop();
    }

}

const ORIENTATIONMODE = {
    y: 0,
    v: 0,
    vertical: 0,
    x: 1,
    h: 1,
    horizontal: 1,
};

const GetValue$1J = Phaser.Utils.Objects.GetValue;

class MouseWheelScroller extends ComponentBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;

        if (this.parent !== this.scene) {
            this.focusMode = GetValue$1J(config, 'focus', false);
        } else {
            this.focusMode = false;
        }

        this.setSpeed(GetValue$1J(config, 'speed', 0.1));
        this.setEnable(GetValue$1J(config, 'enable', true));

        if (!this.focusMode) { // Register on scene
            this.scene.input.on('wheel', this.onSceneScroll, this);
        } else {
            var gameObject = this.parent;
            gameObject
                .setInteractive(GetValue$1J(config, "inputConfig", undefined))
                .on('wheel', function (pointer, dx, dy, dz, event) {
                    if (!this.enable) {
                        return;
                    }
                    this.scroll(dy);
                }, this);

        }
    }

    destroy() {
        if (!this.focusMode) {
            this.scene.input.off('wheel', this.onSceneScroll, this);
        }
    }

    onSceneScroll(pointer, currentlyOver, dx, dy, dz, event) {
        if (!this.enable) {
            return;
        }
        this.scroll(dy);
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }

        this.enable = e;
        return this;
    }

    setSpeed(speed) {
        this.speed = speed;
        return this;
    }

    scroll(dy) {
        dy *= this.speed;
        this.emit('scroll', dy, this.parent, this);
    }
}

const GetValue$1K = Phaser.Utils.Objects.GetValue;

var CreateScrollableSizer = function (config) {
    var scene = this.scene;
    var scrollMode = GetScrollMode(config);
    var scrollableSizer = new Sizer(scene, { orientation: scrollMode });
    // A child which not put into scene

    var child = GetValue$1K(config, 'child.gameObject', undefined);
    var sliderConfig = GetValue$1K(config, 'slider', undefined),
        slider,
        sliderPosition = GetValue$1K(sliderConfig, 'position', 0);
    if (typeof (sliderPosition) === 'string') {
        sliderPosition = SLIDER_POSITION_MAP[sliderPosition];
    }
    var isRightSlider = (sliderPosition === 0);  // Right/bottom slider

    var scrollerConfig = GetValue$1K(config, 'scroller', true),
        scroller;
    var mouseWheelScrollerConfig = GetValue$1K(config, 'mouseWheelScroller', false),
        mouseWheelScroller;

    // Child, slider, scroller, mouseWheelScroller
    if (child) {
        var childSpace = GetValue$1K(config, 'space.child', 0);
        var childPadding = {};
        this.childMargin = {};
        if (typeof (childSpace) !== 'number') {
            var paddingConfig = childSpace;
            if (scrollMode === 0) {
                childPadding.left = GetValue$1K(paddingConfig, 'left', 0);
                childPadding.right = GetValue$1K(paddingConfig, 'right', 0);
                this.childMargin.top = GetValue$1K(paddingConfig, 'top', 0);
                this.childMargin.bottom = GetValue$1K(paddingConfig, 'bottom', 0);
            } else {
                childPadding.top = GetValue$1K(paddingConfig, 'top', 0);
                childPadding.bottom = GetValue$1K(paddingConfig, 'bottom', 0);
                this.childMargin.top = GetValue$1K(paddingConfig, 'left', 0);
                this.childMargin.bottom = GetValue$1K(paddingConfig, 'right', 0);
            }
        } else {
            if (sliderConfig) { // Has slider
                if (scrollMode === 0) {
                    childPadding = (isRightSlider) ? { right: childSpace } : { left: childSpace };
                } else {
                    childPadding = (isRightSlider) ? { bottom: childSpace } : { top: childSpace };
                }
            }
            this.childMargin.top = 0;
            this.childMargin.bottom = 0;
        }

        if (sliderConfig) {
            if (sliderConfig === true) {
                sliderConfig = {};
            }

            // Vertical slider(orientation=1) for left-right scrollableSizer(orientation=0)
            // Horizontal slider(orientation=0) for top-bottom scrollableSizer(orientation=1)
            sliderConfig.orientation = (scrollableSizer.orientation === 0) ? 1 : 0;
            slider = new Slider(scene, sliderConfig);
        }

        if (scrollerConfig) {
            if (scrollerConfig === true) {
                scrollerConfig = {};
            }
            scrollerConfig.orientation = scrollMode;
            scroller = new Scroller(child, scrollerConfig);
        }

        if (mouseWheelScrollerConfig) {
            mouseWheelScroller = new MouseWheelScroller(child, mouseWheelScrollerConfig);
        }

        // Add slider to parent sizer at left/top side
        if (slider && (!isRightSlider)) {
            scrollableSizer.add(slider,
                {
                    proportion: 0,
                    align: 'center',
                    expand: true
                }
            );
        }

        // Add child to parent sizer
        var proportion = GetValue$1K(config, 'child.proportion', 1);
        var expand = GetValue$1K(config, 'child.expand', true);
        scrollableSizer.add(child,
            {
                proportion: proportion,
                align: 'center',
                padding: childPadding,
                expand: expand,
            }
        );

        // Add slider to parent sizer at right/bottom side
        if (slider && isRightSlider) {
            scrollableSizer.add(slider,
                {
                    proportion: 0,
                    align: 'center',
                    expand: true
                }
            );
        }

    }

    // Control
    if (slider) {
        slider.on('valuechange', function (newValue) {
            this.t = newValue;
            this.emit('scroll', this);
        }, this);
    }
    if (scroller) {
        scroller.on('valuechange', function (newValue) {
            this.childOY = newValue;
            this.emit('scroll', this);
        }, this);
    }
    if (mouseWheelScroller) {
        mouseWheelScroller.on('scroll', function (incValue) {
            this.addChildOY(-incValue, true);
        }, this);
    }

    this.addChildrenMap('child', child);
    this.addChildrenMap('slider', slider);
    this.addChildrenMap('scroller', scroller);
    this.addChildrenMap('mouseWheelScroller', mouseWheelScroller);

    return scrollableSizer;
};

var SLIDER_POSITION_MAP = {
    right: 0,
    left: 1,
    bottom: 0,
    top: 1,
};

var ResizeController = function () {
    var topChildOY = this.topChildOY;
    var bottomChildOY = this.bottomChildOY;
    var scroller = this.childrenMap.scroller;
    var slider = this.childrenMap.slider;
    if (scroller) {
        scroller.setBounds(bottomChildOY, topChildOY);
    }
    if (slider) {
        slider.setEnable(bottomChildOY !== topChildOY);
    }
    this.updateController();
    return this;
};

var UpdateController = function () {
    var scroller = this.childrenMap.scroller;
    var slider = this.childrenMap.slider;
    if (scroller) {
        scroller.setValue(this.childOY);
    }
    if (slider) {
        slider.setValue(this.t);
    }
};

const GetValue$1L = Phaser.Utils.Objects.GetValue;
const Clamp$8 = Phaser.Math.Clamp;

class Scrollable extends Sizer {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        var scrollMode = GetScrollMode(config); // Left-to-right, or top-to-bottom
        // Create sizer
        config.orientation = (scrollMode === 0) ? 1 : 0;
        super(scene, config);
        this.type = GetValue$1L(config, 'type', 'rexScrollable');

        // Add elements
        var background = GetValue$1L(config, 'background', undefined);
        var scrollableSizer = CreateScrollableSizer.call(this, config);
        var header = GetValue$1L(config, 'header', undefined);
        var footer = GetValue$1L(config, 'footer', undefined);

        // Background
        if (background) {
            this.addBackground(background);
        }

        if (header) {
            var align = GetValue$1L(config, 'align.header', 'center');
            var headerSpace = GetValue$1L(config, 'space.header', 0);
            var padding;
            if (scrollMode === 0) {
                padding = { bottom: headerSpace };
            } else {
                padding = { right: headerSpace };
            }
            var expand = GetValue$1L(config, 'expand.header', true);
            this.add(header, 0, align, padding, expand);
        }

        if (scrollableSizer) {
            this.add(scrollableSizer, 1, 'center', 0, true);
        }

        if (footer) {
            var align = GetValue$1L(config, 'align.footer', 'center');
            var footerSpace = GetValue$1L(config, 'space.footer', 0);
            var padding;
            if (scrollMode === 0) {
                padding = { top: footerSpace };
            } else {
                padding = { left: footerSpace };
            }
            var expand = GetValue$1L(config, 'expand.footer', true);
            this.add(footer, 0, align, padding, expand);
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('header', header);
        this.addChildrenMap('footer', footer);

        // Necessary properties of child object
        // child.t (RW), child.childOY (RW), child.topChildOY (R), child.bottomChildOY (R)
    }

    runLayout(parent, newWidth, newHeight) {
        // Skip hidden or !dirty sizer
        if (this.ignoreLayout) {
            return this;
        }
        super.runLayout(parent, newWidth, newHeight);
        this.resizeController();
        return this;
    }

    set t(t) {
        // Get inner childT
        var childMargin = this.childMargin;
        if ((childMargin.top !== 0) || (childMargin.bottom !== 0)) {
            var child = this.childrenMap.child;
            var innerHeight = (child.topChildOY - child.bottomChildOY);
            var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
            var innerChildOY = (outerHeight * t) - childMargin.top;
            t = innerChildOY / innerHeight;
        }

        this.childrenMap.child.t = t;
        this.updateController();
    }

    get t() {
        var t = this.childrenMap.child.t;

        // Get outer childT
        var childMargin = this.childMargin;
        if ((childMargin.top !== 0) || (childMargin.bottom !== 0)) {
            var child = this.childrenMap.child;
            var innerHeight = (child.topChildOY - child.bottomChildOY);
            var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
            var outerChildOY = (innerHeight * t) + childMargin.top;
            t = outerChildOY / outerHeight;
        }
        return t;
    }

    set childOY(value) {
        this.childrenMap.child.childOY = value;
        this.updateController();
    }

    get childOY() {
        return this.childrenMap.child.childOY;
    }

    get topChildOY() {
        return this.childrenMap.child.topChildOY + this.childMargin.top;
    }

    get bottomChildOY() {
        return this.childrenMap.child.bottomChildOY - this.childMargin.bottom;
    }

    get isOverflow() {
        var child = this.childrenMap.child;
        return child.topChildOY !== child.bottomChildOY;
    }

    setChildOY(value, clamp) {
        if (clamp === undefined) {
            clamp = false;
        }
        if (clamp) {
            value = Clamp$8(value, this.bottomChildOY, this.topChildOY);
        }
        this.childOY = value;
        return this;
    }

    addChildOY(inc, clamp) {
        this.setChildOY(this.childOY + inc, clamp);
        return this;
    }

    setT(value, clamp) {
        if (clamp === undefined) {
            clamp = false;
        }
        if (clamp) {
            value = Clamp$8(value, 0, 1);
        }
        this.t = value;
        return this;
    }

    addT(inc, clamp) {
        this.setT(this.t + inc, clamp);
        return this;
    }

    scrollToTop() {
        this.t = 0;
        return this;
    }

    scrollToBottom() {
        this.t = 1;
        return this;
    }

    get sliderEnable() {
        var slider = this.childrenMap.slider;
        if (!slider) {
            return false;
        }

        return slider.enable;
    }

    set sliderEnable(value) {
        var slider = this.childrenMap.slider;
        if (!slider) {
            return;
        }
        slider.setEnable(value);
    }

    setSliderEnable(enabled) {
        if (enabled === undefined) {
            enabled = true;
        }
        this.sliderEnable = enabled;
        return this;
    }

    get scrollerEnable() {
        var scroller = this.childrenMap.scroller;
        if (!scroller) {
            return false;
        }

        return scroller.enable;
    }

    set scrollerEnable(value) {
        var scroller = this.childrenMap.scroller;
        if (!scroller) {
            return;
        }
        scroller.setEnable(value);
    }

    setScrollerEnable(enabled) {
        if (enabled === undefined) {
            enabled = true;
        }
        this.scrollerEnable = enabled;
        return this;
    }

    get mouseWheelScrollerEnable() {
        var mouseWheelScroller = this.childrenMap.mouseWheelScroller;
        if (!mouseWheelScroller) {
            return false;
        }

        return mouseWheelScroller.enable;
    }

    set mouseWheelScrollerEnable(value) {
        var mouseWheelScroller = this.childrenMap.mouseWheelScrollerEnable;
        if (!mouseWheelScroller) {
            return;
        }
        mouseWheelScroller.setEnable(value);
    }

    setMouseWheelScrollerEnable(enabled) {
        if (enabled === undefined) {
            enabled = true;
        }
        this.mouseWheelScrollerEnable = enabled;
        return this;
    }
}

var Methods$4 = {
    resizeController: ResizeController,
    updateController: UpdateController
};

// mixin
Object.assign(
    Scrollable.prototype,
    Methods$4
);

class Cell {
    constructor(parent, config) {
        this.container = null;
        this._deltaHeight = 0;
        this.setParent(parent);
        // this.resetFromJSON(config);
    }

    setParent(parent) {
        this.parent = parent; // parent: table
        this.parentContainer = parent.getParentContainer();
    }

    // resetFromJSON(o) {
    //     return this;
    // }

    destroy(fromScene) {
        if (fromScene === undefined) {
            fromScene = false;
        }

        if (!fromScene) {
            this.destroyContainer();
        }

        this.deltaHeight = 0;
        this.data = undefined;
        this.container = null;
        this.parent = undefined;
        this.parentContainer = undefined;
    }

    get table() {
        return this.parent;
    }

    get scrollMode() {
        return this.parentContainer.scrollMode;
    }

    get colIndx() {
        return this.parent.cellIndxeToColIndex(this.index);
    }

    get rowIndx() {
        return this.parent.cellIndxeToRowIndex(this.index);
    }

    getContainer() {
        return this.container;
    }

    setContainer(container) {
        if (!container) {
            this.destroyContainer();
            return this;
        }

        if (this.container) {
            this.container.destroy();
        }
        this.container = container;
        this.parentContainer.add(container);
        return this;
    }

    destroyContainer() {
        if (this.container) {
            this.container.destroy();
            this.container = null;
        }
        return this;
    }

    popContainer() {
        if (this.container) {
            var container = this.container;
            this.container = null;
            this.parentContainer.remove(container);
            return container;
        } else {
            return null;
        }
    }

    setXY(x, y) {
        if (this.container) {
            this.parentContainer.setChildLocalPosition(this.container, x, y);
        }
        return this;
    }

    get deltaHeight() {
        return this._deltaHeight;
    }

    set deltaHeight(deltaHeight) {
        if (deltaHeight == null) {
            deltaHeight = 0;
        }
        var table = this.parent;
        if ((this._deltaHeight === 0) && (deltaHeight !== 0)) {
            table.nonZeroDeltaHeightCount++;
        } else if ((this._deltaHeight !== 0) && (deltaHeight === 0)) {
            table.nonZeroDeltaHeightCount--;
        }

        var tableHeightChanged = (this._deltaHeight !== deltaHeight);

        this._deltaHeight = deltaHeight;

        if (tableHeightChanged) {
            var eventName = (this.scrollMode === 0) ? 'cellheightchange' : 'cellwidthchange';
            this.parentContainer.emit(eventName, this, this.container, this.parentContainer);
        }
    }

    get deltaWidth() {
        return this.deltaHeight;
    }

    set deltaWidth(deltaWidth) {
        this.deltaHeight = deltaWidth;
    }

    setDeltaHeight(deltaHeight) {
        this.deltaHeight = deltaHeight;
        return this;
    }

    setDeltaWidth(deltaWidth) {
        this.deltaHeight = deltaWidth;
        return this;
    }

    get height() {
        if (this.scrollMode === 0) {
            return this.deltaHeight + this.parent.defaultCellHeight;
        } else {
            return this.parent.defaultCellWidth;
        }
    }

    set height(height) {
        // Only worked when scrollMode is 0
        if (this.scrollMode === 1) {
            return;
        }
        this.setDeltaHeight(height - this.parent.defaultCellHeight);
    }

    setHeight(height) {
        // Only worked when scrollMode is 0
        this.height = height;
        return this;
    }

    get width() {
        if (this.scrollMode === 0) {
            return this.parent.defaultCellWidth;
        } else {
            return this.deltaHeight + this.parent.defaultCellHeight;
        }
    }

    set width(width) {
        // Only worked when scrollMode is 1
        if (this.scrollMode === 0) {
            return;
        }
        this.setDeltaHeight(width - this.parent.defaultCellHeight);
    }

    setWidth(width) {
        this.width = width;
        return this;
    }

    get scene() {
        return this.parentContainer.scene;
    }
}

Object.assign(
    Cell.prototype,
    DataMethods
);

const GetValue$1M = Phaser.Utils.Objects.GetValue;
const SpliceOne = Phaser.Utils.Array.SpliceOne;

class Table {
    constructor(parent, config) {
        this.parent = parent; // parent: GridTable game object (Container)
        this.cells = [];
        this.cellPool = new Stack();
        this.resetFromJSON(config);
    }

    resetFromJSON(o) {
        this.colCount = undefined;
        this._nonZeroDeltaHeightCount = 0;
        this.resetTotalRowsHeight();
        this.setDefaultCellHeight(GetValue$1M(o, 'cellHeight', 30));
        this.setDefaultCellWidth(GetValue$1M(o, 'cellWidth', 30));
        this.initCells(GetValue$1M(o, 'cellsCount', 0));
        this.setColumnCount(GetValue$1M(o, 'columns', 1));
        return this;
    }

    destroy(fromScene) {
        // GridTable is destroyed, all cell containers will also be destroyed too
        // Don't have to freeCell
        this.cellPool.destroy();
        this.cells = undefined;
        this.parent = undefined;
    }

    get nonZeroDeltaHeightCount() {
        return this._nonZeroDeltaHeightCount;
    }

    set nonZeroDeltaHeightCount(count) {
        if (this._nonZeroDeltaHeightCount === count) {
            return;
        }
        this._nonZeroDeltaHeightCount = count;
        this.resetTotalRowsHeight();
    }

    get defaultCellHeightMode() {
        return (this.nonZeroDeltaHeightCount === 0);
    }

    setDefaultCellHeight(height) {
        this.defaultCellHeight = height;
        return this;
    }

    setDefaultCellWidth(width) {
        this.defaultCellWidth = width;
        return this;
    }

    initCells(size) {
        var cells = this.cells;
        cells.length = size;
        for (var i = 0; i < size; i++) {
            cells[i] = null;
        }
        return this;
    }

    insertNewCells(cellIdx, count) {
        var cells = this.cells;
        if (cellIdx === cells.length) {
            // append at end of array
            var endIdx = cellIdx + count;
            cells.legth = endIdx;
            for (var i = cellIdx; i < endIdx; i++) {
                cells[i] = null;
            }
        } else {
            var newCells = [];
            newCells.length = count;
            for (var i = 0; i < count; i++) {
                newCells[i] = null;
            }
            this.cells.splice(cellIdx, 0, ...newCells);
        }

        this.resetTotalRowsHeight();
        return this;
    }

    removeCells(cellIdx, count) {
        var endIdx = cellIdx + count;
        for (var i = cellIdx; i < endIdx; i++) {
            this.freeCell(i);
        }

        if (endIdx === this.cells.length) {
            // remove until end of array
            this.cells.length = cellIdx;
        } else {
            if (count === 1) {
                SpliceOne(this.cells, cellIdx);
            } else {
                this.cells.splice(cellIdx, count);
            }
            this.buildCellIndex(cellIdx);
        }

        this.resetTotalRowsHeight();
        return this;
    }

    setColumnCount(cnt) {
        this.colCount = cnt;
        this.resetTotalRowsHeight();
        return this;
    }

    get rowCount() {
        return Math.ceil(this.cells.length / this.colCount);
    }

    get cellsCount() {
        return this.cells.length;
    }

    isValidCellIdx(idx) {
        return ((idx >= 0) && (idx < this.cells.length));
    }

    heightToRowIndex(height, isCeil) {
        // defaultCellHeightMode
        if (this.defaultCellHeightMode) {
            var rowIdx = height / this.defaultCellHeight;
            if (isCeil) {
                rowIdx = Math.ceil(rowIdx);
            } else {
                rowIdx = Math.floor(rowIdx);
            }

            return rowIdx;
        }

        // count cell height one by one
        var rowCount = this.rowCount;
        var remainder = height,
            isValidIdx;
        var rowHeight, rowIdx = 0;

        while (1) {
            rowHeight = this.getRowHeight(rowIdx);
            remainder -= rowHeight;

            isValidIdx = (rowIdx >= 0) && (rowIdx < rowCount);
            if ((remainder > 0) && isValidIdx) {
                rowIdx += 1;
            } else if (remainder === 0) {
                return rowIdx;
            } else {
                if (isCeil) {
                    var preRowIdx = rowIdx;
                    rowIdx += 1;
                    isValidIdx = (rowIdx >= 0) && (rowIdx < rowCount);

                    if (!isValidIdx)
                        rowIdx = preRowIdx;
                }

                return rowIdx;
            }
        }

    }

    widthToColIndex(width, isCeil) {
        var colIdx = width / this.defaultCellWidth;
        if (isCeil) {
            colIdx = Math.ceil(colIdx);
        } else {
            colIdx = Math.floor(colIdx);
        }

        return colIdx;
    }

    colRowToCellIndex(colIdx, rowIdx) {
        if (colIdx >= this.colCount) {
            return null;
        }
        return (rowIdx * this.colCount) + colIdx;
    }

    rowIndexToHeight(start, end) {
        // defaultCellHeightMode
        if (this.defaultCellHeightMode) {
            return (end - start + 1) * this.defaultCellHeight;
        }

        var h, sum = 0;
        for (var i = start; i <= end; i++) {
            h = this.getRowHeight(i);
            sum += h;
        }

        return sum;
    }

    colIndexToWidth(start, end) {
        return (end - start + 1) * this.defaultCellWidth;
    };

    getRowHeight(rowIdx) {
        var cnt = this.colCount;
        // single column
        if (cnt <= 1) {
            return this.getCellHeight(this.colRowToCellIndex(0, rowIdx));
        }

        // multiple columns, get the maximum height
        var maxHeight = 0,
            cellHeight;
        for (var i = 0; i < cnt; i++) {
            cellHeight = this.getCellHeight(this.colRowToCellIndex(i, rowIdx));
            if (maxHeight < cellHeight)
                maxHeight = cellHeight;
        }
        return maxHeight;
    }

    getColWidth(idx) {
        return this.defaultCellWidth;
    }

    getCellHeight(cellIdx) {
        if (!this.isValidCellIdx(cellIdx)) {
            return 0;
        }

        var cellHeight;
        if (this.defaultCellHeightMode)
            cellHeight = this.defaultCellHeight;
        else {
            var cell = this.getCell(cellIdx, false);
            var deltaHeight = (cell) ? cell.deltaHeight : 0;
            cellHeight = this.defaultCellHeight + deltaHeight;
        }

        return cellHeight;
    }

    resetTotalRowsHeight() {
        this._totalRowsHeight = null;
    }

    get totalRowsHeight() {
        if (this._totalRowsHeight === null) {
            this._totalRowsHeight = this.rowIndexToHeight(0, this.rowCount - 1);
        }

        return this._totalRowsHeight;
    }

    get totalColumnWidth() {
        return this.colCount * this.defaultCellWidth;
    }

    cellIndxeToColIndex(cellIdx) {
        return cellIdx % this.colCount;
    }

    cellIndxeToRowIndex(cellIdx) {
        return Math.floor(cellIdx / this.colCount);
    }

    getCell(cellIdx, createNewCell) {
        if (!this.isValidCellIdx(cellIdx)) {
            return null;
        }

        if (createNewCell === undefined) {
            createNewCell = true;
        }
        if ((this.cells[cellIdx] === null) && createNewCell) {
            var cell = this.newCell(cellIdx);
            this.cells[cellIdx] = cell;
        }

        return this.cells[cellIdx];
    }

    newCell(cellIdx) {
        var cell = this.cellPool.pop();
        if (cell === null) {
            cell = new Cell(this);
        } else {
            cell.setParent(this);
        }
        cell.index = cellIdx;

        return cell;
    }

    buildCellIndex(startIdx) {
        if (startIdx === undefined) {
            startIdx = 0;
        }
        var cells = this.cells,
            cell;
        for (var i = startIdx, len = cells.length; i < len; i++) {
            cell = cells[i];
            if (cell) {
                cell.index = i;
            }
        }
        return this;
    }

    getParentContainer() {
        return this.parent;
    }

    freeCell(cell) {
        if (typeof (cell) === 'number') {
            cell = this.cells[cell];
        }

        if (!cell) {
            return this;
        }

        cell.destroy();
        this.cellPool.push(cell);
        return this;
    }
}

var MaskToGameObject = function (mask) {
    return (mask.hasOwnProperty('geometryMask')) ? mask.geometryMask : mask.bitmapMask;
};

var SetTableOY = function (oy) {
    var table = this.table;
    var topTableOY = this.topTableOY;
    var bottomTableOY = this.bottomTableOY;
    var tableOYExceedTop = (oy > this.topTableOY);
    var tableOYExeceedBottom = (oy < this.bottomTableOY);
    if (this.clampTableOXY) {
        var rowCount = table.rowCount;
        var visibleRowCount = table.heightToRowIndex(this.instHeight, true);

        // less then 1 page            
        if (rowCount < visibleRowCount) {
            oy = 0;
        } else if (tableOYExceedTop) {
            oy = topTableOY;
        } else if (tableOYExeceedBottom) {
            oy = bottomTableOY;
        }
    }

    if (this._tableOY !== oy) {
        this._tableOY = oy;
    }


    if (tableOYExceedTop) {
        if (!this.execeedTopState) {
            this.emit('execeedtop', this, oy, topTableOY);
        }
    }
    this.execeedTopState = tableOYExceedTop;

    if (tableOYExeceedBottom) {
        if (!this.execeedBottomState) {
            this.emit('execeedbottom', this, oy, bottomTableOY);
        }
    }
    this.execeedBottomState = tableOYExeceedBottom;
    return this;
};

var SetTableOX = function (ox) {
    var table = this.table;
    var leftTableOX = this.leftTableOX;
    var rightTableOX = this.rightTableOX;
    var tableOXExeceedLeft = (ox > this.leftTableOX);
    var tableOXExeceedRight = (ox < this.rightTableOX);
    if (this.clampTableOXY) {
        var colCount = table.colCount;
        var visibleColCount = table.widthToColIndex(this.instWidth, true);

        // less then 1 page            
        if (colCount < visibleColCount) {
            ox = 0;
        } else if (tableOXExeceedLeft) {
            ox = leftTableOX;
        } else {
            // var tableVisibleWidth = this.tableVisibleWidth;
            if (tableOXExeceedRight)
                ox = rightTableOX;
        }
    }

    if (this._tableOX !== ox) {
        this._tableOX = ox;
    }

    if (tableOXExeceedLeft) {
        if (!this.execeedLeftState) {
            this.emit('execeedleft', this, ox, leftTableOX);
        }
    }
    this.execeedLeftState = tableOXExeceedLeft;

    if (tableOXExeceedRight) {
        if (!this.execeedRightState) {
            this.emit('execeedright', this, ox, rightTableOX);
        }
    }
    this.execeedRightState = tableOXExeceedRight;
    return this;
};

const Intersects = Phaser.Geom.Intersects.RectangleToRectangle;
const Overlaps = Phaser.Geom.Rectangle.Overlaps;

var MaskChildren = function (parent, mask, children) {
    if (!mask) {
        return;
    }

    if (children === undefined) {
        children = parent.getAllChildren();
    }

    var parentBounds = parent.getBounds();
    var maskGameObject = MaskToGameObject(mask);

    var child, childBounds, visiblePointsNumber;
    for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];
        if (child.hasOwnProperty('isRexContainerLite')) {
            continue;
        }
        if (child === maskGameObject) {
            continue;
        }
        if (!isVisible(child)) {  // Child is invisible before masking
            continue;
        }

        if (child.getBounds) {
            childBounds = child.getBounds(childBounds);
            visiblePointsNumber = containsPoints(parentBounds, childBounds);
            switch (visiblePointsNumber) {
                case 4: // 4 points are all inside visible window, set visible
                    showAll(parent, child);
                    break;
                case 0: // No point is inside visible window
                    // Parent intersects with child, or parent is inside child, set visible, and apply mask
                    if (Intersects(parentBounds, childBounds) || Overlaps(parentBounds, childBounds)) {
                        showSome(parent, child, mask);
                    } else { // Set invisible
                        showNone(parent, child);
                    }
                    break;
                default: // Part of points are inside visible window, set visible, and apply mask
                    showSome(parent, child, mask);
                    break;
            }
        } else {
            showSome(parent, child, mask);
        }
    }
};

var isVisible = function (gameObject) {
    while (1) {
        var localState = gameObject.rexContainer;
        if (!localState) { // Top game object
            return gameObject.visible;
        } else if (localState.visible) {
            var parent = localState.parent;
            if (parent) { // Test parent's visible
                gameObject = parent;
                continue;
            } else { // Top visible game object
                return true;
            }
        } else { // Current game object is invisible
            return false;
        }
    }
};

var containsPoints = function (rectA, rectB) {
    var result = 0;
    var top = rectB.top,
        bottom = rectB.bottom,
        left = rectB.left,
        right = rectB.right;
    result += rectA.contains(left, top) ? 1 : 0;
    result += rectA.contains(left, bottom) ? 1 : 0;
    result += rectA.contains(right, top) ? 1 : 0;
    result += rectA.contains(right, bottom) ? 1 : 0;
    return result;
};

var showAll = function (parent, child, mask) {
    parent.setChildMaskVisible(child, true);
    if (child.clearMask) {
        child.clearMask();
    }
};

var showSome = function (parent, child, mask) {
    parent.setChildMaskVisible(child, true);
    if (child.setMask) {
        child.setMask(mask);
    }
};

var showNone = function (parent, child, mask) {
    parent.setChildMaskVisible(child, false);
    if (child.clearMask) {
        child.clearMask();
    }
};

var MaskCells = function () {
    if (!this.cellsMask) {
        // No cellsMask
        return this;
    } else if (!this.maskCellsFlag) {
        // No maskCells flag
        return this;
    } else if  ((this.alpha === 0) || (!this.visible)) {
        // Grid table is not visible
        return this;
    }

    var children = [];
    var cells = this.visibleCells.entries, container;
    for (var i = 0, cnt = cells.length; i < cnt; i++) {
        container = cells[i].getContainer();
        if (container) {
            if (container.hasOwnProperty('isRexContainerLite')) { // ContainerLite
                container.getAllChildren(children);
            } else { // Others
                children.push(container);
            }
        }
    }
    MaskChildren(this, this.cellsMask, children);

    if (this.maskUpdateMode === 0) {
        this.maskCellsFlag = false;
    }
    return this;
};

var HideCell = function (cell) {
    // Option: pop container of cell by cell.popContainer() under this event 
    this.emit('cellinvisible', cell);

    if (this.cellContainersPool) {
        var cellContainer = cell.popContainer(); // null if already been removed
        if (cellContainer) {
            this.cellContainersPool.killAndHide(cellContainer);
        }
    }

    cell.destroyContainer(); // Destroy container of cell
};

var HideCells = function () {
    var preList = this.preVisibleCells;
    var curList = this.visibleCells;
    preList.iterate(function (cell) {
        if (!curList.contains(cell)) {
            HideCell.call(this, cell);
        }
    }, this);
};

var ShowCell = function (cell) {
    // Attach container to cell by cell.setContainer(container) under this event
    var reusedCellContainer = null;
    var cellContainer = cell.getContainer();
    if (cellContainer) {
        reusedCellContainer = cellContainer;
        cell.popContainer();
    } else if (this.cellContainersPool) {
        reusedCellContainer = this.cellContainersPool.getFirstDead();
        if (reusedCellContainer !== null) { // Reuse this game object
            reusedCellContainer.setActive(true).setVisible(true);
        }
    }

    this.emit('cellvisible', cell, reusedCellContainer, this);

    if (this.cellContainersPool) {
        var cellContainer = cell.getContainer();
        if (cellContainer) {
            if (reusedCellContainer === null) {
                this.cellContainersPool.add(cellContainer); // New cell container, add to pool
            } else if (reusedCellContainer !== cellContainer) {
                // Why reusedCellContainer is not equal to cellContainer?
                this.cellContainersPool.add(cellContainer); // New cell container, add to pool
                this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
            }
        } else { // No cell container added
            if (reusedCellContainer !== null) {
                this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
            }
        }
    }
};

var ShowCells = function () {
    if (this.cellsCount === 0) {
        return;
    }
    var table = this.table;

    var startRowIdx = table.heightToRowIndex(-this.tableOY);
    if (startRowIdx <= 0) {
        startRowIdx = 0;  //Turn -0 to 0
    }
    var rowIdx = startRowIdx;

    var startColIdx = table.widthToColIndex(-this.tableOX);
    if (startColIdx <= 0) {
        startColIdx = 0;  //Turn -0 to 0
    }
    var colIdx = startColIdx;

    var cellIdx = table.colRowToCellIndex(colIdx, rowIdx);
    var bottomBound = this.bottomBound;
    var rightBound = this.rightBound;
    var lastIdx = table.cellsCount - 1;
    var lastColIdx = table.colCount - 1;

    var startCellTLX = GetCellTLX.call(this, colIdx),
        cellTLX = startCellTLX;
    var cellTLY = GetCellTLY.call(this, rowIdx);
    while ((cellTLY < bottomBound) && (cellIdx <= lastIdx)) {
        if (this.table.isValidCellIdx(cellIdx)) {
            var cell = table.getCell(cellIdx, true);
            this.visibleCells.set(cell);
            if (!this.preVisibleCells.contains(cell)) {
                ShowCell.call(this, cell);
            }
            if (this.scrollMode === 0) {
                cell.setXY(cellTLX, cellTLY);
            } else {
                cell.setXY(cellTLY, cellTLX);
            }
        }

        if ((cellTLX < rightBound) && (colIdx < lastColIdx)) {
            cellTLX += table.getColWidth(colIdx);
            colIdx += 1;
        } else {
            cellTLX = startCellTLX;
            cellTLY += table.getRowHeight(rowIdx);

            colIdx = startColIdx;
            rowIdx += 1;
        }

        cellIdx = table.colRowToCellIndex(colIdx, rowIdx);
    }
};

var GetCellTLX = function (colIdx) {
    var ox = (this.scrollMode === 0) ? this.topLeftX : this.topLeftY;
    var x = this.tableOX + this.table.colIndexToWidth(0, colIdx - 1) + ox;
    return x;
};

var GetCellTLY = function (rowIdx) {
    var oy = (this.scrollMode === 0) ? this.topLeftY : this.topLeftX;
    var y = this.tableOY + this.table.rowIndexToHeight(0, rowIdx - 1) + oy;
    return y;
};

var UpdateTable = function (refresh) {
    if (refresh === undefined) {
        refresh = false;
    }
    if (refresh) {
        ClearVisibleCellIndexes.call(this);
        HideCells.call(this);
    }
    ClearVisibleCellIndexes.call(this);
    ShowCells.call(this);
    HideCells.call(this);

    this.maskCellsFlag = true;
    return this;
};

var ClearVisibleCellIndexes = function () {
    var tmp = this.preVisibleCells;
    this.preVisibleCells = this.visibleCells;
    this.visibleCells = tmp;
    this.visibleCells.clear();
};

var IsCellVisible = function (cellIdx) {
    var cell = this.table.getCell(cellIdx, false);
    return cell && this.visibleCells.contains(cell);
};

var PointToCellIndex = function (x, y) {
    y -= (this.y + this.topLeftY);
    x -= (this.x + this.topLeftX);
    var offsetTableOY = this.tableOY - ((this.scrollMode === 0) ? y : x);
    var offsetTableOX = this.tableOX - ((this.scrollMode === 0) ? x : y);

    var table = this.table;
    var rowIdx = table.heightToRowIndex(-offsetTableOY);
    var colIdx = table.widthToColIndex(-offsetTableOX);
    var cellIdx = table.colRowToCellIndex(colIdx, rowIdx);
    if (cellIdx === null) {
        return null;
    }
    if (!this.isCellVisible(cellIdx)) {
        return null;
    }
    return cellIdx;
};

var PointToCellContainer = function (x, y) {
    var cellIdx = PointToCellIndex.call(this, x, y);
    if (cellIdx === null) {
        return undefined;
    }
    return this.getCellContainer(cellIdx);
};

// For when you know this Set will be modified during the iteration
var EachVisibleCell = function (callback, scope) {
    this.visibleCells.each(callback, scope);
    return this;
};

// For when you absolutely know this Set won't be modified during the iteration
var IterateVisibleCell = function (callback, scope) {
    this.visibleCells.iterate(callback, scope);
    return this;
};

var EachCell = function (callback, scope) {
    this.table.cells.slice().forEach(callback, scope);
    return this;
};

var IterateCell = function (callback, scope) {
    this.table.cells.forEach(callback, scope);
    return this;
};

var SetCellsCount = function (count) {
    var cellsCount = this.cellsCount;
    if (cellsCount === count) {
        return this;
    }

    if (cellsCount > count) {
        this.removeCells(count, cellsCount - count);
    } else { // cellsCount < count
        this.insertNewCells(cellsCount, count - cellsCount);
    }
    return this;
};

const Clamp$9 = Phaser.Math.Clamp;

var InsertNewCells = function (cellIdx, count) {
    if (typeof (cellIdx) === 'object') {
        cellIdx = cellIdx.index;
    }
    if (count === undefined) {
        count = 1;
    }
    if (count <= 0) {
        return this;
    }
    cellIdx = Clamp$9(cellIdx, 0, this.cellsCount);
    this.table.insertNewCells(cellIdx, count);
    return this;
};

var RemoveCells = function (cellIdx, count) {
    if (typeof (cellIdx) === 'object') {
        cellIdx = cellIdx.index;
    }
    if (count === undefined) {
        count = 1;
    }
    if (cellIdx < 0) {
        count += cellIdx;
        cellIdx = 0;
    }
    if (count <= 0) {
        return this;
    }
    // out-of-range
    if (cellIdx > this.cellsCount) {
        return this;
    }

    var cell;
    for (var i = cellIdx, endIdx = cellIdx + count; i < endIdx; i++) {
        cell = this.getCell(i, false);
        if (cell) {
            if (this.visibleCells.contains(cell)) {
                HideCell.call(this, cell);
                this.visibleCells.delete(cell);
            }
            this.preVisibleCells.delete(cell);
        }
    }

    this.table.removeCells(cellIdx, count);
    return this;
};

var SetColumnCount = function (count) {
    if (this.table.colCount === count) {
        return this;
    }
    this.table.setColumnCount(count);
    return this;
};

var SetGridSize = function (colCount, rowCount) {
    this.setCellsCount(colCount * rowCount);
    this.table.setColumnCount(colCount);
    return this;
};

var UpdateVisibleCell = function (cellIdx) {
    var cell = this.table.getCell(cellIdx, false);
    if (!cell || !cell.container) {
        return this;
    }

    ShowCell.call(this, cell);

    return this;
};

var Methods$5 = {
    setTableOY: SetTableOY,
    setTableOX: SetTableOX,
    maskCells: MaskCells,
    updateTable: UpdateTable,
    isCellVisible: IsCellVisible,
    pointToCellIndex: PointToCellIndex,
    pointToCellContainer: PointToCellContainer,
    eachVisibleCell: EachVisibleCell,
    iterateVisibleCell: IterateVisibleCell,
    eachCell: EachCell,
    iterateCell: IterateCell,

    setCellsCount: SetCellsCount,
    insertNewCells: InsertNewCells,
    removeCells: RemoveCells,
    setColumnCount: SetColumnCount,
    setGridSize: SetGridSize,
    updateVisibleCell: UpdateVisibleCell
};

const Group$1 = Phaser.GameObjects.Group;
const Components$3 = Phaser.GameObjects.Components;
const Set = Phaser.Structs.Set;
const GetValue$1N = Phaser.Utils.Objects.GetValue;

class GridTable extends ContainerLite {
    constructor(scene, x, y, width, height, config) {
        if (config === undefined) {
            config = {};
        }
        super(scene, x, y, width, height);
        this.type = 'rexGridTable';
        this._tableOX = 0;
        this._tableOY = 0;
        this.visibleCells = new Set();
        this.preVisibleCells = new Set();
        this.execeedTopState = false;
        this.execeedBottomState = false;
        this.execeedLeftState = false;
        this.execeedRightState = false;

        var reuseCellContainer = GetValue$1N(config, 'reuseCellContainer', false);
        if (reuseCellContainer) {
            this.cellContainersPool = new Group$1(scene); // Don't add Group into update list, I will destroy it manually
        }

        var callback = GetValue$1N(config, 'cellVisibleCallback', null);
        if (callback !== null) {
            var scope = GetValue$1N(config, 'cellVisibleCallbackScope', undefined);
            this.on('cellvisible', callback, scope);
        }
        callback = GetValue$1N(config, 'cellInvisibleCallback', null);
        if (callback !== null) {
            var scope = GetValue$1N(config, 'cellInvisibleCallbackScope', undefined);
            this.on('cellinvisible', callback, scope);
        }

        this.setCellsMask(GetValue$1N(config, 'mask', true));

        this.setScrollMode(GetValue$1N(config, 'scrollMode', 0));
        this.setClampMode(GetValue$1N(config, 'clamplTableOXY', true));

        // Pre-process cell size
        if (this.scrollMode === 0) { // scroll y
            var cellWidth = GetValue$1N(config, 'cellWidth', undefined);
            this.expandCellSize = (cellWidth === undefined);
            if (cellWidth === undefined) {
                var columns = GetValue$1N(config, 'columns', 1);
                config.cellWidth = this.width / columns;
            }
        } else { // scroll x
            // Swap cell width and cell height
            var cellWidth = GetValue$1N(config, 'cellHeight', undefined);
            var cellHeight = GetValue$1N(config, 'cellWidth', undefined);
            this.expandCellSize = (cellWidth === undefined);
            config.cellWidth = cellWidth;
            config.cellHeight = cellHeight;
        }
        this.table = new Table(this, config);

        this.updateTable();
    }

    destroy(fromScene) {  // preDestroy method does not have fromScene parameter
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        if (this.cellsMask) {
            this.scene.game.events.off('poststep', this.maskCells, this);
            this.cellsMask.destroy();
            this.cellsMask = undefined;
        }

        this.table.destroy(fromScene);
        this.table = undefined;
        if (this.cellContainersPool) {
            this.cellContainersPool.destroy(true);
            this.cellContainersPool = undefined;
        }

        super.destroy(fromScene);
    }

    setScrollMode(mode) {
        if (typeof (mode) === 'string') {
            mode = SCROLLMODE$1[mode.toLowerCase()];
        }
        this.scrollMode = mode;
        return this;
    }

    setClampMode(mode) {
        if (mode === undefined) {
            mode = true;
        }
        this.clampTableOXY = mode;
        return this;
    }

    get tableOY() {
        return this._tableOY;
    }

    get tableOX() {
        return this._tableOX;
    }

    set tableOY(oy) {
        this.setTableOY(oy).updateTable();
    }

    set tableOX(ox) {
        this.setTableOX(ox).updateTable();
    }

    setTableOXY(ox, oy) {
        this.setTableOY(oy).setTableOX(ox);
        return this;
    }

    addTableOY(dy) {
        this.setTableOY(this.tableOY + dy);
        return this;
    }

    addTableOX(dx) {
        this.setTableOX(this.tableOX + dx);
        return this;
    }

    addTableOXY(dx, dy) {
        this.addTableOY(dy).addTableOX(dx);
        return this;
    }

    setTableOYByPercentage(percentage) {
        this.setTableOY(-this.tableVisibleHeight * percentage);
        return this;
    }

    getTableOYPercentage() {
        var tableVisibleHeight = this.tableVisibleHeight;
        if (tableVisibleHeight === 0) {
            return 0;
        }
        return (this.tableOY / -tableVisibleHeight);
    }

    set t(value) {
        this.setTableOYByPercentage(value).updateTable();
    }

    get t() {
        return this.getTableOYPercentage();
    }

    getCell(cellIdx) {
        return this.table.getCell(cellIdx, true);
    }

    getCellContainer(cellIdx) {
        var cell = this.table.getCell(cellIdx, false);
        var container;
        if (cell) {
            container = cell.getContainer();
        }
        return container;
    }

    get cellsCount() {
        return this.table.cellsCount;
    }

    get columnCount() {
        return this.table.colCount;
    }

    setCellHeight(cellIdx, height) {
        var cell;
        if (typeof (cellIdx) === 'number') {
            cell = this.table.getCell(cellIdx, true);
        } else {
            cell = cellIdx;
        }
        cell.height = height; // Only worked when scrollMode is 0
        return this;
    }

    setCellWidth(cellIdx, width) {
        var cell;
        if (typeof (cellIdx) === 'number') {
            cell = this.table.getCell(cellIdx, true);
        } else {
            cell = cellIdx;
        }
        cell.width = width; // Only worked when scrollMode is 1
        return this;
    }

    setCellsMask(config) {
        var maskEnable, maskPadding, maskUpdateMode;
        if (config === true) {
            maskEnable = true;
            maskPadding = 0;
            maskUpdateMode = 0;
        } else if (config === false) {
            maskEnable = false;
        } else {
            maskEnable = GetValue$1N(config, 'mask', true);
            maskPadding = GetValue$1N(config, 'padding', 0);
            maskUpdateMode = GetValue$1N(config, 'updateMode', 0);
        }

        this.maskCellsFlag = true;
        this.maskUpdateMode = maskUpdateMode; // 0,1,undefined
        if (maskEnable) {
            var maskGameObject = new DefaultMaskGraphics(this, 0, maskPadding);
            this.cellsMask = maskGameObject.createGeometryMask();
            this.add(maskGameObject);
            if (typeof (maskUpdateMode) === 'string') {
                maskUpdateMode = MASKUPDATEMODE[maskUpdateMode];
            }
            this.scene.game.events.on('poststep', this.maskCells, this);
        }

        return this;
    }

    get instHeight() {
        return (this.scrollMode === 0) ? this.height : this.width;
    }

    get instWidth() {
        return (this.scrollMode === 0) ? this.width : this.height;
    }

    get tableHeight() {
        return this.table.totalRowsHeight;
    }

    get tableWidth() {
        return this.table.totalColumnWidth;
    }

    get topTableOY() {
        return 0;
    }

    get bottomTableOY() {
        return -this.tableVisibleHeight;
    }

    get leftTableOX() {
        return 0;
    }

    get rightTableOX() {
        return -this.tableVisibleWidth;
    }

    get tableVisibleHeight() {
        var h;
        var tableHeight = this.tableHeight;
        var instHeight = this.instHeight;
        if (tableHeight > instHeight) {
            h = tableHeight - instHeight;
        } else {
            h = 0;
        }

        return h;
    }

    get tableVisibleWidth() {
        var w;
        var tableWidth = this.tableWidth;
        var instWidth = this.instWidth;
        if (tableWidth > instWidth) {
            w = tableWidth - instWidth;
        } else {
            w = 0;
        }
        return w;
    };

    get bottomLeftY() {
        return -(this.displayHeight * this.originY) + this.displayHeight;
    }

    get topRightX() {
        return -(this.displayWidth * this.originX) + this.displayWidth;
    }

    get topLeftX() {
        return -(this.displayWidth * this.originX);
    }

    get topLeftY() {
        return -(this.displayHeight * this.originY)
    }

    get bottomBound() {
        if (this.scrollMode === 0) {
            return this.bottomLeftY;
        } else {
            return this.topRightX;
        }
    }

    get rightBound() {
        if (this.scrollMode === 0) {
            return this.topRightX;
        } else {
            return this.bottomLeftY;
        }
    }

    resize(width, height) {
        if ((this.width === width) && (this.height === height)) {
            return this;
        }

        super.resize(width, height);
        if (this.cellsMask) {
            ResizeGameObject(MaskToGameObject(this.cellsMask), width, height);
        }

        if (this.expandCellSize) {
            this.table.setDefaultCellWidth(this.instWidth / this.table.colCount);
        }
        this.updateTable(true);
        return this;
    }
}
// mixin
Object.assign(
    GridTable.prototype,
    Methods$5
);

const SCROLLMODE$1 = {
    v: 0,
    vertical: 0,
    h: 1,
    horizontal: 1
};

const MASKUPDATEMODE = {
    update: 0,
    everyTick: 1
};

var InjectProperties = function (table) {
    Object.defineProperty(table, 'childOY', {
        configurable: true,
        get: function () {
            return table.tableOY;
        },
        set: function (value) {
            table.tableOY = value;
        }
    });
    Object.defineProperty(table, 'topChildOY', {
        get: function () {
            return table.topTableOY;
        }
    });
    Object.defineProperty(table, 'bottomChildOY', {
        get: function () {
            return table.bottomTableOY;
        }
    });
};

var TableOnCellVisible = function (table) {
    table.on('cellvisible', function (cell, cellContainer, table) {
        var callback = this.createCellContainerCallback;
        var scope = this.createCellContainerCallbackScope;
        cell.item = this.items[cell.index];
        var cellContainer;
        if (scope) {
            cellContainer = callback.call(scope, cell, cellContainer, table);
        } else {
            cellContainer = callback(cell, cellContainer, table);
        }
        if (cellContainer) {
            if (cellContainer.setOrigin) {
                cellContainer.setOrigin(0);
            }
            if (cellContainer.isRexSizer) {
                cellContainer.layout(); // Use original size
            }
        }

        cell.item = undefined;
        cell.setContainer(cellContainer);
    }, this);
};

var EmitCellEvent = function (eventEmitter, eventName, table, x, y, pointer, event) {
    var cellIndex;
    if (y === undefined) {
        cellIndex = x;
    } else {
        cellIndex = table.pointToCellIndex(x, y);
    }
    if ((cellIndex === null) || (cellIndex === undefined)) {
        return;
    }
    var cellContainer = table.getCellContainer(cellIndex);
    if (cellContainer) {
        eventEmitter.emit(eventName, cellContainer, cellIndex, pointer, event);
    }
};

var PointerUpDownCell = function (table, tableConfig) {
    table
        .on('pointerdown', function (pointer, localX, localY, event) {
            EmitCellEvent(this.eventEmitter, 'cell.down', table, pointer.x, pointer.y, pointer, event);
        }, this)
        .on('pointerup', function (pointer, localX, localY, event) {
            EmitCellEvent(this.eventEmitter, 'cell.up', table, pointer.x, pointer.y, pointer, event);
        }, this);
};

var OverCell = function (table, tableConfig) {
    table
        .on('pointermove', OnMove, this)
        .on('pointerover', OnMove, this)
        .on('pointerout', OnOut, this);  // pointer-up is included too
};

var OnMove = function (pointer, localX, localY, event) {
    var table = this.childrenMap.child;
    var cellIndex = table.pointToCellIndex(pointer.x, pointer.y);
    if (cellIndex === table.input.lastOverCellIndex) {
        return;
    }

    var preCellIndex = table.input.lastOverCellIndex;
    table.input.lastOverCellIndex = cellIndex;
    EmitCellEvent(this.eventEmitter, 'cell.out', table, preCellIndex, undefined, pointer, event);
    EmitCellEvent(this.eventEmitter, 'cell.over', table, cellIndex, undefined, pointer, event);
};

var OnOut = function (pointer, event) {
    var table = this.childrenMap.child;
    var cellIndex = table.input.lastOverCellIndex;
    table.input.lastOverCellIndex = undefined;
    EmitCellEvent(this.eventEmitter, 'cell.out', table, cellIndex, undefined, pointer, event);
};

const GetValue$1O = Phaser.Utils.Objects.GetValue;

var ClickCell = function (table, tableConfig) {
    var buttonConfig = GetValue$1O(tableConfig, 'click', undefined);
    if (buttonConfig === false) {
        return;
    } else if (buttonConfig === undefined) {
        buttonConfig = {};
    }
    buttonConfig.threshold = 10;
    table._click = new Button(table, buttonConfig);
    table._click.on('click', function (button, gameObject, pointer, event) {
        EmitCellEvent(this.eventEmitter, 'cell.click', gameObject, pointer.x, pointer.y, pointer, event);
    }, this);
};

const GetValue$1P = Phaser.Utils.Objects.GetValue;

class OnePointerTracer extends TickTask {
    constructor(gameObject, config) {
        var scene = GetSceneObject(gameObject);
        if (scene === gameObject) {
            gameObject = undefined;
        }
        super(scene, config);

        this.gameObject = gameObject;
        if (gameObject) {
            gameObject.setInteractive(GetValue$1P(config, "inputConfig", undefined));
        }
        this._enable = undefined;
        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        this.setEnable(GetValue$1P(o, 'enable', true));

        this.setDetectBounds();
        if (this.gameObject === undefined) {
            this.setDetectBounds(GetValue$1P(o, 'bounds', undefined));
        } else {
            this.setDetectBounds();
        }

        this.tracerState = TOUCH0$1;
        // this.recongizedState = new stateClass(this);
        this.pointer = undefined;
        this.lastPointer = undefined; // Last catched pointer
        this.movedState = false;
        this.isTouchingAnyObject = false;
        return this;
    }

    boot() {
        super.boot();
        if (this.gameObject) {
            this.gameObject.on('pointerdown', this.onPointerDown, this);
        } else {
            this.scene.input.on('pointerdown', this.onPointerDown, this);
        }
        this.scene.input.on('pointerup', this.onPointerUp, this);
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.events.once('shutdown', this.destroy, this);
    }

    shutdown(fromScene) {
        if (!this.scene) {
            return
        }

        if (this.gameObject) ; else {
            this.scene.input.off('pointerdown', this.onPointerDown, this);
        }
        this.scene.input.off('pointerup', this.onPointerUp, this);
        this.scene.input.off('pointermove', this.onPointerMove, this);
        this.scene.events.off('shutdown', this.destroy, this);

        this.gameObject = undefined;
        this.bounds = undefined;
        this.pointer = undefined;
        this.lastPointer = undefined; // Last catched pointer
        this.movedState = false;

        super.shutdown(fromScene);
    }

    get enable() {
        return this._enable;
    }

    set enable(e) {
        if (this._enable === e) {
            return;
        }

        if (!e) {
            this.dragCancel();
        }
        this._enable = e;
        return this;
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }

        this.enable = e;
        return this;
    }

    setDetectBounds(bounds) {
        this.bounds = bounds;
        return this;
    }

    toggleEnable() {
        this.setEnable(!this.enable);
        return this;
    }

    onPointerDown(pointer, gameObjects) {
        if (!this.enable) {
            return;
        }

        if (this.pointer !== undefined) {
            return;
        }

        var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
        if (!isInsideBounds) {
            return;
        }

        if (this.pointer === pointer) {
            return;
        }

        this.pointer = pointer;
        this.lastPointer = pointer;
        this.movedState = false;
        this.tracerState = TOUCH1$1;

        if (this.gameObject === undefined) {
            this.isTouchingAnyObject = (gameObjects.length > 0);
        }
        this.onDragStart();
    }

    onPointerUp(pointer) {
        if (!this.enable) {
            return;
        }

        var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
        if (!isInsideBounds) {
            return;
        }

        if (this.pointer !== pointer) {
            return;
        }

        this.pointer = undefined;
        this.movedState = false;
        this.tracerState = TOUCH0$1;
        this.onDragEnd();
    }

    onPointerMove(pointer) {
        if (!this.enable) {
            return;
        }

        if (pointer.isDown) {
            var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
            var isCatchedPointer = (this.pointer === pointer);
            if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) { // Pointer moves out of bounds
                this.onPointerUp(pointer);
            } else { // Pointer drags in bounds
                if (!this.movedState) {
                    this.movedState = (pointer.x !== pointer.downX) || (pointer.y !== pointer.downY);
                }
                if (this.movedState) {
                    this.onDrag();
                }
            }
        }
    }

    dragCancel() {
        if (this.tracerState === TOUCH1$1) {
            this.onDragEnd();
        }
        this.pointer = undefined;
        this.tracerState = TOUCH0$1;
        return this;
    }

    onDragStart() {
        this.emit('dragstart', this);
    }

    onDragEnd() {
        this.emit('dragend', this);
    }

    onDrag() {
        this.emit('drag', this);
    }

    // onLastPointerMove() { }

    preUpdate(time, delta) { }

    postUpdate(time, delta) { }

    startTicking() {
        super.startTicking();
        this.scene.events.on('preupdate', this.preUpdate, this);
        this.scene.events.on('postupdate', this.postUpdate, this);
    }

    stopTicking() {
        super.stopTicking();
        if (this.scene) { // Scene might be destoryed
            this.scene.events.off('preupdate', this.preUpdate, this);
            this.scene.events.off('postupdate', this.postUpdate, this);
        }
    }

    setRecongizedStateObject(stateObject) {
        this.recongizedState = stateObject;
        return this;
    }

    get state() {
        return this.recongizedState.state;
    }

    set state(newState) {
        this.recongizedState.state = newState;
    }

    cancel() {
        this.state = IDLE$1;
        return this;
    }
}

const TOUCH0$1 = 0;
const TOUCH1$1 = 1;

const IDLE$1 = 'IDLE';

const GetValue$1Q = Phaser.Utils.Objects.GetValue;
const DistanceBetween$3 = Phaser.Math.Distance.Between;

class Tap extends OnePointerTracer {
    constructor(gameObject, config) {
        super(gameObject, config);

        var self = this;
        var stateConfig = {
            states: {
                IDLE: {
                    enter: function () {
                        self.stop();
                        self.tapsCount = 0;
                        self.x = 0;
                        self.y = 0;
                        self.worldX = 0;
                        self.worldY = 0;
                    },
                    exit: function () {
                        var pointer = self.lastPointer;
                        self.x = pointer.x;
                        self.y = pointer.y;
                        self.worldX = pointer.worldX;
                        self.worldY = pointer.worldY;
                    }
                },
                BEGIN: {
                    enter: function () {
                        self.start();
                        self.tapsCount = 0;
                        self.emit('tappingstart', self, self.gameObject, self.lastPointer);
                    },
                },
                RECOGNIZED: {
                    enter: function () {
                        self.start();
                        self.emit('tap', self, self.gameObject, self.lastPointer);
                        self.emit(`${self.tapsCount}tap`, self, self.gameObject, self.lastPointer);
                    },
                }
            },
            init: function () {
                this.state = IDLE$2;
            },
            eventEmitter: false,
        };
        this.setRecongizedStateObject(new FSM(stateConfig));
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);
        this.setHoldTime(GetValue$1Q(o, 'time', 250)); // min-hold-time of Press is 251
        this.setTapInterval(GetValue$1Q(o, 'tapInterval', 200));
        this.setDragThreshold(GetValue$1Q(o, 'threshold', 9));
        this.setTapOffset(GetValue$1Q(o, 'tapOffset', 10));

        var taps = GetValue$1Q(o, 'taps', undefined);
        if (taps !== undefined) {
            this.setTaps(taps);
        } else {
            this.setMaxTaps(GetValue$1Q(o, 'maxTaps', undefined));
            this.setMinTaps(GetValue$1Q(o, 'minTaps', undefined));
        }
        return this;
    }

    onDragStart() {
        switch (this.state) {
            case IDLE$2:
                this.state = BEGIN;
                break;

            case BEGIN:
                var pointer = this.lastPointer;
                var tapsOffset = DistanceBetween$3(
                    pointer.upX,
                    pointer.upY,
                    pointer.x,
                    pointer.y);
                if (tapsOffset > this.tapOffset) { // Can't recognize next level, restart here
                    this.state = RECOGNIZED;
                    this.state = BEGIN;
                }
                break;

            case RECOGNIZED:
                this.state = BEGIN;
                break;
        }
    }

    onDragEnd() {
        if (this.state === BEGIN) {
            this.tapsCount++; // Try recognize next level
            this.emit('tapping', this, this.gameObject, this.lastPointer);

            if ((this.maxTaps !== undefined) && (this.tapsCount === this.maxTaps)) { // Reach to maxTaps, stop here                
                this.state = RECOGNIZED;
            }
        }
    }

    onDrag() {
        if (this.state === IDLE$2) {
            return;
        }

        if (this.pointer.getDistance() > this.dragThreshold) { // Cancel
            this.state = IDLE$2;
        }
    }

    preUpdate(time, delta) {
        if ((!this.isRunning) || (!this.enable)) {
            return;
        }
        if (this.state === BEGIN) {
            var pointer = this.lastPointer;
            if (pointer.isDown) {
                var holdTime = time - pointer.downTime;
                if (holdTime > this.holdTime) {
                    this.state = IDLE$2;
                }
            } else { // isUp
                var releasedTime = time - pointer.upTime;
                if (releasedTime > this.tapInterval) {
                    if ((this.minTaps === undefined) || (this.tapsCount >= this.minTaps)) {
                        this.state = RECOGNIZED;
                    } else {
                        this.state = IDLE$2;
                    }
                }
            }
        }
    }

    postUpdate(time, delta) {
        if ((!this.isRunning) || (!this.enable)) {
            return;
        }
        // Clear RECOGNIZED after update()
        if (this.state === RECOGNIZED) {
            this.state = IDLE$2;
        }
    }

    get isTapped() {
        return (this.state === RECOGNIZED);
    }

    setHoldTime(time) {
        this.holdTime = time; // ms
        return this;
    }

    setTapInterval(time) {
        this.tapInterval = time; // ms
        return this;
    }

    setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
    }

    setTapOffset(distance) {
        this.tapOffset = distance;
        return this;
    }

    setMaxTaps(taps) {
        this.maxTaps = taps;
        return this;
    }

    setMinTaps(taps) {
        this.minTaps = taps;
        return this;
    }

    setTaps(minTaps, maxTaps) {
        if (maxTaps === undefined) {
            maxTaps = minTaps;
        }
        this.setMinTaps(minTaps).setMaxTaps(maxTaps);
        return this;
    }
}

const IDLE$2 = 'IDLE';
const BEGIN = 'BEGIN';
const RECOGNIZED = 'RECOGNIZED';

const GetValue$1R = Phaser.Utils.Objects.GetValue;

class Press extends OnePointerTracer {
    constructor(gameObject, config) {
        super(gameObject, config);

        var self = this;
        var stateConfig = {
            states: {
                IDLE: {
                    enter: function () {
                        self.x = 0;
                        self.y = 0;
                        self.worldX = 0;
                        self.worldY = 0;
                    },
                    exit: function () {
                        var pointer = self.lastPointer;
                        self.x = pointer.x;
                        self.y = pointer.y;
                        self.worldX = pointer.worldX;
                        self.worldY = pointer.worldY;
                    }
                },
                BEGIN: {
                    enter: function () {
                        self.start();
                    },
                    exit: function () {
                        self.stop();
                    }
                },
                RECOGNIZED: {
                    enter: function () {
                        self.emit('pressstart', self, self.gameObject, self.lastPointer);
                    },
                    exit: function () {
                        self.emit('pressend', self, self.gameObject, self.lastPointer);
                    }
                }
            },
            init: function () {
                this.state = IDLE$3;
            },
            eventEmitter: false,
        };
        this.setRecongizedStateObject(new FSM(stateConfig));
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);
        this.setDragThreshold(GetValue$1R(o, 'threshold', 9));
        this.setHoldTime(GetValue$1R(o, 'time', 251));
        return this;
    }

    onDragStart() {
        this.state = BEGIN$1;
        if (this.holdTime === 0) {
            this.state = RECOGNIZED$1;
        }
    }

    onDragEnd() {
        this.state = IDLE$3;
    }

    onDrag() {
        if (this.state === IDLE$3) {
            return;
        }

        if (this.pointer.getDistance() > this.dragThreshold) {
            this.state = IDLE$3;
        }
    }

    preUpdate(time, delta) {
        if ((!this.isRunning) || (!this.enable)) {
            return;
        }
        if (this.state === BEGIN$1) {
            var holdTime = time - this.pointer.downTime;
            if (holdTime >= this.holdTime) {
                this.state = RECOGNIZED$1;
            }
        }
    }

    get isPressed() {
        return (this.state === RECOGNIZED$1);
    }

    setHoldTime(time) {
        this.holdTime = time; // ms
        return this;
    }

    setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
    }
}

const IDLE$3 = 'IDLE';
const BEGIN$1 = 'BEGIN';
const RECOGNIZED$1 = 'RECOGNIZED';

const GetValue$1S = Phaser.Utils.Objects.GetValue;

class Pan extends OnePointerTracer {
    constructor(gameObject, config) {
        super(gameObject, config);

        var self = this;
        var stateConfig = {
            states: {
                IDLE: {
                },
                BEGIN: {
                    enter: function () {
                        var pointer = self.pointer;
                        self.startX = pointer.x;
                        self.startY = pointer.y;
                        self.startWorldX = pointer.worldX;
                        self.startWorldY = pointer.worldY;
                    }
                },
                RECOGNIZED: {
                    enter: function () {
                        self.emit('panstart', self, self.gameObject, self.lastPointer);
                    },
                    exit: function () {
                        var pointer = self.lastPointer;
                        self.endX = pointer.x;
                        self.endY = pointer.y;
                        self.endWorldX = pointer.worldX;
                        self.endWorldY = pointer.worldY;
                        self.emit('panend', self, self.gameObject, self.lastPointer);
                    }
                }
            },
            init: function () {
                this.state = IDLE$4;
            },
            eventEmitter: false,
        };
        this.setRecongizedStateObject(new FSM(stateConfig));
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);
        this.setDragThreshold(GetValue$1S(o, 'threshold', 10));
        return this;
    }

    onDragStart() {
        this.state = BEGIN$2;
        if (this.dragThreshold === 0) {
            this.state = RECOGNIZED$2;
        }
    }

    onDragEnd() {
        this.state = IDLE$4;
    }

    onDrag() {
        switch (this.state) {
            case BEGIN$2:
                if (this.pointer.getDistance() >= this.dragThreshold) {
                    this.state = RECOGNIZED$2;
                }
                break;

            case RECOGNIZED$2:
                var p1 = this.pointer.position;
                var p0 = this.pointer.prevPosition;
                this.dx = p1.x - p0.x;
                this.dy = p1.y - p0.y;
                var pointer = this.pointer;
                this.x = pointer.x;
                this.y = pointer.y;
                this.worldX = pointer.worldX;
                this.worldY = pointer.worldY;
                this.emit('pan', this, this.gameObject, this.lastPointer);
                break;
        }
    }

    get isPanned() {
        return (this.state === RECOGNIZED$2);
    }

    setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
    }
}

const IDLE$4 = 'IDLE';
const BEGIN$2 = 'BEGIN';
const RECOGNIZED$2 = 'RECOGNIZED';

const DistanceBetween$4 = Phaser.Math.Distance.Between;
const AngleBetween = Phaser.Math.Angle.Between;

var VelocityMethods = {
    getDt: function () {
        var game = this.scene.sys.game;
        var dt = game.loop.delta;
        return dt;
    },

    getVelocity: function () {
        var p1 = this.pointer.position;
        var p0 = this.pointer.prevPosition;
        var d = DistanceBetween$4(p0.x, p0.y, p1.x, p1.y);
        var velocity = d / (this.getDt() * 0.001);
        return velocity;
    },

    getVelocityX: function () {
        var p1 = this.pointer.position;
        var p0 = this.pointer.prevPosition;
        var d = Math.abs(p1.x - p0.x);
        var velocity = d / (this.getDt() * 0.001);
        return velocity;
    },

    getVelocityY: function () {
        var p1 = this.pointer.position;
        var p0 = this.pointer.prevPosition;
        var d = Math.abs(p1.y - p0.y);
        var velocity = d / (this.getDt() * 0.001);
        return velocity;
    },

    getVelocityAngle: function () {
        var p1 = this.pointer.position;
        var p0 = this.pointer.prevPosition;
        var angle = AngleBetween(p0.x, p0.y, p1.x, p1.y);
        return angle;
    }
};

var DIRMODE = {
    'up&down': 0,
    'left&right': 1,
    '4dir': 2,
    '8dir': 3
};

var AngleToDirections = function (angle, dirMode, out) {
    if (out === undefined) {
        out = {};
    } else if (out === true) {
        out = globOut;
    }

    out.left = false;
    out.right = false;
    out.up = false;
    out.down = false;

    angle = (angle + 360) % 360;
    switch (dirMode) {
        case 0: // up & down
            if (angle < 180) {
                out.down = true;
            } else {
                out.up = true;
            }
            break;

        case 1: // left & right
            if ((angle > 90) && (angle <= 270)) {
                out.left = true;
            } else {
                out.right = true;
            }
            break;

        case 2: // 4 dir
            if ((angle > 45) && (angle <= 135)) {
                out.down = true;
            } else if ((angle > 135) && (angle <= 225)) {
                out.left = true;
            } else if ((angle > 225) && (angle <= 315)) {
                out.up = true;
            } else {
                out.right = true;
            }
            break;

        case 3: // 8 dir
            if ((angle > 22.5) && (angle <= 67.5)) {
                out.down = true;
                out.right = true;
            } else if ((angle > 67.5) && (angle <= 112.5)) {
                out.down = true;
            } else if ((angle > 112.5) && (angle <= 157.5)) {
                out.down = true;
                out.left = true;
            } else if ((angle > 157.5) && (angle <= 202.5)) {
                out.left = true;
            } else if ((angle > 202.5) && (angle <= 247.5)) {
                out.left = true;
                out.up = true;
            } else if ((angle > 247.5) && (angle <= 292.5)) {
                out.up = true;
            } else if ((angle > 292.5) && (angle <= 337.5)) {
                out.up = true;
                out.right = true;
            } else {
                out.right = true;
            }
            break;
    }

    return out;
};

var globOut = {};

const GetValue$1T = Phaser.Utils.Objects.GetValue;
const RadToDeg$3 = Phaser.Math.RadToDeg;

class Swipe extends OnePointerTracer {
    constructor(gameObject, config) {
        super(gameObject, config);

        var self = this;
        var stateConfig = {
            states: {
                IDLE: {
                    enter: function () {
                        self.x = 0;
                        self.y = 0;
                        self.worldX = 0;
                        self.worldY = 0;
                    },
                    exit: function () {
                        var pointer = self.lastPointer;
                        self.x = pointer.x;
                        self.y = pointer.y;
                        self.worldX = pointer.worldX;
                        self.worldY = pointer.worldY;
                    }
                },
                BEGIN: {
                    enter: function () {
                        self.validDrag = false;
                    }
                },
                RECOGNIZED: {
                    enter: function () {
                        self.start();
                        self.updateDirectionStates();
                        self.emit('swipe', self, self.gameObject, self.lastPointer);
                    },

                    exit: function () {
                        self.stop();
                        self.clearDirectionStates();
                    }
                }
            },
            init: function () {
                this.state = IDLE$5;
            },
            eventEmitter: false,
        };
        this.setRecongizedStateObject(new FSM(stateConfig));
        this.clearDirectionStates();
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);
        this.setDragThreshold(GetValue$1T(o, 'threshold', 10));
        this.setVelocityThreshold(GetValue$1T(o, 'velocityThreshold', 1000));
        this.setDirectionMode(GetValue$1T(o, 'dir', '8dir'));
        return this;
    }

    onDragStart() {
        this.state = BEGIN$3;
    }

    onDragEnd() {
        this.state = IDLE$5;
    }

    onDrag() {
        if (this.state === BEGIN$3) {
            if (!this.validDrag) {
                this.validDrag = (this.dragThreshold === 0) || (this.pointer.getDistance() >= this.dragThreshold);
            }
            if (this.validDrag && (this.dragVelocity > this.velocityThreshold)) {
                this.state = RECOGNIZED$3;
            }
        }
    }

    postUpdate(time, delta) {
        if ((!this.isRunning) || (!this.enable)) {
            return;
        }
        // Clear RECOGNIZED after update()
        if (this.state === RECOGNIZED$3) {
            this.state = IDLE$5;
        }
    }

    get isSwiped() {
        return (this.state === RECOGNIZED$3);
    }

    get dragVelocity() {
        var velocity;
        switch (this.dirMode) {
            case 0: velocity = this.getVelocityY(); break; // up & down
            case 1: velocity = this.getVelocityX(); break; // left & right
            default: velocity = this.getVelocity(); break; // 4 dir, 8 dir
        }
        return velocity;
    }

    setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
    }

    setVelocityThreshold(velocity) {
        this.velocityThreshold = velocity;
        return this;
    }

    setDirectionMode(m) {
        if (typeof (m) === 'string') {
            m = DIRMODE[m];
        }
        this.dirMode = m;
        return this;
    }

    updateDirectionStates() {
        var angle = RadToDeg$3(this.getVelocityAngle());
        AngleToDirections(angle, this.dirMode, this);
        return this;
    }

    clearDirectionStates() {
        this.left = false;
        this.right = false;
        this.up = false;
        this.down = false;
        return this;
    }
}

Object.assign(
    Swipe.prototype,
    VelocityMethods
);

const IDLE$5 = 'IDLE';
const BEGIN$3 = 'BEGIN';
const RECOGNIZED$3 = 'RECOGNIZED';

const GetValue$1U = Phaser.Utils.Objects.GetValue;
const SpliceOne$1 = Phaser.Utils.Array.SpliceOne;
const DistanceBetween$5 = Phaser.Math.Distance.Between;
const AngleBetween$1 = Phaser.Math.Angle.Between;

class TwoPointersTracer {
    constructor(scene, config) {
        var amount = scene.input.manager.pointersTotal - 1;
        if (amount < 2) {
            scene.input.addPointer(2 - amount);
        }

        this.scene = scene;
        // Event emitter
        this.setEventEmitter(GetValue$1U(config, 'eventEmitter', undefined));

        this._enable = undefined;
        this.pointers = [];
        this.movedState = {};
        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        this.setEnable(GetValue$1U(o, "enable", true));
        this.bounds = GetValue$1U(o, 'bounds', undefined);

        this.tracerState = TOUCH0$2;
        this.pointers.length = 0;
        Clear(this.movedState);
        return this;
    }

    boot() {
        this.scene.input.on('pointerdown', this.onPointerDown, this);
        this.scene.input.on('pointerup', this.onPointerUp, this);
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.events.once('shutdown', this.destroy, this);
    }

    shutdown() {
        if (!this.scene) {
            return
        }

        this.destroyEventEmitter();
        this.pointers.length = 0;
        Clear(this.movedState);
        this.scene.input.off('pointerdown', this.onPointerDown, this);
        this.scene.input.off('pointerup', this.onPointerUp, this);
        this.scene.input.off('pointermove', this.onPointerMove, this);
        this.scene.events.off('shutdown', this.destroy, this);
        this.scene = undefined;
    }

    destroy() {
        this.shutdown();
    }

    get enable() {
        return this._enable;
    }

    set enable(e) {
        if (this._enable === e) {
            return;
        }

        if (!e) {
            this.dragCancel();
        }
        this._enable = e;
        return this;
    }

    setEnable(e) {
        if (e === undefined) {
            e = true;
        }

        this.enable = e;
        return this;
    }

    toggleEnable() {
        this.setEnable(!this.enable);
        return this;
    }

    onPointerDown(pointer) {
        if (!this.enable) {
            return;
        }

        if (this.pointers.length === 2) {
            return;
        }

        var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
        if (!isInsideBounds) {
            return;
        }

        var index = this.pointers.indexOf(pointer);
        if (index !== -1) { // Already in catched pointers
            return;
        }

        this.movedState[pointer.id] = false;
        this.pointers.push(pointer);

        switch (this.tracerState) {
            case TOUCH0$2:
                this.tracerState = TOUCH1$2;
                this.onDrag1Start();
                break;
            case TOUCH1$2:
                this.tracerState = TOUCH2;
                this.onDrag2Start();
                break;
        }
    }

    onPointerUp(pointer) {
        if (!this.enable) {
            return;
        }

        var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
        if (!isInsideBounds) {
            return;
        }

        var index = this.pointers.indexOf(pointer);
        if (index === -1) { // Not in catched pointers
            return;
        } else {
            delete this.movedState[pointer.id];
            SpliceOne$1(this.pointers, index);
        }

        switch (this.tracerState) {
            case TOUCH1$2:
                this.tracerState = TOUCH0$2;
                this.onDrag1End();
                break;
            case TOUCH2:
                this.tracerState = TOUCH1$2;
                this.onDrag2End();
                this.onDrag1Start();
                break;
        }
    }

    onPointerMove(pointer) {
        if (!this.enable) {
            return;
        }

        if (pointer.isDown) {
            var isInsideBounds = (this.bounds) ? this.bounds.contains(pointer.x, pointer.y) : true;
            var isCatchedPointer = (this.pointers.indexOf(pointer) !== -1);
            if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) { // Pointer moves out of bounds, lose pointer
                this.onPointerUp(pointer);
            } else {  // Pointer drags in bounds
                if (!this.movedState[pointer.id]) {
                    this.movedState[pointer.id] = (pointer.x !== pointer.downX) || (pointer.y !== pointer.downY);
                }
                if (this.movedState[pointer.id]) {
                    switch (this.tracerState) {
                        case TOUCH1$2:
                            this.onDrag1();
                            break;
                        case TOUCH2:
                            this.onDrag2();
                            break;
                    }
                }
            }
        }
    }

    dragCancel() {
        if (this.tracerState === TOUCH2) {
            this.onDrag2End();
        }
        this.pointers.length = 0;
        Clear(this.movedState);
        this.tracerState = TOUCH0$2;
        return this;
    }

    onDrag1Start() {
        this.emit('drag1start', this);
    }

    onDrag1End() {
        this.emit('drag1end', this);
    }

    onDrag1() {
        this.emit('drag1', this);
    }

    onDrag2Start() {
        this.emit('drag2start', this);
    }

    onDrag2End() {
        this.emit('drag2end', this);
    }

    onDrag2() {
        this.emit('drag2', this);
    }

    get distanceBetween() {
        if (this.tracerState !== TOUCH2) {
            return 0;
        }
        var p0 = this.pointers[0],
            p1 = this.pointers[1];
        return DistanceBetween$5(p0.x, p0.y, p1.x, p1.y);
    }

    get angleBetween() {
        if (this.tracerState !== TOUCH2) {
            return 0;
        }
        var p0 = this.pointers[0],
            p1 = this.pointers[1];
        return AngleBetween$1(p0.x, p0.y, p1.x, p1.y);
    }

    get drag1Vector() {
        var pointer = this.pointers[0];
        if (pointer && this.movedState[pointer.id]) {
            var p1 = pointer.position;
            var p0 = pointer.prevPosition;
            tmpDragVector.x = p1.x - p0.x;
            tmpDragVector.y = p1.y - p0.y;
        } else {
            tmpDragVector.x = 0;
            tmpDragVector.y = 0;
        }
        return tmpDragVector;
    }

    get centerX() {
        if (this.tracerState !== TOUCH2) {
            return 0;
        }
        var p0 = this.pointers[0].position;
        var p1 = this.pointers[1].position;
        return (p0.x + p1.x) / 2;
    }

    get centerY() {
        if (this.tracerState !== TOUCH2) {
            return 0;
        }
        var p0 = this.pointers[0].position;
        var p1 = this.pointers[1].position;
        return (p0.y + p1.y) / 2;
    }

    get prevCenterX() {
        if (this.tracerState !== TOUCH2) {
            return 0;
        }
        var preP0 = (this.movedState[this.pointers[0].id]) ? this.pointers[0].prevPosition : this.pointers[0].position;
        var preP1 = (this.movedState[this.pointers[1].id]) ? this.pointers[1].prevPosition : this.pointers[1].position;
        return (preP0.x + preP1.x) / 2;
    }

    get prevCenterY() {
        if (this.tracerState !== TOUCH2) {
            return 0;
        }
        var preP0 = (this.movedState[this.pointers[0].id]) ? this.pointers[0].prevPosition : this.pointers[0].position;
        var preP1 = (this.movedState[this.pointers[1].id]) ? this.pointers[1].prevPosition : this.pointers[1].position;
        return (preP0.y + preP1.y) / 2;
    }

    get movementCenterX() {
        return this.centerX - this.prevCenterX;
    }

    get movementCenterY() {
        return this.centerY - this.prevCenterY;
    }

    setRecongizedStateObject(stateObject) {
        this.recongizedState = stateObject;
        return this;
    }

    get state() {
        return this.recongizedState.state;
    }

    set state(newState) {
        this.recongizedState.state = newState;
    }

    cancel() {
        this.state = IDLE$6;
        return this;
    }
}

Object.assign(
    TwoPointersTracer.prototype,
    EventEmitterMethods
);

var tmpDragVector = {};

const TOUCH0$2 = 0;
const TOUCH1$2 = 1;
const TOUCH2 = 2;

const IDLE$6 = 'IDLE';

const GetValue$1V = Phaser.Utils.Objects.GetValue;

class Pinch extends TwoPointersTracer {
    constructor(scene, config) {
        super(scene, config);

        var self = this;
        var stateConfig = {
            states: {
                IDLE: {
                    enter: function () {
                        self.prevDistance = undefined;
                        self.scaleFactor = 1;
                    },
                },
                BEGIN: {
                },
                RECOGNIZED: {
                    enter: function () {
                        self.emit('pinchstart', self);
                    },
                    exit: function () {
                        self.emit('pinchend', self);
                    }
                }
            },
            init: function () {
                this.state = IDLE$7;
            },
            eventEmitter: false,
        };
        this.setRecongizedStateObject(new FSM(stateConfig));
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);
        this.setDragThreshold(GetValue$1V(o, 'threshold', 0));
        return this;
    }

    onDrag2Start() {
        this.scaleFactor = 1;
        this.prevDistance = this.distanceBetween;
        this.state = BEGIN$4;
        if (this.dragThreshold === 0) {
            this.state = RECOGNIZED$4;
        }
    }

    onDrag2End() {
        this.state = IDLE$7;
    }

    onDrag2() {
        switch (this.state) {
            case BEGIN$4:
                if ((this.pointers[0].getDistance() >= this.dragThreshold) &&
                    (this.pointers[1].getDistance() >= this.dragThreshold)) {
                    var curDistance = this.distanceBetween;
                    this.scaleFactor = curDistance / this.prevDistance;
                    this.prevDistance = curDistance;
                    this.state = RECOGNIZED$4;
                }
                break;
            case RECOGNIZED$4:
                var curDistance = this.distanceBetween;
                this.scaleFactor = curDistance / this.prevDistance;
                this.emit('pinch', this);
                this.prevDistance = curDistance;
                break;
        }
    }

    get isPinched() {
        return (this.state === RECOGNIZED$4);
    }

    setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
    }
}

const IDLE$7 = 'IDLE';
const BEGIN$4 = 'BEGIN';
const RECOGNIZED$4 = 'RECOGNIZED';

const RotateAround$4 = Phaser.Math.RotateAround;

var RotateObjectAround = function (gameObject, x, y, angle) {
    RotateAround$4(gameObject, x, y, angle);
    gameObject.rotation += angle;
    return gameObject;
};

var SpinObject = function (gameObject, camera) {
    if (!this.isRotation) {
        return this;
    }

    if (camera === undefined) {
        camera = this.pointers[0].camera;
    }

    var movementX = this.movementCenterX,
        movementY = this.movementCenterY;

    camera.getWorldPoint(this.centerX, this.centerY, tmpPos);
    var centerWorldX = tmpPos.x;
    var centerWorldY = tmpPos.y;

    var angle = this.rotation;
    if (Array.isArray(gameObject)) {
        var gameObjects = gameObject;
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
            gameObject = gameObjects[i];
            gameObject.x += movementX;
            gameObject.y += movementY;
            RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
        }
    } else {
        gameObject.x += movementX;
        gameObject.y += movementY;
        RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
    }
    return this;
};

var tmpPos = {};

const GetValue$1W = Phaser.Utils.Objects.GetValue;
const WrapDegrees = Phaser.Math.Angle.WrapDegrees; // Wrap degrees: -180 to 180 
const ShortestBetween = Phaser.Math.Angle.ShortestBetween;
const RadToDeg$4 = Phaser.Math.RadToDeg;
const DegToRad$7 = Phaser.Math.DegToRad;

class Rotate$1 extends TwoPointersTracer {
    constructor(scene, config) {
        super(scene, config);

        var self = this;
        var stateConfig = {
            states: {
                IDLE: {
                    enter: function () {
                        self.prevAngle = undefined;
                        self.angle = 0;
                    },
                },
                BEGIN: {
                },
                RECOGNIZED: {
                    enter: function () {
                        self.emit('rotatestart', self);
                    },
                    exit: function () {
                        self.emit('rotateend', self);
                    }
                }
            },
            init: function () {
                this.state = IDLE$8;
            },
            eventEmitter: false,
        };
        this.setRecongizedStateObject(new FSM(stateConfig));
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);
        this.setDragThreshold(GetValue$1W(o, 'threshold', 0));
        return this;
    }

    onDrag2Start() {
        this.prevAngle = WrapDegrees(RadToDeg$4(this.angleBetween)); // Degrees
        this.state = BEGIN$5;
        if (this.dragThreshold === 0) {
            this.state = RECOGNIZED$5;
        }
    }

    onDrag2End() {
        this.state = IDLE$8;
    }

    onDrag2() {
        switch (this.state) {
            case BEGIN$5:
                if ((this.pointers[0].getDistance() >= this.dragThreshold) &&
                    (this.pointers[1].getDistance() >= this.dragThreshold)) {
                    var curAngle = WrapDegrees(RadToDeg$4(this.angleBetween));
                    this.angle = ShortestBetween(this.prevAngle, curAngle);
                    this.prevAngle = curAngle;
                    this.state = RECOGNIZED$5;
                }
                break;
            case RECOGNIZED$5:
                var curAngle = WrapDegrees(RadToDeg$4(this.angleBetween));
                this.angle = ShortestBetween(this.prevAngle, curAngle);
                this.prevAngle = curAngle;
                this.emit('rotate', this);
                break;
        }
    }

    get isRotated() {
        return (this.state === RECOGNIZED$5);
    }

    get rotation() {
        return DegToRad$7(this.angle);
    }

    setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
    }

}

var methods$c = {
    spinObject: SpinObject,
};
Object.assign(
    Rotate$1.prototype,
    methods$c
);


const IDLE$8 = 'IDLE';
const BEGIN$5 = 'BEGIN';
const RECOGNIZED$5 = 'RECOGNIZED';

const GetValue$1X = Phaser.Utils.Objects.GetValue;

var TapCell = function (table, tableConfig) {
    var tapConfig = GetValue$1X(tableConfig, 'tap', undefined);
    if (tapConfig === false) {
        return;
    }

    table._tap = new Tap(table, tapConfig);
    table._tap
        .on('tap', function (tap, gameObject, lastPointer) {
            var eventName = `cell.${tap.tapsCount}tap`;
            EmitCellEvent(this.eventEmitter, eventName, tap.gameObject, tap.x, tap.y, lastPointer);
        }, this);
};

const GetValue$1Y = Phaser.Utils.Objects.GetValue;

var PressCell = function (table, tableConfig) {
    var pressConfig = GetValue$1Y(tableConfig, 'press', undefined);
    if (pressConfig === false) {
        return;
    }

    table._press = new Press(table, pressConfig);
    table._press
        .on('pressstart', function (press, gameObject, lastPointer) {
            EmitCellEvent(this.eventEmitter, 'cell.pressstart', table, press.x, press.y, lastPointer);
        }, this)
        .on('pressend', function (press, gameObject, lastPointer) {
            EmitCellEvent(this.eventEmitter, 'cell.pressend', table, press.x, press.y, lastPointer);
        }, this);
};

const GetValue$1Z = Phaser.Utils.Objects.GetValue;

var SwipeCell = function (table, tableConfig) {
    var swipeConfig = GetValue$1Z(tableConfig, 'swipe', undefined);
    if (swipeConfig === false) {
        return;
    } else if (swipeConfig === undefined) {
        swipeConfig = {};
    }
    swipeConfig.dir = '4dir';
    table._swipe = new Swipe(table, swipeConfig);
    table._swipe
        .on('swipe', function (swipe, gameObject, lastPointer) {
            var dirName =
                (swipe.left) ? 'left' :
                    (swipe.right) ? 'right' :
                        (swipe.up) ? 'up' :
                            'down';
            EmitCellEvent(this.eventEmitter, `cell.swipe${dirName}`, table, swipe.x, swipe.y, lastPointer);
        }, this);
};

var TableSetInteractive = function (table, tableConfig) {
    table.setInteractive();
    
    PointerUpDownCell.call(this, table, tableConfig);
    OverCell.call(this, table, tableConfig);
    ClickCell.call(this, table, tableConfig);
    TapCell.call(this, table, tableConfig);
    PressCell.call(this, table, tableConfig);
    SwipeCell.call(this, table, tableConfig);
};

var SetItems = function (items) {
    if (items === undefined) {
        this.items.length = 0;
    } else {
        this.items = items;
    }

    var table = this.childrenMap.child;
    table.setCellsCount(this.items.length);
    table.updateTable(true);

    this.resizeController();
    return this;
};

const GetValue$1_ = Phaser.Utils.Objects.GetValue;

class GridTable$1 extends Scrollable {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        // Create grid table core
        var scrollMode = GetScrollMode(config);
        var tableConfig = GetValue$1_(config, 'table', undefined);
        if (tableConfig === undefined) {
            tableConfig = {};
        }
        tableConfig.scrollMode = scrollMode;
        tableConfig.clamplTableOXY = GetValue$1_(config, 'clamplChildOY', false);
        var tableWidth = GetValue$1_(tableConfig, 'width', undefined);
        var tableHeight = GetValue$1_(tableConfig, 'height', undefined);
        var table = new GridTable(scene, 0, 0, tableWidth, tableHeight, tableConfig);
        scene.add.existing(table); // Important: Add to display list for touch detecting
        var proportion, expand;
        if (scrollMode === 0) {
            proportion = (tableWidth === undefined) ? 1 : 0;
            expand = (tableHeight === undefined);
        } else {
            proportion = (tableHeight === undefined) ? 1 : 0;
            expand = (tableWidth === undefined);
        }
        // Inject properties for scrollable interface
        InjectProperties(table);

        // Fill config of scrollable
        config.type = 'rexGridTable';
        config.child = {
            gameObject: table,
            proportion: proportion,
            expand: expand,
        };
        var spaceConfig = GetValue$1_(config, 'space', undefined);
        if (spaceConfig) {
            spaceConfig.child = spaceConfig.table;
        }
        super(scene, config);

        this.addChildrenMap('table', table);

        this.eventEmitter = GetValue$1_(config, 'eventEmitter', this);
        var callback = GetValue$1_(config, 'createCellContainerCallback', NOOP);
        var scope = GetValue$1_(config, 'createCellContainerCallbackScope', undefined);
        this.setCreateCellContainerCallback(callback, scope);
        TableOnCellVisible.call(this, table);

        this.resizeControllerFlag = false;
        var eventName = (scrollMode === 0) ? 'cellheightchange' : 'cellwidthchange';
        table.on(eventName, function () {
            this.resizeControllerFlag = true;
        }, this);

        if (GetValue$1_(tableConfig, 'interactive', true)) {
            TableSetInteractive.call(this, table, tableConfig);
        }
        this.setItems(GetValue$1_(config, 'items', []));

        scene.game.events.on('poststep', this.onPostStep, this);
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        this.scene.game.events.off('poststep', this.onPostStep, this);

        super.destroy(fromScene);
    }

    setCreateCellContainerCallback(callback, scope) {
        this.createCellContainerCallback = callback;
        this.createCellContainerCallbackScope = scope;
        return this;
    }

    refresh() {
        this.setItems(this.items);
        return this;
    }

    getCell(cellIdx) {
        var table = this.childrenMap.child;
        return table.getCell(cellIdx);
    }

    getCellContainer(cellIdx) {
        var table = this.childrenMap.child;
        return table.getCellContainer(cellIdx);
    }

    updateVisibleCell(cellIdx) {
        var table = this.childrenMap.child;
        return table.updateVisibleCell(cellIdx);
    }

    onPostStep() {
        if (this.resizeControllerFlag) {
            this.resizeController();
            this.resizeControllerFlag = false;
        }
    }
}

var methods$d = {
    setItems: SetItems
};
Object.assign(
    GridTable$1.prototype,
    methods$d
);

var ExpandSubMenu = function (parentButton, items) {
    this.collapseSubMenu();

    var orientation;
    if (this.root.toggleOrientation) {
        orientation = (this.orientation === 0) ? 1 : 0;
    } else {
        orientation = this.orientation;
    }

    var subMenu = new this.constructor(this.scene, {
        items: items,
        orientation: orientation,

        createBackgroundCallback: this.root.createBackgroundCallback,
        createBackgroundCallbackScope: this.root.createBackgroundCallbackScope,
        createButtonCallback: this.root.createButtonCallback,
        createButtonCallbackScope: this.root.createButtonCallbackScope,
        easeIn: this.root.easeIn,
        easeOut: this.root.easeOut,

        _rootMenu: this.root,
        _parentMenu: this,
        _parentButton: parentButton
    });

    this.pin(subMenu);
    this.childrenMap.subMenu = subMenu;
    this.root.emit('expand', subMenu, parentButton, this);
    return this;
};

var GetEaseConfig = function (easeConfig, menu) {
    if (easeConfig.sameOrientation) {
        easeConfig.orientation = menu.orientation;
    } else {
        easeConfig.orientation = (menu.orientation === 0) ? 1 : 0;
    }
    return easeConfig;
};

var Collapse = function () {
    this.root.emit('collapse', this, this.parentButton, this.root);
    this.scaleDownDestroy(GetEaseConfig(this.root.easeOut, this));
    this.collapseSubMenu();
    return this;
};

var CollapseSubMenu = function () {
    if (this.childrenMap.subMenu === undefined) {
        return this;
    }

    var subMenu = this.childrenMap.subMenu;
    this.childrenMap.subMenu = undefined;
    this.remove(subMenu);
    subMenu.collapse();
    return this;
};

var Methods$6 = {
    expandSubMenu: ExpandSubMenu,
    collapse: Collapse,
    collapseSubMenu: CollapseSubMenu,
};

var CreateBackground = function (scene, items, callback, scope) {
    var background;
    if (callback) {
        items.scene = scene;
        if (scope) {
            background = callback.call(scope, items);
        } else {
            background = callback(items);
        }
        items.scene = undefined;
    }

    return background;
};

var CreateButtons = function (scene, items, callback, scope) {
    var item;
    var buttons = [],
        button;
    if (items && callback) {
        for (var i = 0, cnt = items.length; i < cnt; i++) {
            item = items[i];
            item.scene = scene;
            if (scope) {
                button = callback.call(scope, item, i, items);
            } else {
                button = callback(item, i, items);
            }
            item.scene = undefined;
            buttons.push(button);
        }
    }

    return buttons;
};

var MenuSetInteractive = function (menu) {
    menu
        // Expand sub event
        .on(menu.root.expandEventName, function (button, index) {
            if (this._isPassedEvent) {
                return;
            }
            var subItems = this.items[index].children;
            if (subItems) {
                this.expandSubMenu(button, subItems);
            }
        }, menu)
        // Click any button
        .on('button.click', function (button, index, pointer, event) {
            // Pass event to root menu object
            if (this !== this.root) {
                this.root._isPassedEvent = true;
                this.root.emit('button.click', button, index, pointer, event);
                this.root._isPassedEvent = false;
            }
        }, menu)
        //Pointer over any button
        .on('button.over', function (button, index, pointer, event) {
            // Pass event to root menu object
            if (this !== this.root) {
                this.root._isPassedEvent = true;
                this.root.emit('button.over', button, index, pointer, event);
                this.root._isPassedEvent = false;
            }
        }, menu)
        //Pointer out any button
        .on('button.out', function (button, index, pointer, event) {
            // Pass event to root menu object
            if (this !== this.root) {
                this.root._isPassedEvent = true;
                this.root.emit('button.out', button, index, pointer, event);
                this.root._isPassedEvent = false;
            }
        }, menu);
};

const GetValue$1$ = Phaser.Utils.Objects.GetValue;

class Menu extends Buttons {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        // Orientation
        if (!config.hasOwnProperty('orientation')) {
            config.orientation = 1; // y
        }

        // Parent
        var rootMenu = config._rootMenu;
        var parentMenu = config._parentMenu;
        var parentButton = config._parentButton;
        // Items
        var items = GetValue$1$(config, 'items', undefined);
        // Background
        var createBackgroundCallback = GetValue$1$(config, 'createBackgroundCallback', undefined);
        var createBackgroundCallbackScope = GetValue$1$(config, 'createBackgroundCallbackScope', undefined);
        config.background = CreateBackground(scene, items, createBackgroundCallback, createBackgroundCallbackScope);
        // Buttons
        var createButtonCallback = GetValue$1$(config, 'createButtonCallback', undefined);
        var createButtonCallbackScope = GetValue$1$(config, 'createButtonCallbackScope', undefined);
        config.buttons = CreateButtons(scene, items, createButtonCallback, createButtonCallbackScope);

        super(scene, config);
        this.type = 'rexMenu';

        this.items = items;
        this.root = (rootMenu === undefined) ? this : rootMenu;
        this.parentMenu = parentMenu;
        this.parentButton = parentButton;

        var isRootMenu = (this.root === this);
        if (isRootMenu) { // Root menu
            // Bounds
            var bounds = config.bounds;
            if (bounds === undefined) {
                bounds = GetDefaultBounds(scene);
            }
            this.bounds = bounds;

            // Side of submenu
            this.subMenuSide = [
                ((this.y < bounds.centerY) ? SUBMENU_DOWN : SUBMENU_UP),
                ((this.x < bounds.centerX) ? SUBMENU_RIGHT : SUBMENU_LEFT)
            ];
            // Overwrite subMenuSide value if given
            var subMenuSide = GetValue$1$(config, 'subMenuSide', undefined);
            if (subMenuSide !== undefined) {
                if (typeof (subMenuSide) === 'string') {
                    subMenuSide = SubMenuSideMode[subMenuSide];
                }
                this.subMenuSide[this.orientation] = subMenuSide;
            }
            // ToggleOrientation mode
            this.toggleOrientation = GetValue$1$(config, 'toggleOrientation', false);
            // Expand mode
            this.expandEventName = GetValue$1$(config, 'expandEvent', 'button.click');
            // Transition
            this.easeIn = ParseEaseConfig(this, GetValue$1$(config, 'easeIn', 0));
            this.easeOut = ParseEaseConfig(this, GetValue$1$(config, 'easeOut', 0));
            // Callbacks
            this.createBackgroundCallback = createBackgroundCallback;
            this.createBackgroundCallbackScope = createBackgroundCallbackScope;
            this.createButtonCallback = createButtonCallback;
            this.createButtonCallbackScope = createButtonCallbackScope;

            // Event flag
            this._isPassedEvent = false;
        }

        var originX = 0, originY = 0;
        if (!this.root.easeIn.sameOrientation) {
            var easeOrientation = GetEaseConfig(this.root.easeIn, this).orientation;
            var menuOrientation = (parentMenu) ? parentMenu.orientation : this.orientation;
            var subMenuSide = this.root.subMenuSide[menuOrientation];
            if ((easeOrientation === 0) && (subMenuSide === SUBMENU_LEFT)) {
                originX = 1;
            }
            if ((easeOrientation === 1) && (subMenuSide === SUBMENU_UP)) {
                originY = 1;
            }
        }

        this
            .setOrigin(originX, originY)
            .layout();

        // Sub-menu, align to parent button
        if (!isRootMenu) {
            var subMenuSide = this.root.subMenuSide[parentMenu.orientation];
            switch (subMenuSide) {
                case SUBMENU_LEFT: //Put submene at left side
                    this.alignTop(parentButton.top).alignRight(parentButton.left);
                    break;

                case SUBMENU_RIGHT: //Put submene at right side
                    this.alignTop(parentButton.top).alignLeft(parentButton.right);
                    break;

                case SUBMENU_UP: //Put submene at up side
                    this.alignLeft(parentButton.left).alignBottom(parentButton.top);
                    break;

                case SUBMENU_DOWN: //Put submene at down side
                    this.alignLeft(parentButton.left).alignTop(parentButton.bottom);
                    break;
            }
        }
        this.pushIntoBounds(this.root.bounds);

        MenuSetInteractive(this);

        // Ease in menu
        this.popUp(GetEaseConfig(this.root.easeIn, this));
        this.once('popup.complete', function () {
            // Pass event to root menu object
            if (this !== this.root) {
                this.root.emit('popup.complete', this);
            }
        }, this);
    }

    isInTouching(pointer) {
        if (super.isInTouching(pointer)) {
            return true;
        } else if (this.childrenMap.subMenu) {
            return this.childrenMap.subMenu.isInTouching(pointer);
        } else {
            return false;
        }
    }
}

var ParseEaseConfig = function (menu, easeConfig) {
    if (typeof (easeConfig) === 'number') {
        easeConfig = {
            duration: easeConfig
        };
    }

    if (easeConfig.hasOwnProperty('orientation') && (easeConfig.orientation !== undefined)) {
        easeConfig.sameOrientation = GetOrientationMode(easeConfig.orientation) === menu.orientation;
    } else {
        easeConfig.sameOrientation = true;
    }
    return easeConfig;
};

const SUBMENU_LEFT = 2;
const SUBMENU_RIGHT = 0;
const SUBMENU_UP = 3;
const SUBMENU_DOWN = 1;
const SubMenuSideMode = {
    up: SUBMENU_UP,
    down: SUBMENU_DOWN,
    left: SUBMENU_LEFT,
    right: SUBMENU_RIGHT
};

Object.assign(
    Menu.prototype,
    Methods$6
);

const TextKlass = Phaser.GameObjects.Text;

var IsTextGameObject = function (gameObject) {
    return (gameObject instanceof TextKlass);
};

const BitmapTextKlass = Phaser.GameObjects.BitmapText;

var IsBitmapTextGameObject = function (gameObject) {
    return (gameObject instanceof BitmapTextKlass);
};

const TextType = 0;
const TagTextType = 1;
const BitmapTextType = 2;

var GetTextObjectType = function (textObject) {
    var textObjectType;
    if (IsBitmapTextGameObject(textObject)) {
        textObjectType = BitmapTextType;
    } else if (IsTextGameObject(textObject)) {
        textObjectType = TextType;
    } else {
        textObjectType = TagTextType;
    }

    return textObjectType;
};

var TextToLines = function (textObject, text, lines) {
    var textObjectType = GetTextObjectType(textObject);
    switch (textObjectType) {
        case TextType:
            lines = textObject.getWrappedText(text); // Array of string
            break;
        case TagTextType:
            lines = textObject.getPenManager(text, lines); // Pens-manager
            break;
        case BitmapTextType:
            lines = textObject
                .setText(text)
                .getTextBounds().wrappedText.split('\n');
            break;
    }
    return lines;
};

var GetLines = function (startLineIndex, endLineIdx) {
    if (startLineIndex === undefined) {
        startLineIndex = this.startLineIndex;
    }
    if (endLineIdx === undefined) {
        endLineIdx = startLineIndex + this.pageLinesCount;
    }

    var text;
    switch (this.textObjectType) {
        case TextType:
        case BitmapTextType:
            text = this.lines.slice(startLineIndex, endLineIdx).join('\n');
            break;
        case TagTextType:
            var startIdx = this.lines.getLineStartIndex(startLineIndex);
            var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
            text = this.lines.getSliceTagText(startIdx, endIdx, true);
            break;
    }

    return text;
};

var GetString = function (text) {
    if (Array.isArray(text)) {
        text = text.join('\n');
    } else if (typeof (text) === 'number') {
        text = text.toString();
    }
    return text;
};

var SetContentMethods = {
    clearText() {
        this.sections.length = 0;
        this.pageStartIndexes.length = 0;
        this.lines.length = 0;

        return this;
    },

    appendPage(text) {
        var pageStartIndex = this.totalLinesCount;

        this.sections.push(GetString(text));
        var text = this.sections.join('\n');
        this.lines = TextToLines(this.parent, text, this.lines);

        var newLinesCount = this.totalLinesCount - pageStartIndex;
        var pageCount = Math.ceil(newLinesCount / this.pageLinesCount);
        for (var i = 0; i < pageCount; i++) {
            this.pageStartIndexes.push(
                pageStartIndex + (i * this.pageLinesCount)
            );
        }

        return this;
    },

    setText(text, resetPageIdx) {
        if (resetPageIdx === undefined) {
            resetPageIdx = true;
        }

        if (resetPageIdx) {
            this.resetPageIdx();
        }

        this.clearText();

        var sections = GetString(text).split(this.pageBreak);
        // if (sections[sections.length - 1] === '') { // Last section is an empty string
        //     sections.length -= 1;
        // }

        for (var i = 0, cnt = sections.length; i < cnt; i++) {
            this.appendPage(sections[i]);
        }

        return this;
    },

    appendText(text) {
        var content = this.content + GetString(text);
        this.setText(content, false);
        return this;
    },


};

const Clamp$a = Phaser.Math.Clamp;

var GetPageMethods = {
    getPage(idx) {
        if (idx === undefined) {
            idx = this.pageIndex;
        }

        return this.setPageIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
    },

    getNextPage() {
        return this.getPage(this.pageIndex + 1);
    },

    getPreviousPage() {
        return this.getPage(this.pageIndex - 1);
    },

    resetPageIdx() {
        this.pageIndex = -1;
        return this;
    },

    setPageIndex(idx) {
        idx = Clamp$a(idx, 0, this.pageCount - 1);
        this.pageIndex = idx;
        this.startLineIndex = this.pageStartIndexes[idx];
        this.endLineIndex = this.pageStartIndexes[idx + 1];
        return this;
    },
};

var SetNoWrapText = function (textObject, text) {
    var textObjectType = GetTextObjectType(textObject);
    switch (textObjectType) {
        case TextType:
            // Store wrap properties
            var style = textObject.style;
            var wordWrapWidth = style.wordWrapWidth;
            var wordWrapCallback = style.wordWrapCallback;
            // Disable wrap
            style.wordWrapWidth = 0;
            style.wordWrapCallback = undefined;
            // Set text
            textObject.setText(text);
            // Restore wrap
            style.wordWrapWidth = wordWrapWidth;
            style.wordWrapCallback = wordWrapCallback;
            break;

        case TagTextType:
            // Store wrap properties
            var style = textObject.style;
            var wrapMode = style.wrapMode;
            // Disable wrap
            style.wrapMode = 0;
            // Set text
            textObject.setText(text);
            // Restore wrap
            style.wrapMode = wrapMode;
            break;

        case BitmapTextType:
            // Store wrap properties
            var maxWidth = textObject._maxWidth;
            // Disable wrap
            textObject._maxWidth = 0;
            // Set text
            textObject.setText(text);
            // Restore wrap
            textObject._maxWidth = maxWidth;
            break;
    }
};

var ShowMethods = {
    showPage(idx) {
        this.displayText(
            this.getPage(idx)
        );
        return this;
    },

    showNextPage() {
        this.displayText(
            this.getNextPage()
        );
        return this;
    },

    showPreviousPage() {
        this.displayText(
            this.getPreviousPage()
        );
        return this;
    },

    show() {
        this.displayText(
            this.getLines()
        );
        return this;
    },

    showNextLine() {
        this.displayText(
            this.setStartLineIndex(this.startLineIndex + 1).getLines()
        );
        return this;
    },

    showPreviousLine() {
        this.displayText(
            this.setStartLineIndex(this.startLineIndex - 1).getLines()
        );
        return this;
    },

    displayText(text) {
        SetNoWrapText(this.parent, text);
    }
};

var Methods$7 = {   
    getLines: GetLines,
};

Object.assign(
    Methods$7,
    SetContentMethods,
    GetPageMethods,
    ShowMethods
);

const GetValue$20 = Phaser.Utils.Objects.GetValue;
const Clamp$b = Phaser.Math.Clamp;

class TextPage extends ComponentBase {
    constructor(gameObject, config) {
        super(gameObject, { eventEmitter: false });
        // No event emitter
        // this.parent = gameObject;

        this.textObjectType = GetTextObjectType(this.parent);

        this.pageStartIndexes = [];

        // Text object : array of string
        // Tag text object : pens-manager
        // Bitmap text object : array of string
        this.lines = TextToLines(this.parent, '');

        this.sections = [];

        this.resetFromJSON(config);
    }

    resetFromJSON(o) {
        this.setMaxLines(GetValue$20(o, 'maxLines', undefined));
        this.setPageBreak(GetValue$20(o, 'pageBreak', '\f\n'));
        this.setText(GetValue$20(o, 'text', ''));
        this.setStartLineIndex(GetValue$20(o, 'start', 0));
        this.setPageIndex(GetValue$20(o, 'page', -1));
        return this;
    }

    toJSON() {
        return {
            maxLines: this.maxLines,
            text: this.content,
            start: this.startLineIndex,
            page: this.pageIndex,
            pageBreak: this.pageBreak
        };
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        switch (this.textObjectType) {
            case TextType:
                this.lines.length = 0;
                break;
            case TagTextType:
                this.lines.destroy();
                break;
            case BitmapTextType:
                this.lines.length = 0;
                break;
        }

        this.pageStartIndexes.length = 0;
        this.sections.length = 0;

        this.lines = undefined;
        this.pageStartIndexes = undefined;
        this.sections = undefined;

        super.shutdown(fromScene);
    }

    setMaxLines(maxLines) {
        this.maxLines = maxLines;
        return this;
    }

    setPageBreak(pageBreak) {
        this.pageBreak = pageBreak;
        return this;
    }

    get pageCount() {
        return this.pageStartIndexes.length;
    }

    get isFirstPage() {
        return (this.pageIndex <= 0);
    }

    get isLastPage() {
        return (this.pageIndex >= (this.pageCount - 1));
    }

    get totalLinesCount() {
        return (this.lines) ? this.lines.length : 0;
    }

    get startLineIndex() {
        return this._startLineIndex;
    }

    set startLineIndex(value) {
        value = Clamp$b(value, 0, this.totalLinesCount - 1);
        this._startLineIndex = value;
    }

    setStartLineIndex(idx) {
        this.startLineIndex = idx;
        return this;
    }

    get pageLinesCount() {
        if (this.maxLines !== undefined) {
            return this.maxLines;

        } else {
            var count;
            switch (this.textObjectType) {
                case TextType:
                case TagTextType:
                    var maxLines = this.parent.style.maxLines;
                    if (maxLines > 0) {
                        count = maxLines;
                    } else {
                        count = this.totalLinesCount;
                    }
                    break;
                case BitmapTextType:
                    count = this.totalLinesCount;
                    break;
            }
            return count;

        }
    }

    get content() {
        return this.sections.join(this.pageBreak);
    }
}

Object.assign(
    TextPage.prototype,
    Methods$7,
);

var GetWrapText = function (textObject, text) {
    var textObjectType = GetTextObjectType(textObject);
    switch (textObjectType) {
        case TextType:
            textObject.style.syncFont(textObject.canvas, textObject.context);
            text = textObject.runWordWrap(text);
            break;
        case TagTextType:
            text = textObject.getText(text, undefined, undefined, true);
            break;
        case BitmapTextType:
            text = textObject.setText(text).getTextBounds().wrappedText;
            break;
    }
    return text;
};

const GetFastValue$2 = Phaser.Utils.Objects.GetFastValue;
const GetValue$21 = Phaser.Utils.Objects.GetValue;

class TextTyping extends ComponentBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;

        this.timer = null;
        this.resetFromJSON(config);
    }

    resetFromJSON(o) {
        this.setTextWrapEnable(GetValue$21(o, 'wrap', false));
        this.setTypeMode(GetValue$21(o, 'typeMode', 0));
        this.setTypeSpeed(GetValue$21(o, 'speed', 333));
        this.setTextCallback = GetFastValue$2(o, 'setTextCallback', null);
        this.setTextCallbackScope = GetFastValue$2(o, 'setTextCallbackScope', null);

        this.setTypingContent(GetFastValue$2(o, 'text', ''));
        this.typingIdx = GetFastValue$2(o, 'typingIdx', 0);
        this.insertIdx = GetFastValue$2(o, 'insertIdx', null);

        var elapsed = GetFastValue$2(o, 'elapsed', null);
        if (elapsed !== null) {
            this.start(undefined, undefined, this.typingIdx, elapsed);
        }

        return this;
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        this.freeTimer();

        super.shutdown(fromScene);
    }

    setTypeMode(m) {
        if (typeof (m) === 'string') {
            m = TYPEMODE[m];
        }
        this.typeMode = m;
        return this;
    }

    setTypeSpeed(speed) {
        this.speed = speed;
        return this;
    }

    setTextWrapEnable(enable) {
        if (enable === undefined) {
            enable = true;
        }
        this.textWrapEnable = enable;
        return this;
    }

    set text(value) {
        var text = TransferText(value);
        if (this.textWrapEnable) {
            text = GetWrapText(this.parent, text);
        }

        this._text = text;
    }

    get text() {
        return this._text;
    }

    get isTyping() {
        return (this.getTimer() !== null);
    }

    get isLastChar() {
        return (this.typingIdx === this.textLen);
    }

    start(text, speed, startIdx, timerStartAt) {
        if (text !== undefined) {
            this.setTypingContent(text);
        }
        if (speed !== undefined) {
            this.speed = speed;
        }
        if (startIdx === undefined) {
            startIdx = 0;
        }

        this.typingIdx = startIdx + 1;
        if (this.speed === 0) {
            this.stop(true);
        } else {
            this.setText('');
            this.startTimer(timerStartAt);
        }

        return this;
    }

    appendText(text) {
        var newText = this.text.concat(TransferText(text));
        if (this.isTyping) {
            this.setTypingContent(newText);
        } else {
            this.start(newText, undefined, this.textLen);
        }

        return this;
    }

    stop(showAllText) {
        var timer = this.getTimer();
        if (timer) {
            this.freeTimer();
        }
        if (showAllText) {
            this.typingIdx = this.textLen;
            this.setText(this.text);
            this.emit('type');
            this.emit('complete', this, this.parent);
        }

        return this;
    }

    pause() {
        var timer = this.getTimer();
        if (timer) {
            timer.paused = true;
        }
        return this;
    }

    resume() {
        var timer = this.getTimer();
        if (timer) {
            timer.paused = false;
        }
        return this;
    }

    setTypingContent(text) {
        this.text = text;
        this.textLen = this.getTextLength(this.text);
        return this;
    }

    onTyping() {
        var newText = this.getTypingString(this.text, this.typingIdx, this.textLen, this.typeMode);

        this.setText(newText);

        this.emit('type');

        if (this.isLastChar) {
            this.freeTimer();
            this.emit('complete', this, this.parent);
        } else {
            this.timer.delay = this.speed; // delay of next typing            
            this.typingIdx++;
        }
    }

    getTypingString(text, typeIdx, textLen, typeMode) {
        var result;
        if (typeMode === 0) { //left-to-right
            var startIdx = 0;
            var endIdx = typeIdx;
            this.insertIdx = endIdx;
            result = this.getSubString(text, startIdx, endIdx);

        } else if (typeMode === 1) { //right-to-left
            var endIdx = textLen;
            var startIdx = endIdx - typeIdx;
            this.insertIdx = 0;
            result = this.getSubString(text, startIdx, endIdx);

        } else if (typeMode === 2) { //middle-to-sides
            var midIdx = textLen / 2;
            var startIdx = Math.floor(midIdx - (typeIdx / 2));
            var endIdx = startIdx + typeIdx;
            this.insertIdx = (typeIdx % 2) ? typeIdx : 0;
            result = this.getSubString(text, startIdx, endIdx);

        } else if (typeMode === 3) { //sides-to-middle
            var lowerLen = Math.floor(typeIdx / 2);
            var lowerResult;
            if (lowerLen > 0) {
                var endIdx = textLen;
                var startIdx = endIdx - lowerLen;
                lowerResult = this.getSubString(text, startIdx, endIdx);
            } else {
                lowerResult = "";
            }

            var upperLen = typeIdx - lowerLen;
            var upperResult;
            if (upperLen > 0) {
                var startIdx = 0;
                var endIdx = startIdx + upperLen;
                this.insertIdx = endIdx;
                upperResult = this.getSubString(text, startIdx, endIdx);
            } else {
                upperResult = "";
                this.insertIdx = 0;
            }
            result = upperResult + lowerResult;
        }

        return result;
    }

    startTimer(timerStartAt) {
        if (this.timer) {
            this.freeTimer();
        }
        var startAt;
        if (timerStartAt === undefined) {
            startAt = 0;
        } else {
            this.speed;
            startAt = timerStartAt;
        }

        this.timer = this.scene.time.addEvent({
            delay: 0,
            startAt: startAt,
            loop: true,
            callback: this.onTyping,
            callbackScope: this
        });
        return this;
    }

    getTimer() {
        return this.timer;
    }

    freeTimer() {
        if (this.timer) {
            this.timer.remove();
            this.timer = null;
        }

        return this;
    }

    setText(text) {
        if (this.setTextCallback) {
            if (this.setTextCallbackScope) {
                text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIdx);
            } else {
                text = this.setTextCallback(text, this.isLastChar, this.insertIdx);
            }
        }

        if (this.textWrapEnable) {
            SetNoWrapText(this.parent, text);
        } else {
            this.parent.setText(text);
        }
    }

    getTextLength(text) {
        var gameObject = this.parent;
        var len;
        if (gameObject.getPlainText) {
            len = gameObject.getPlainText(text).length;
        } else {
            len = text.length;
        }

        return len;
    }

    getSubString(text, startIdx, endIdx) {
        var gameObject = this.parent;
        var result;
        if (gameObject.getSubString) {
            result = gameObject.getSubString(text, startIdx, endIdx);
        } else {
            result = text.slice(startIdx, endIdx);
        }

        return result;
    }
}

var TransferText = function (text) {
    if (Array.isArray(text)) {
        text = text.join('\n');
    } else if (typeof (text) === 'number') {
        text = text.toString();
    }
    return text;
};

const TYPEMODE = {
    'left-to-right': 0,
    'right-to-left': 1,
    'middle-to-sides': 2,
    'sides-to-middle': 3
};

const GetValue$22 = Phaser.Utils.Objects.GetValue;

class TextBox extends Label {
    constructor(scene, config) {
        if (config === undefined) {
            config = {
                text: createDefaultTextObject$1(scene)
            };
        }

        super(scene, config);
        this.type = 'rexTextBox';

        var text = this.childrenMap.text;
        this.page = new TextPage(text, GetValue$22(config, 'page', undefined));
        this.typing = new TextTyping(text, GetValue$22(config, 'type', undefined));
        this.typing
            .on('complete', this.onPageEnd, this)
            .on('type', this.onType, this);

        this.textWidth = text.width;
        this.textHeight = text.height;
    }

    start(text, speed) {
        this.page.setText(text);
        if (speed !== undefined) {
            this.setTypeSpeed(speed);
        }
        this.typeNextPage();
        return this;
    }

    typeNextPage() {
        if (!this.isLastPage) {
            var txt = this.page.getNextPage();
            this.typing.start(txt);
        } else {
            this.emit('complete');
        }
        return this;
    }

    pause() {
        this.typing.pause();
        return this;
    }

    resume() {
        this.typing.resume();
        return this;
    }

    stop(showAllText) {
        this.typing.stop(showAllText);
        return this;
    }

    setTypeSpeed(speed) {
        this.typing.setTypeSpeed(speed);
        return this;
    }

    get isTyping() {
        return this.typing.isTyping;
    }

    get isLastPage() {
        return this.page.isLastPage;
    }

    get isFirstPage() {
        return this.page.isFirstPage;
    }

    get pageCount() {
        return this.page.pageCount;
    }

    get pageIndex() {
        return this.page.pageIndex;
    }

    onType() {
        var text = this.childrenMap.text;
        if ((this.textWidth !== text.width) || (this.textHeight !== text.height)) {
            this.textWidth = text.width;
            this.textHeight = text.height;
            this.getTopmostSizer().layout();
        }
        this.emit('type');
    }

    onPageEnd() {
        this.emit('pageend');

        if (this.isLastPage) {
            this.emit('complete');
        }
    }

}

var createDefaultTextObject$1 = function (scene) {
    return scene.add.text(0, 0, '', {
        wordWrap: {
            width: 200,
        },
        maxLines: 5
    });
};

const GetValue$23 = Phaser.Utils.Objects.GetValue;

class NumberBar extends Sizer {
    constructor(scene, config) {
        // Create sizer
        super(scene, config);
        this.type = 'rexNumberBar';

        // Add elements
        var background = GetValue$23(config, 'background', undefined);
        var icon = GetValue$23(config, 'icon', undefined);
        var iconMask = GetValue$23(config, 'iconMask', undefined);
        var sliderConfig = GetValue$23(config, 'slider', undefined);
        var text = GetValue$23(config, 'text', undefined);

        // Space
        var iconSpace = GetValue$23(config, 'space.icon', 0);
        var sliderSpace = GetValue$23(config, 'space.slider', 0);

        if (background) {
            this.addBackground(background);
        }

        if (icon) {
            var padding;
            if (this.orientation === 0) {
                if (sliderConfig || text) {
                    padding = { right: iconSpace };
                }
            } else {
                if (sliderConfig || text) {
                    padding = { bottom: iconSpace };
                }
            }

            this.add(icon, 0, 'center', padding);

            if (iconMask) {
                iconMask = AddChildMask.call(this, icon, icon, 1); // Circle mask
            }
        }

        var slider;
        if (sliderConfig) {
            sliderConfig.orientation = this.orientation;
            sliderConfig.eventEmitter = this;
            sliderConfig.value = null;
            if (!sliderConfig.hasOwnProperty('input')) {
                sliderConfig.input = -1;
            }
            slider = new Slider(scene, sliderConfig);

            var padding;
            if (this.orientation === 0) {
                if (text) {
                    padding = { right: sliderSpace };
                }
            } else {
                if (text) {
                    padding = { bottom: sliderSpace };
                }
            }

            var proportion;
            if (this.orientation === 0) {
                var sliderWidth = GetValue$23(sliderConfig, 'width', undefined);
                proportion = (sliderWidth === undefined) ? 1 : 0;
            } else {
                var sliderHeight = GetValue$23(sliderConfig, 'height', undefined);
                proportion = (sliderHeight === undefined) ? 1 : 0;
            }
            this.add(slider, proportion, 'center', padding);
        }


        if (text) {
            this.add(text);
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('icon', icon);
        this.addChildrenMap('iconMask', iconMask);
        this.addChildrenMap('slider', slider);
        this.addChildrenMap('text', text);

        var callback = GetValue$23(config, 'valuechangeCallback', null);
        if (callback !== null) {
            var scope = GetValue$23(config, 'valuechangeCallbackScope', undefined);
            this.on('valuechange', callback, scope);
        }
        this.setEnable(GetValue$23(config, 'enable', undefined));
        this.setValue(GetValue$23(config, 'value', 0));
    }

    get enable() {
        if (this.childrenMap.slider) {
            return this.childrenMap.slider.enable;
        } else {
            return false;
        }
    }

    set enable(value) {
        if (this.childrenMap.slider) {
            this.childrenMap.slider.setEnable(value);
        }
    }

    setEnable(enable) {
        if (enable === undefined) {
            enable = true;
        }
        this.enable = enable;
        return this;
    }

    get value() {
        if (this.childrenMap.slider) {
            return this.childrenMap.slider.value;
        } else {
            return 0;
        }
    }

    set value(value) {
        if (!this.childrenMap.slider) {
            return;
        }
        this.childrenMap.slider.value = value;
    }

    setValue(value, min, max) {
        if (this.childrenMap.slider) {
            this.childrenMap.slider.setValue(value, min, max);
        }
        return this;
    }

    addValue(inc, min, max) {
        if (this.childrenMap.slider) {
            this.childrenMap.slider.addValue(inc, min, max);
        }
        return this;
    }

    getValue(min, max) {
        if (this.childrenMap.slider) {
            return this.childrenMap.slider.getValue(min, max);
        } else {
            return 0;
        }
    }

    easeValueTo(value, min, max) {
        if (this.childrenMap.slider) {
            this.childrenMap.slider.easeValueTo(value, min, max);
        }
        return this;
    }

    stopEaseValue() {
        if (this.childrenMap.slider) {
            this.childrenMap.slider.stopEaseValue();
        }
        return this;
    }

    setEaseValueDuration(duration) {
        if (this.childrenMap.slider) {
            this.childrenMap.slider.setEaseValueDuration(duration);
        }
        return this;
    }

    setEaseValueFunction(ease) {
        if (this.childrenMap.slider) {
            this.childrenMap.slider.setEaseValueFunction(ease);
        }
        return this;
    }

    get text() {
        var textObject = this.childrenMap.text;
        if (textObject === undefined) {
            return '';
        }
        var value;
        if (textObject.text) {
            value = textObject.text;
        } else {
            value = textObject.getData('text');
        }
        return value;
    }

    set text(value) {
        var textObject = this.childrenMap.text;
        if (textObject === undefined) {
            return;
        }
        if (textObject.setText) {
            textObject.setText(value);
        } else {
            textObject.setData('text', value);
        }
    }

    setText(value) {
        this.text = value;
        return this;
    }
}

const GetValue$24 = Phaser.Utils.Objects.GetValue;
const BadgeKeys = {
    leftTop: 'left-top', centerTop: 'center-top', rightTop: 'right-top',
    leftCenter: 'left-center', center: 'center', rightCenter: 'right-center',
    leftBottom: 'left-bottom', centerBottom: 'center-bottom', rightBottom: 'right-bottom'
};

class Badge extends OverlapSizer {
    constructor(scene, config) {
        // Create sizer  
        super(scene, config);
        this.type = 'rexBadge';

        // Add elements
        var background = GetValue$24(config, 'background', undefined);
        if (background) {
            this.addBackground(background);
        }
        this.addChildrenMap('background', background);

        // Base item
        var main = GetValue$24(config, 'main', undefined);
        if (main) {
            this.add(main, {
                key: 'main',
                align: 'center',
                expand: false,
            });
        }
        this.addChildrenMap('main', main);

        // Badges
        for (var key in BadgeKeys) {
            var badge = GetValue$24(config, key, undefined);
            if (badge) {
                this.add(badge, {
                    key: key,
                    align: BadgeKeys[key],
                    expand: false,
                });
                this.addChildrenMap(key, badge);
            }            
        }
    }
}

var AddPage = function (gameObject, key, align, padding, expand, minWidth, minHeight) {
    gameObject.setVisible(false); // Default is invisible
    this.add(gameObject, key, align, padding, expand, minWidth, minHeight);
    return this;
};

var GetPage = function (key) {
    if (key === undefined) {
        return null;
    } else if (!this.sizerChildren.hasOwnProperty(key)) {
        return null;
    } else {
        return this.sizerChildren[key];
    }
};

const ContainerSetChildVisible = ContainerLite.prototype.setChildVisible;

var SwapPage = function (key) {
    this._previousKey = this._currentKey;
    var prevoiusPage = this.previousPage;
    if (prevoiusPage) {
        if (this.swapMode === 0) { // Invisible
            ContainerSetChildVisible.call(this, prevoiusPage, false);
            this.emit('pageinvisible', prevoiusPage, this._previousKey, this);
        } else { // Destroy
            prevoiusPage.destroy();
        }
    }

    if (key && !this.sizerChildren.hasOwnProperty(key)) {
        this.emit('createpage', key, this);
    }

    this._currentKey = key;
    var currentPage = this.currentPage;
    if (currentPage) {
        ContainerSetChildVisible.call(this, currentPage, true);
        this.emit('pagevisible', currentPage, this._currentKey, this);
    }
    return this;
};

var Methods$8 = {
    addPage: AddPage,
    getPage: GetPage,
    swapPage: SwapPage
};

const GetValue$25 = Phaser.Utils.Objects.GetValue;

class Pages extends OverlapSizer {
    constructor(scene, config) {
        super(scene, config);
        this.type = 'rexPages';
        this.childrenMap = this.sizerChildren;
        this._previousKey = undefined;
        this._currentKey = undefined;
        this.setSwapMode(GetValue$25(config, 'swapMode', 0));
    }

    setSwapMode(mode) {
        if (typeof (mode) === 'string') {
            mode = SWAPMODE[mode];
        }
        this.swapMode = mode;
        return this;
    }

    get previousKey() {
        return this._previousKey;
    }

    get currentKey() {
        return this._currentKey;
    }

    set currentKey(key) {
        this.swapPage(key);
    }

    get currentPage() {
        return this.getPage(this.currentKey);
    }

    get previousPage() {
        return this.getPage(this.previousKey);
    }

    get keys() {
        return Object.keys(this.sizerChildren);
    }
}

Object.assign(
    Pages.prototype,
    Methods$8
);

const SWAPMODE = {
    invisible: 0,
    destroy: 1
};

var SetText$1 = function (text) {
    if (text !== undefined) {
        this.text = text;
    }

    // Wrap content in lines
    this.lines = TextToLines(this.textObject, this.text, this.lines);

    // Get lines count
    this.linesCount = this.lines.length;

    // Re-calculate these values later
    this._textHeight = undefined;
    this._textVisibleHeight = undefined;

    this.updateTextObject();
    return this;
};

var TextHeightToLinesCount = function (height) {
    // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
    return (height - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing);
};

var LinesCountToTextHeight = function (linesCount) {
    // height = (linesCount * (lineHeight + lineSpacing)) - lineSpacing
    return (linesCount * (this.textLineHeight + this.textLineSpacing)) - this.textLineSpacing;
};

var GetLines$1 = function (startLineIdx) {
    var endLineIdx = startLineIdx + this.visibleLinesCount;
    var text;
    switch (this.textObjectType) {
        case TextType:
            text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
            break;
        case TagTextType:
            var startIdx = this.lines.getLineStartIndex(startLineIdx);
            var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
            text = this.lines.getSliceTagText(startIdx, endIdx, true);
            break;
        case BitmapTextType:
            text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
            break;
    }
    return text;
};

var ResetTextObjectPosition = function () {
    var config = this.textObject.rexSizer;
    this.textObject.y += (config.offsetY - config.preOffsetY);
    config.preOffsetY = config.offsetY;
    this.resetChildPositionState(this.textObject);
};

var UpdateTextObject = function () {
    var startLineIndex = Math.max(Math.floor(TextHeightToLinesCount.call(this, -this.textOY)), 0);
    var textOffset = LinesCountToTextHeight.call(this, startLineIndex) + this.textOY;

    // Grab visible lines
    var text = GetLines$1.call(this, startLineIndex);

    // Display visible content
    SetNoWrapText(this.textObject, text);

    this.textObject.rexSizer.offsetY = textOffset;
    ResetTextObjectPosition.call(this);
    return this;
};

var PreLayout$4 = function () {
    // Style of text
    this._textLineHeight = undefined;
    this._textLineSpacing = undefined;
    // Style of text, width of text
    this._visibleLinesCount = undefined;
    // Style of text, total lines of content
    this._textHeight = undefined;
    this._textVisibleHeight = undefined;

    PreLayout.call(this);
    return this;
};

var ResizeText = function (textObject, width, height) {
    height += this.textLineHeight + this.textLineSpacing; // Add 1 line
    if ((this.textObjectWidth === width) && (this.textObjectHeight === height)) {
        return;
    }
    this.textObjectWidth = width;
    this.textObjectHeight = height;

    switch (this.textObjectType) {
        case TextType:
        case TagTextType:
            textObject.setFixedSize(width, height);

            var style = textObject.style;
            var wrapWidth = Math.max(width, 0);
            if (this.textObjectType === TextType) {  // Built-in text
                style.wordWrapWidth = wrapWidth;
            } else {  // BBCode text, Tag text
                if (style.wrapMode === 0) { // Turn no-wrap to word-wrap
                    style.wrapMode = 1;
                }
                style.wrapWidth = wrapWidth;
            }
            break;
        case BitmapTextType:
            textObject.setMaxWidth(width);
            break;
    }

    // Render content again
    this.setText();
};

var LayoutChildren$5 = function () {
    var child, childConfig, padding;
    var startX = this.left,
        startY = this.top;
    var x, y, width, height; // Align zone

    // LayoutChildren text child
    // Skip invisible child
    child = this.textObject;
    if (!child.rexSizer.hidden) {
        childConfig = child.rexSizer;
        padding = childConfig.padding;
        x = (startX + padding.left);
        y = (startY + padding.top);
        width = this.width - padding.left - padding.right;
        height = this.height - padding.top - padding.bottom;
        ResizeText.call(this, child, width, height);

        AlignIn(child, x, y, width, height, childConfig.align);

        childConfig.preOffsetY = 0; // Clear preOffsetY
        ResetTextObjectPosition.call(this);

        if (this.textMask) {
            this.textMask.setPosition().resize();
            this.resetChildPositionState(this.textMask);
        }

    }
};

var Methods$9 = {
    setText: SetText$1,
    updateTextObject: UpdateTextObject,
    preLayout: PreLayout$4,
    layoutChildren: LayoutChildren$5,
};

const IsPlainObject$p = Phaser.Utils.Objects.IsPlainObject;
const GetValue$26 = Phaser.Utils.Objects.GetValue;
const ALIGN_LEFTTOP = Phaser.Display.Align.TOP_LEFT;

class TextBlock extends Base$2 {
    constructor(scene, x, y, minWidth, minHeight, config) {
        if (IsPlainObject$p(x)) {
            config = x;
            x = GetValue$26(config, 'x', 0);
            y = GetValue$26(config, 'y', 0);
            minWidth = GetValue$26(config, 'width', undefined);
            minHeight = GetValue$26(config, 'height', undefined);
        } else if (IsPlainObject$p(minWidth)) {
            config = minWidth;
            minWidth = GetValue$26(config, 'width', undefined);
            minHeight = GetValue$26(config, 'height', undefined);
        }

        super(scene, x, y, minWidth, minHeight, config);

        this.type = 'rexTextBlock';
        this.textObject = undefined;
        this.linesCount = 0;
        this.textMask = undefined;
        this.textObjectType = undefined;
        this._textLineHeight = undefined;
        this._textLineSpacing = undefined;
        this._visibleLinesCount = undefined;
        this._textHeight = undefined;
        this._textVisibleHeight = undefined;

        this.lines = undefined;
        // Text object : array of string
        // Tag text object : pens-manager
        // Bitmap text object : array of string

        this.text = GetValue$26(config, 'content', '');
        this._textOY = 0;
        this.execeedTopState = false;
        this.execeedBottomState = false;

        this.setClampMode(GetValue$26(config, 'clamplTextOY', true));

        // Add elements
        var background = GetValue$26(config, 'background', undefined);
        var textObject = GetValue$26(config, 'text', undefined);
        if (textObject === undefined) {
            textObject = CreateDefaultTextObject(scene);
        }
        var textMaskEnable = GetValue$26(config, 'textMask', true);

        if (background) {
            this.addBackground(background);
        }

        this.add(textObject);
        this.sizerChildren = [textObject];

        var sizerConfig = this.getSizerConfig(textObject);
        sizerConfig.align = ALIGN_LEFTTOP;
        sizerConfig.padding = GetBoundsConfig(0);
        sizerConfig.expand = true;
        this.textObject = textObject;

        this.textObjectType = GetTextObjectType(textObject);

        // Add more variables
        sizerConfig.preOffsetY = 0;
        sizerConfig.offsetY = 0;

        // Create mask of text object
        if (textMaskEnable) {
            this.textMask = AddChildMask.call(this, this.textObject, this);
        }

        this.addChildrenMap('background', background);
        this.addChildrenMap('text', textObject);
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        this.textObject = undefined;
        this.textMask = undefined;
        if (this.lines) {
            switch (this.textObjectType) {
                case TextType:
                    this.lines.length = 0;
                    break;
                case TagTextType:
                    this.lines.destroy();
                    break;
                case BitmapTextType:
                    this.lines.length = 0;
                    break;
            }
            this.lines = undefined;
        }

        super.destroy(fromScene);
    }

    setClampMode(mode) {
        if (mode === undefined) {
            mode = true;
        }
        this.clampTextOY = mode;
        return this;
    }

    get textLineHeight() {
        if (this._textLineHeight === undefined) {
            var lineHeight;
            switch (this.textObjectType) {
                case TextType:
                case TagTextType:
                    var style = this.textObject.style;
                    lineHeight = style.metrics.fontSize + style.strokeThickness;
                    break;
                case BitmapTextType:
                    var scale = (this.textObject.fontSize / this.textObject.fontData.size);
                    lineHeight = this.textObject.fontData.lineHeight * scale;
                    break;

            }
            this._textLineHeight = lineHeight;
        }
        return this._textLineHeight;
    }

    get textLineSpacing() {
        if (this._textLineSpacing === undefined) {
            var lineSpacing;
            switch (this.textObjectType) {
                case TextType:
                case TagTextType:
                    lineSpacing = this.textObject.lineSpacing;
                    break;
                case BitmapTextType:
                    lineSpacing = 0;
                    break;
            }
            this._textLineSpacing = lineSpacing;
        }
        return this._textLineSpacing;
    }

    get visibleLinesCount() {
        if (this._visibleLinesCount === undefined) {
            this._visibleLinesCount = Math.floor(TextHeightToLinesCount.call(this, this.textObjectHeight));
        }
        return this._visibleLinesCount;
    }

    get topTextOY() {
        return 0;
    }

    get bottomTextOY() {
        return -this.textVisibleHeight;
    }

    get textHeight() {
        if (this._textHeight === undefined) {
            this._textHeight = LinesCountToTextHeight.call(this, this.linesCount);
        }
        return this._textHeight;
    }

    get textVisibleHeight() {
        if (this._textVisibleHeight === undefined) {
            var h;
            var textHeight = this.textHeight;
            var textObjectHeight = this.textObjectHeight - this.textLineHeight - this.textLineSpacing;  // // Remove 1 text line
            if (textHeight > textObjectHeight) {
                h = textHeight - textObjectHeight;
            } else {
                h = 0;
            }
            this._textVisibleHeight = h;
        }
        return this._textVisibleHeight;
    }

    textOYExceedTop(oy) {
        if (oy === undefined) {
            oy = this.textOY;
        }
        return (oy > this.topTextOY);
    }

    textOYExeceedBottom(oy) {
        if (oy === undefined) {
            oy = this.textOY;
        }
        return (oy < this.bottomTextOY);
    }

    get textOY() {
        return this._textOY;
    }

    set textOY(oy) {
        var topTextOY = this.topTextOY;
        var bottomTextOY = this.bottomTextOY;
        var textOYExceedTop = this.textOYExceedTop(oy);
        var textOYExeceedBottom = this.textOYExeceedBottom(oy);

        if (this.clampTextOY) {
            if (this.visibleLinesCount > this.linesCount) {
                oy = 0;
            } else if (textOYExceedTop) {
                oy = topTextOY;
            } else if (textOYExeceedBottom) {
                oy = bottomTextOY;
            }
        }

        if (this._textOY !== oy) {
            this._textOY = oy;
            this.updateTextObject();
        }

        if (textOYExceedTop) {
            if (!this.execeedTopState) {
                this.emit('execeedtop', this, oy, topTextOY);
            }
        }
        this.execeedTopState = textOYExceedTop;

        if (textOYExeceedBottom) {
            if (!this.execeedBottomState) {
                this.emit('execeedbottom', this, oy, bottomTextOY);
            }
        }
        this.execeedBottomState = textOYExeceedBottom;
    }

    setTextOY(oy) {
        this.textOY = oy;
        return this;
    }

    set t(value) {
        this.textOY = -this.textVisibleHeight * value;
    }

    get t() {
        var textVisibleHeight = this.textVisibleHeight;
        if (textVisibleHeight === 0) {
            return 0;
        }
        return (this.textOY / -textVisibleHeight);
    }

    setTextOYByPercentage(percentage) {
        this.t = percentage;
        return this;
    }
}

var CreateDefaultTextObject = function (scene) {
    return scene.add.text(0, 0, '');
};

Object.assign(
    TextBlock.prototype,
    Methods$9
);

var InjectProperties$1 = function(textBlock) {
    Object.defineProperty(textBlock, 'childOY', {
        configurable: true,
        get: function () {
            return textBlock.textOY;
        },
        set: function (value) {
            textBlock.textOY = value;
        }
    });
    Object.defineProperty(textBlock, 'topChildOY', {
        get: function () {
            return textBlock.topTextOY;
        }
    });
    Object.defineProperty(textBlock, 'bottomChildOY', {
        get: function () {
            return textBlock.bottomTextOY;
        }
    });
};

var SetText$2 = function (text) {
    var textBlock = this.childrenMap.child;
    textBlock.setText(text);

    this.resizeController();
    return this;
};

var AppendText$1 = function (text) {
    this.setText(this.text + text);
    return this;
};

const GetValue$27 = Phaser.Utils.Objects.GetValue;

class TextArea extends Scrollable {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        // Create text-block
        var textObject = GetValue$27(config, 'text', undefined);
        var textWidth = GetValue$27(config, 'textWidth', undefined);
        var textHeight = GetValue$27(config, 'textHeight', undefined);
        var textMask = GetValue$27(config, 'textMask', true);
        var content = GetValue$27(config, 'content', '');
        var textBlock = new TextBlock(scene, {
            width: textWidth,
            height: textHeight,
            text: textObject,
            textMask: textMask,
            content: content,
            clamplTextOY: GetValue$27(config, 'clamplChildOY', false)
        });
        scene.add.existing(textBlock); // Important: Add to display list for touch detecting
        var proportion = (textWidth === undefined) ? 1 : 0;
        var expand = (textHeight === undefined);
        // Inject properties for scrollable interface
        InjectProperties$1(textBlock);

        // Fill config of scrollable
        config.scrollMode = 0; // Vertical
        config.type = 'rexTextArea';
        config.child = {
            gameObject: textBlock,
            proportion: proportion,
            expand: expand,
        };
        var spaceConfig = GetValue$27(config, 'space', undefined);
        if (spaceConfig) {
            spaceConfig.child = spaceConfig.text;
        }
        super(scene, config);

        this.addChildrenMap('text', textObject);
    }

    get text() {
        return this.childrenMap.child.text;
    }

    get linesCount() {
        return this.childrenMap.child.linesCount;
    }

    get contentHeight() {
        return this.childrenMap.child.textHeight;
    }
}

var methods$e = {
    setText: SetText$2,
    appendText: AppendText$1,
};
Object.assign(
    TextArea.prototype,
    methods$e
);

var GetChildrenWidth$5 = function () {
    if (this.rexSizer.hidden) {
        return 0;
    }

    var result;
    var child = this.child,
        childConfig = child.rexSizer;
    if (childConfig.hidden) {
        result = 0;
    } else if (this.scrollMode === 0) { // scroll y
        result = this.getChildWidth(child);
    } else { // scroll x
        result = 0;
    }

    return result;
};

var GetChildrenHeight$5 = function () {
    if (this.rexSizer.hidden) {
        return 0;
    }

    var result;
    var child = this.child,
        childConfig = child.rexSizer;
    if (childConfig.hidden) {
        result = 0;
    } else if (this.scrollMode === 0) { // scroll y   
        result = 0;
    } else { // scroll x
        result = (child.isRexSizer) ?
            Math.max(child.minHeight, child.childrenHeight) :
            (child.hasOwnProperty('minHeight')) ? child.minHeight : GetDisplayHeight(child);
    }

    return result;
};

var GetChildrenSizers$5 = function(out) {
    if (out === undefined) {
        out = [];
    }
    if (this.child && this.child.isRexSizer) {
        out.push(this.child);
    }
    return out;
};

var ResetChildPosition = function () {
    var x = this.left;
    var y = this.top;
    if (this.scrollMode === 0) {
        y += this.childOY;
    } else {
        x += this.childOY;
    }
    this.child.setPosition(x, y);
    this.resetChildPositionState(this.child);

    this.setMaskChildrenFlag();
};

var LayoutChildren$6 = function () {
    // LayoutChildren child
    var child = this.child;
    var childWidth, childHeight;
    if (!child.rexSizer.hidden) {
        // Set size
        if (this.scrollMode === 0) {
            childWidth = this.width;
        } else {
            childHeight = this.height;
        }
        if (child.isRexSizer) {
            child.runLayout(this, childWidth, childHeight);
        } else {
            ResizeGameObject(child, childWidth, childHeight);
        }

        // Layout children-mask
        this.layoutChildrenMask();
        // Update local state
        this.resetChildPosition();
        // Re-mask children
        this.maskChildren();
    }
};

const MASKUPDATEMODE$1 = {
    update: 0,
    everyTick: 1
};

var ChildrenMaskMethods = {
    setMaskUpdateMode(mode) {
        if (typeof (mode) === 'string') {
            mode = MASKUPDATEMODE$1[mode];
        }
        this.maskUpdateMode = mode;
        return this;
    },

    startMaskUpdate() {
        this.scene.game.events.on('poststep', this.maskChildren, this);
    },

    stopMaskUpdate() {
        this.scene.game.events.off('poststep', this.maskChildren, this);
    },

    enableChildrenMask(maskPadding) {
        var maskGameObject = AddChildMask.call(this, null, this, 0, maskPadding);
        this.childrenMask = maskGameObject.createGeometryMask();
        // this.childrenMask is a mask object, not a (Graphics) game object
        return this;
    },

    setMaskChildrenFlag(value) {
        if (value === undefined) {
            value = true;
        }
        this.maskChildrenFlag = value;
        return this;
    },

    maskChildren() {
        if (!this.childrenMask) {
            // No childrenMask
            return this;
        } else if (!this.maskChildrenFlag) {
            // No maskCells flag
            return this;
        } else if ((this.alpha === 0) || (!this.visible)) {
            // Parent is not visible
            return this;
        }

        MaskChildren(this, this.childrenMask, this.getAllChildren());

        if (this.maskUpdateMode === 0) {
            this.maskChildrenFlag = false;
        }
        return this;
    },

    layoutChildrenMask() {
        if (this.childrenMask === undefined) {
            return this;
        }

        var maskGameObject = MaskToGameObject(this.childrenMask);
        maskGameObject.setPosition().resize();
        this.resetChildPositionState(maskGameObject);
        return this;
    }
};

var methods$f = {
    getChildrenWidth: GetChildrenWidth$5,
    getChildrenHeight: GetChildrenHeight$5,
    getChildrenSizers: GetChildrenSizers$5,
    resetChildPosition: ResetChildPosition,
    layoutChildren: LayoutChildren$6
};

Object.assign(
    methods$f,
    ChildrenMaskMethods
);

const IsPlainObject$q = Phaser.Utils.Objects.IsPlainObject;
const GetValue$28 = Phaser.Utils.Objects.GetValue;
const ALIGN_LEFTTOP$1 = Phaser.Display.Align.TOP_LEFT;

class ScrollableBlock extends Base$2 {
    constructor(scene, x, y, minWidth, minHeight, config) {
        if (IsPlainObject$q(x)) {
            config = x;
            x = GetValue$28(config, 'x', 0);
            y = GetValue$28(config, 'y', 0);
            minWidth = GetValue$28(config, 'width', undefined);
            minHeight = GetValue$28(config, 'height', undefined);
        } else if (IsPlainObject$q(minWidth)) {
            config = minWidth;
            minWidth = GetValue$28(config, 'width', undefined);
            minHeight = GetValue$28(config, 'height', undefined);
        }
        super(scene, x, y, minWidth, minHeight, config);

        this.type = 'rexScrollableBlock';
        this.child = undefined;
        this.childrenMask = undefined;
        this._childOY = 0;
        this.execeedTopState = false;
        this.execeedBottomState = false;

        this.setScrollMode(GetValue$28(config, 'scrollMode', true));
        this.setClampMode(GetValue$28(config, 'clamplChildOY', true));

        // Add elements
        // No background object, and child does not have padding
        var child = GetValue$28(config, 'child', undefined);
        var expand = GetValue$28(config, 'expand', true);
        var maskConfig = GetValue$28(config, 'mask', undefined);

        if (child.setOrigin) {
            child.setOrigin(0);
        }

        this.add(child);
        this.sizerChildren = [child];

        var sizerConfig = this.getSizerConfig(child);
        sizerConfig.align = ALIGN_LEFTTOP$1;
        sizerConfig.expand = expand;
        this.child = child;

        // Create mask of child object
        var maskEnable, maskPadding, maskUpdateMode;
        if (maskConfig === true) {
            maskEnable = true;
            maskPadding = 0;
            maskUpdateMode = 0;
        } else if (maskConfig === false) {
            maskEnable = false;
        } else {
            maskEnable = GetValue$28(maskConfig, 'mask', true);
            maskPadding = GetValue$28(maskConfig, 'padding', 0);
            maskUpdateMode = GetValue$28(config, 'updateMode', 0);
        }

        if (maskEnable) {
            this.setMaskUpdateMode(maskUpdateMode);
            this.enableChildrenMask(maskPadding);
            this.startMaskUpdate();
        }
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        if (this.childrenMask) {
            this.stopMaskUpdate();
        }

        this.child = undefined;
        if (this.childrenMask) {
            this.childrenMask.destroy();
            this.childrenMask = undefined;
        }

        super.destroy(fromScene);
    }

    setScrollMode(mode) {
        if (typeof (mode) === 'string') {
            mode = SCROLLMODE[mode.toLowerCase()];
        }
        this.scrollMode = mode;
        return this;
    }

    setClampMode(mode) {
        if (mode === undefined) {
            mode = true;
        }
        this.clampChildOY = mode;
        return this;
    }

    get instHeight() {
        return (this.scrollMode === 0) ? this.height : this.width;
    }

    get instWidth() {
        return (this.scrollMode === 0) ? this.width : this.height;
    }

    get childHeight() {
        return (this.scrollMode === 0) ? GetDisplayHeight(this.child) : GetDisplayWidth(this.child);
    }

    get childWidth() {
        return (this.scrollMode === 0) ? GetDisplayWidth(this.child) : GetDisplayHeight(this.child);
    }

    get topChildOY() {
        return 0;
    }

    get bottomChildOY() {
        return -this.visibleHeight;
    }

    get visibleHeight() {
        var h;
        var childHeight = this.childHeight;
        var instHeight = this.instHeight;
        if (childHeight > instHeight) {
            h = childHeight - instHeight;
        } else {
            h = 0;
        }

        return h;
    }

    childOYExceedTop(oy) {
        if (oy === undefined) {
            oy = this.childOY;
        }
        return (oy > this.topChildOY);
    }

    childOYExeceedBottom(oy) {
        if (oy === undefined) {
            oy = this.childOY;
        }
        return (oy < this.bottomChildOY);
    }

    get childOY() {
        return this._childOY;
    }

    set childOY(oy) {
        var topChildOY = this.topChildOY;
        var bottomChildOY = this.bottomChildOY;
        var childOYExceedTop = this.childOYExceedTop(oy);
        var childOYExeceedBottom = this.childOYExeceedBottom(oy);

        if (this.clampChildOY) {
            if (this.instHeight > this.childHeight) {
                oy = 0;
            } else if (childOYExceedTop) {
                oy = topChildOY;
            } else if (childOYExeceedBottom) {
                oy = bottomChildOY;
            }
        }

        if (this._childOY !== oy) {
            this._childOY = oy;
            this.resetChildPosition();
        }

        if (childOYExceedTop) {
            if (!this.execeedTopState) {
                this.emit('execeedtop', this, oy, topChildOY);
            }
        }
        this.execeedTopState = childOYExceedTop;

        if (childOYExeceedBottom) {
            if (!this.execeedBottomState) {
                this.emit('execeedbottom', this, oy, bottomChildOY);
            }
        }
        this.execeedBottomState = childOYExeceedBottom;
    }

    setChildOY(oy) {
        this.childOY = oy;
        return this;
    }

    set t(value) {
        this.childOY = -this.visibleHeight * value;
    }

    get t() {
        var visibleHeight = this.visibleHeight;
        if (visibleHeight === 0) {
            return 0;
        }
        return (this.childOY / -visibleHeight);
    }

    setChildOYByPercentage(percentage) {
        this.t = percentage;
        return this;
    }
}

Object.assign(
    ScrollableBlock.prototype,
    methods$f
);

const GetValue$29 = Phaser.Utils.Objects.GetValue;

class ScrollablePanel extends Scrollable {
    constructor(scene, config) {
        if (config === undefined) {
            config = {};
        }

        // Create scrollable-block
        var scrollMode = GetScrollMode(config);
        var panelConfig = GetValue$29(config, 'panel', undefined);
        if (panelConfig === undefined) {
            panelConfig = {};
        }
        panelConfig.scrollMode = scrollMode;
        panelConfig.clamplChildOY = GetValue$29(config, 'clamplChildOY', false);
        var scrollableBlock = new ScrollableBlock(scene, panelConfig);
        scene.add.existing(scrollableBlock); // Important: Add to display list for touch detecting
        var panelWidth = GetValue$29(panelConfig, 'width', undefined);
        var panelHeight = GetValue$29(panelConfig, 'height', undefined);
        var proportion, expand;
        if (scrollMode === 0) {
            proportion = (panelWidth === undefined) ? 1 : 0;
            expand = (panelHeight === undefined);
        } else {
            proportion = (panelHeight === undefined) ? 1 : 0;
            expand = (panelWidth === undefined);
        }

        // Fill config of scrollable
        config.type = 'rexScrollablePanel';
        config.child = {
            gameObject: scrollableBlock,
            proportion: proportion,
            expand: expand,
        };
        var spaceConfig = GetValue$29(config, 'space', undefined);
        if (spaceConfig) {
            spaceConfig.child = spaceConfig.panel;
        }
        super(scene, config);

        this.addChildrenMap('panel', this.childrenMap.child.child);
    }
}

var DefaultTransitCallbacks = {
    popUp: function (gameObject, duration) {
        gameObject.popUp(duration);
    },

    scaleDown: function (gameObject, duration) {
        gameObject.scaleDown(duration);
    },

    fadeIn: function (gameObject, duration) {
        gameObject.fadeIn(duration);
    },

    fadeOut: function (gameObject, duration) {
        gameObject.fadeOut(duration);
    },
};

var Copy = function (dest, src, startIdx, endIdx) {
    if (startIdx === undefined) {
        startIdx = 0;
    }    if (endIdx === undefined) {
        endIdx = src.length;
    }
    dest.length = endIdx - startIdx;
    for (var i = 0, len = dest.length; i < len; i++) {
        dest[i] = src[i + startIdx];
    }
    return dest;
};

const GetValue$2a = Phaser.Utils.Objects.GetValue;

var RunCommands = function (queue, scope, config) {
    var reverse = GetValue$2a(config, 'reverse', false);

    var retVal;
    if (IsArray(queue[0])) {
        if (!reverse) {
            for (var i = 0, len = queue.length; i < len; i++) {
                retVal = RunCommands(queue[i], scope, config);
            }
        } else {
            for (var len = queue.length, i = len - 1; i >= 0; i--) {
                retVal = RunCommands(queue[i], scope, config);
            }
        }
    } else {
        retVal = RunCommand(queue, scope, config);
    }

    return retVal;
};

var RunCommand = function (cmd, scope, config) {
    var argsConvert = GetValue$2a(config, 'argsConvert', undefined);
    var argsConvertScope = GetValue$2a(config, 'argsConvertScope', undefined);

    var fnName = cmd[0];

    ARGS = Copy(ARGS, cmd, 1);
    if (argsConvert) {
        // convert string to floating number, boolean, null, or string        
        if (argsConvert === true) {
            argsConvert = convert;
            argsConvertScope = undefined;
        }
        for (var i = 0, len = ARGS.length; i < len; i++) {
            if (argsConvertScope) {
                ARGS[i] = argsConvert.call(argsConvertScope, ARGS[i], cmd);
            } else {
                ARGS[i] = argsConvert(ARGS[i], cmd);
            }
        }
    }

    var fn;
    if (typeof (fnName) === 'string') {
        fn = scope[fnName];
        if (fn == null) {
            fn = GetValue$2a(scope, fnName, null);
        }
    } else {
        fn = fnName;
    }

    var retValue = fn.apply(scope, ARGS);
    return retValue;
};
var ARGS = []; // reuse this array

const GetValue$2b = Phaser.Utils.Objects.GetValue;

class Player extends ComponentBase {
    constructor(parent, config) {
        super(parent, config);

        var clockClass = GetValue$2b(config, 'clockClass', Clock);
        this.clock = new clockClass(parent);
        this.clock.on('update', this.update, this);

        this.resetFromJSON(config); // this function had been called in super(config)
    }

    resetFromJSON(o) {
        this.clock.resetFromJSON(GetValue$2b(o, 'clock', undefined));
        this.state = GetValue$2b(o, 'state', 0); // 0=idle, 1=run, 2=completed
        this.commands = GetValue$2b(o, 'commands', []); // [[time, cmds], [time, cmds], ...]
        this.scope = GetValue$2b(o, 'scope', undefined);
        this.setTimeUnit(GetValue$2b(o, 'timeUnit', 0));
        this.setDtMode(GetValue$2b(o, 'dtMode', 0));
        this.index = GetValue$2b(o, 'index', 0);
        this.nextTime = GetValue$2b(o, 'nextTime', 0);
        return this;
    }

    toJSON() {
        return {
            clock: this.clock.toJSON(),
            state: this.state,
            commands: this.commands,
            scope: this.scope,
            timeUnit: this.timeUnit,
            dtMode: this.dtMode,
            index: this.index,
            nextTime: this.nextTime
        };
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        this.clock.shutdown(fromScene);
        this.commands = undefined;

        super.shutdown(fromScene);
    }

    load(commands, scope, config) {
        this.stop();
        var timeUnit = GetValue$2b(config, 'timeUnit', undefined);
        if (timeUnit !== undefined) {
            this.setTimeUnit(timeUnit);
        }
        var dtMode = GetValue$2b(config, 'dtMode', undefined);
        if (dtMode !== undefined) {
            this.setDtMode(dtMode);
        }
        commands = commands
            .filter(function (item) {
                var dt = item[0];
                return !isNaN(dt);
            })
            .map(function (item) {
                var dt = item[0];
                if (typeof (dt) === 'string') {
                    item[0] = parseFloat(item[0]);
                }
                return item;
            });

        if (this.dtMode === 0) {
            commands.sort(function (itemA, itemB) {
                var dtA = itemA[0],
                    dtB = itemB[0];
                return (dtA > dtB) ? 1 :
                    (dtA < dtB) ? -1 : 0;
            });
        }

        this.commands = commands;
        this.scope = scope;
        return this;
    }

    start(startAt) {
        if (startAt === undefined) {
            startAt = 0;
        }

        this.stop();

        this.index = 0;
        this.state = 1;
        this.nextTime = this.getNextDt(0);

        this.clock.start(startAt);
        this.update(startAt);
        return this;
    }

    pause() {
        this.clock.pause();
        return this;
    }

    resume() {
        this.clock.resume();
        return this;
    }

    stop() {
        this.clock.stop();
        this.state = 0;
        return this;
    }

    seek(time) {
        this.clock.seek(time);
        return this;
    }

    get isPlaying() {
        return this.clock.isRunning;
    }

    get completed() {
        return (this.state === 2);
    }

    get timeScale() {
        return this.clock.timeScale;
    }

    set timeScale(timeScale) {
        this.clock.timeScale = timeScale;
    }

    setTimeScale(timeScale) {
        this.timeScale = timeScale;
        return this;
    }

    get now() {
        return this.clock.now;
    }

    update(now) {
        if (this.nextTime > now) {
            return this;
        }
        var lastCommandIndex = this.commands.length - 1;
        while (1) {
            // Execute a command
            var item = this.commands[this.index];
            var command = item[1];
            if (!IsArray(command)) { // [dt, fnName, param0, param1, ...]
                command = Copy(CMD, item, 1);
            }
            RunCommands(command, this.scope);
            this.emit('runcommand', command, this.scope);
            // Execute a command

            if (this.index === lastCommandIndex) {
                this.complete();
                return this;
            } else {
                // Get next time
                this.index++; // Point to next command
                this.nextTime = this.getNextDt(this.nextTime);
                if (this.nextTime > now) {
                    return this;
                }
                // Get next time
            }

        }
    }

    complete() {
        this.clock.stop();
        this.state = 2;
        this.emit('complete', this.parent, this);
    }

    getNextDt(currentDt) {
        var time = this.commands[this.index][0];
        if (this.timeUnit === 1) { // Second mode
            time = time * 1000;
        }

        if (this.dtMode === 1) {
            time += currentDt;
        }

        return time;
    }

    setDtMode(dtMode) {
        if (typeof (dtMode) === 'string') {
            dtMode = DTMODE[dtMode];
        }
        this.dtMode = dtMode;
        return this;
    }

    setTimeUnit(timeUnit) {
        if (typeof (timeUnit) === 'string') {
            timeUnit = TIMEUNITMODE[timeUnit];
        }
        this.timeUnit = timeUnit;
        return this;
    }
}

var CMD = []; // reuse this array

const TIMEUNITMODE = {
    ms: 0,
    s: 1,
    sec: 1,
};

const DTMODE = {
    abs: 0,
    absolute: 0,
    inc: 1,
    increment: 1
};

const GetValue$2c = Phaser.Utils.Objects.GetValue;

class Toast extends Label {
    constructor(scene, config) {
        if (config === undefined) {
            config = {
                text: createDefaultTextObject(scene)
            };
        }

        super(scene, config);
        this.type = 'rexToast';

        this.setTransitInTime(GetValue$2c(config, 'duration.in', 200));
        this.setDisplayTime(GetValue$2c(config, 'duration.hold', 1200));
        this.setTransitOutTime(GetValue$2c(config, 'duration.out', 200));
        this.setTransitInCallback(GetValue$2c(config, 'transitIn', TransitionMode.popUp));
        this.setTransitOutCallback(GetValue$2c(config, 'transitOut', TransitionMode.scaleDown));

        this.player = new Player(this, { dtMode: 1 });
        this.messages = [];

        this.setVisible(false);
    }

    destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
            return;
        }

        this.player.destroy();
        this.player = undefined;
        this.messages = undefined;

        super.destroy(fromScene);
    }

    setDisplayTime(time) {
        this.displayTime = time;
        return this;
    }

    setTransitOutTime(time) {
        this.transitOutTime = time;
        return this;
    }

    setTransitInTime(time) {
        this.transitInTime = time;
        return this;
    }

    setTransitInCallback(callback) {
        if (typeof (callback) === 'string') {
            callback = TransitionMode[callback];
        }

        switch (callback) {
            case TransitionMode.popUp:
                callback = DefaultTransitCallbacks.popUp;
                break;
            case TransitionMode.fadeIn:
                callback = DefaultTransitCallbacks.fadeIn;
                break;
        }

        this.transitInCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
    }

    setTransitOutCallback(callback) {
        if (typeof (callback) === 'string') {
            callback = TransitionMode[callback];
        }

        switch (callback) {
            case TransitionMode.scaleDown:
                callback = DefaultTransitCallbacks.scaleDown;
                break;
            case TransitionMode.fadeOut:
                callback = DefaultTransitCallbacks.fadeOut;
                break;
        }

        this.transitOutCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
    }

    showMessage(callback) {
        if (callback === undefined) {
            // Try pop up a pendding message
            if (this.messages.length === 0) {
                return this;
            }
            callback = this.messages.shift();
        }

        if (this.player.isPlaying) {
            // Pend message
            this.messages.push(callback);
            return this;
        }

        // Recover to initial state
        this
            .setScale(1, 1)
            .setVisible(true);
        if (typeof (callback) === 'string') {
            this.setText(callback);
        } else {
            callback(this);
        }
        this.layout();

        var commands = [
            [ // Transit-in
                0, // time
                [this.transitInCallback, this, this.transitInTime] // [callback, param, ...]
            ],
            [ // Hold
                this.transitInTime,
                [NOOP]
            ],
            [ // Transit-out
                this.displayTime,
                [this.transitOutCallback, this, this.transitOutTime]
            ],
            [ // End
                this.transitOutTime,
                [this.setVisible, false]
            ],
            [ // Complete - show next message
                30, // Add a small delay before complete
                [NOOP]
            ]
        ];
        this.player
            .load(commands, this)
            .once('complete', function () {
                this.showMessage();
            }, this)
            .start();

        return this;
    }
}

const TransitionMode = {
    popUp: 0,
    fadeIn: 1,
    scaleDown: 0,
    fadeOut: 1,
};

var GetShowCallback = function () {
    return function (child, key, sides, reset) {
        if (key !== 'panel') {
            sides.setChildVisible(child, true);
        }
    }
};

var GetHideCallback = function () {
    return function (child, key, sides, reset) {
        if (key !== 'panel') {
            sides.setChildVisible(child, false);
        }
    }
};

var VisibleCallbacks = {
    show: GetShowCallback,
    hide: GetHideCallback
};

var GetShowCallback$1 = function (duration, alpha) {
    if (alpha === undefined) {
        alpha = 1;
    }
    return function (child, key, sides, reset) {
        if (key !== 'panel') {
            sides.fadeChild(child, ((reset) ? 0 : duration), alpha);
        }
    }
};

var GetHideCallback$1 = function (duration, alpha) {
    if (alpha === undefined) {
        alpha = 0;
    }
    return function (child, key, sides, reset) {
        if (key !== 'panel') {
            sides.fadeChild(child, ((reset) ? 0 : duration), alpha);
        }
    }
};

var FadeCallbacks = {
    show: GetShowCallback$1,
    hide: GetHideCallback$1
};

var GetCallback = function (duration, ease) {
    return function (child, key, sides, reset) {
        if (key !== 'panel') {
            sides.moveChild(child, ((reset) ? 0 : duration), ease);
        }
    }
};

var MoveCallbacks = {
    show: GetCallback,
    hide: GetCallback
};

var GetCallback$1 = function (duration, ease) {
    return function (child, key, sides, reset) {
        if (key === 'panel') {
            sides.moveChild(child, ((reset) ? 0 : duration), ease);
        }
    }
};

var MovePanelCallbacks = {
    show: GetCallback$1,
    hide: GetCallback$1
};

const DefaultCallbacks = {
    visible: VisibleCallbacks,
    fade: FadeCallbacks,
    move: MoveCallbacks,
    'move-panel': MovePanelCallbacks
};

var GetDefaultCallbacks = function (config) {
    var callbackType, callbackParams;
    [callbackType, ...callbackParams] = (typeof (config) === 'string') ? [config] : config;

    var showCallback, hideCallback;
    if (DefaultCallbacks.hasOwnProperty(callbackType)) {
        showCallback = DefaultCallbacks[callbackType].show.apply(null, callbackParams);
        hideCallback = DefaultCallbacks[callbackType].hide.apply(null, callbackParams);
    } else {
        showCallback = NOOP;
        hideCallback = NOOP;
    }
    return {
        show: showCallback,
        hide: hideCallback
    }
};

var ShowChildMethods = {
    showChild(key, reset) {
        var child = this.sizerChildren[key];
        if (child) {
            this.emit('showchild', child, key, this, reset);
            this.resetChildState(child);
        }
        return this;
    },

    hideChild(key, reset) {
        var child = this.sizerChildren[key];
        if (child) {
            this.emit('hidechild', child, key, this, reset);
            this.resetChildState(child);
        }
        return this;
    },

    swapChild(key, reset) {
        if (this.currentChildKey === key) ; else if ((this.currentChildKey === 'panel') || (key === 'panel')) {
            this.previousChildKey = this.currentChildKey;
            this.currentChildKey = key;
            this.hideChild(this.previousChildKey, reset);
            this.showChild(this.currentChildKey, reset);
        } else { // Swap from current side to another side
            this.swapChild('panel', reset);
            this.swapChild(key, reset);
        }
        return this;
    },

    showPanel(reset) {
        this.swapChild('panel', reset);
        return this;
    },

    showLeftSide() {
        this.swapChild('leftSide');
        return this;
    },

    showRightSide() {
        this.swapChild('rightSide');
        return this;
    },

    showTopSide() {
        this.swapChild('topSide');
        return this;
    },

    showBottomSide() {
        this.swapChild('bottomSide');
        return this;
    },

    hideLeftSide() {
        if (this.currentChildKey == 'leftSide') {
            this.showPanel();
        }
        return this;
    },

    hideRightSide() {
        if (this.currentChildKey == 'rightSide') {
            this.showPanel();
        }
        return this;
    },

    hideTopSide() {
        if (this.currentChildKey == 'topSide') {
            this.showPanel();
        }
        return this;
    },

    hideBottomSide() {
        if (this.currentChildKey == 'bottomSide') {
            this.showPanel();
        }
        return this;
    },

    toggleLeftSide() {
        var key = (this.currentChildKey !== 'panel') ? 'panel' : 'leftSide';
        this.swapChild(key);
        return this;
    },

    toggleRightSide() {
        var key = (this.currentChildKey !== 'panel') ? 'panel' : 'rightSide';
        this.swapChild(key);
        return this;
    },

    toggleTopSide() {
        var key = (this.currentChildKey !== 'panel') ? 'panel' : 'topSide';
        this.swapChild(key);
        return this;
    },

    toggleBottomSide() {
        var key = (this.currentChildKey !== 'panel') ? 'panel' : 'bottomSide';
        this.swapChild(key);
        return this;
    }
};

const ContainerSetChildVisible$1 = ContainerLite.prototype.setChildVisible;

var Visible$1 = {
    setChildVisible(child, visible) {
        var key;
        if (typeof (child) === 'string') {
            var key = child;
            child = this.sizerChildren[key];
        } else {
            key = IndexOf(this.sizerChildren, child);
        }
        if (visible === undefined) {
            visible = (this.currentChildKey === key) ? true : false;
        }
        ContainerSetChildVisible$1.call(this, child, visible);
        return this;
    }
};

var Fade$2 = {
    fadeChild(child, duration, alpha) {
        var key;
        if (typeof (child) === 'string') {
            key = child;
            child = this.sizerChildren[key];
        } else {
            key = IndexOf(this.sizerChildren, child);
        }
        if (duration === undefined) {
            duration = 500;
        }
        if (alpha === undefined) {
            alpha = (this.currentChildKey === key) ? 1 : 0;
        }

        child.fadeIn(duration, { start: child.alpha, end: alpha });
        return this;
    },

    fadeChildPromise(child, duration, alpha) {
        if (typeof (child) === 'string') {
            child = this.sizerChildren[key];
        }
        this.fadeChild(child, duration, alpha);

        if (child._fade) {
            return WaitComplete(child._fade);
        } else {
            return Promise.resolve();
        }
    }
};

var Move = {
    moveChild(child, duration, ease, distance) {
        var key;
        if (typeof (child) === 'string') {
            key = child;
            child = this.sizerChildren[key];
        } else {
            key = IndexOf(this.sizerChildren, child);
        }

        if (duration === undefined) {
            duration = 500;
        }

        var isShownChild = (this.currentChildKey === key);

        if (distance === undefined) {
            switch (key) {
                case 'leftSide':
                case 'rightSide':
                    distance = GetDisplayWidth(child);
                    break;
                case 'topSide':
                case 'bottomSide':
                    distance = GetDisplayHeight(child);
                    break;
                default: // 'panel'
                    if (isShownChild) { // Show panel
                        switch (this.previousChildKey) {
                            case 'leftSide':
                            case 'rightSide':
                                distance = GetDisplayWidth(this.sizerChildren[this.previousChildKey]);
                                break;
                            case 'topSide':
                            case 'bottomSide':
                                distance = GetDisplayHeight(this.sizerChildren[this.previousChildKey]);
                                break;
                            default:
                                distance = 0;
                                break;
                        }
                    } else { // Hide panel
                        switch (this.currentChildKey) {
                            case 'leftSide':
                            case 'rightSide':
                                distance = GetDisplayWidth(this.sizerChildren[this.currentChildKey]);
                                break;
                            case 'topSide':
                            case 'bottomSide':
                                distance = GetDisplayHeight(this.sizerChildren[this.currentChildKey]);
                                break;
                            default:
                                distance = 0;
                                break;
                        }
                    }
                    break;
            }
        }

        var moveLeft, moveRight, moveUp, moveDown;
        if (isShownChild) {
            switch (key) {
                case 'panel':
                    switch (this.previousChildKey) {
                        case 'leftSide':
                            moveLeft = true;
                            break;
                        case 'rightSide':
                            moveRight = true;
                            break;
                        case 'topSide':
                            moveUp = true;
                            break;
                        case 'bottomSide':
                            moveDown = true;
                            break;
                    }
                    break;
                case 'leftSide':
                    moveRight = true;
                    break;
                case 'rightSide':
                    moveLeft = true;
                    break;
                case 'topSide':
                    moveDown = true;
                    break;
                case 'bottomSide':
                    moveUp = true;
                    break;
            }
        } else { // Hide
            switch (key) {
                case 'panel':
                    switch (this.currentChildKey) {
                        case 'leftSide':
                            moveRight = true;
                            break;
                        case 'rightSide':
                            moveLeft = true;
                            break;
                        case 'topSide':
                            moveDown = true;
                            break;
                        case 'bottomSide':
                            moveUp = true;
                            break;
                    }
                    break;
                case 'leftSide':
                    moveLeft = true;
                    break;
                case 'rightSide':
                    moveRight = true;
                    break;
                case 'topSide':
                    moveUp = true;
                    break;
                case 'bottomSide':
                    moveDown = true;
                    break;
            }
        }

        if (moveLeft) {
            child.moveTo(duration, `-=${distance}`, undefined, ease);
        } else if (moveRight) {
            child.moveTo(duration, `+=${distance}`, undefined, ease);
        } else if (moveUp) {
            child.moveTo(duration, undefined, `-=${distance}`, ease);
        } else if (moveDown) {
            child.moveTo(duration, undefined, `+=${distance}`, ease);
        } else {
            child.moveTo(0);
        }
        return this;
    },

    moveChildPromise(child, duration, ease, distance) {
        if (typeof (child) === 'string') {
            child = this.sizerChildren[key];
        }
        this.moveChild(child, duration, ease, distance);

        if (child._easeMove) {
            return WaitComplete(child._easeMove);
        } else {
            return Promise.resolve();
        }
    }
};

var methods$g = {};

Object.assign(
    methods$g,
    Visible$1,
    Fade$2,
    Move
);

const GetValue$2d = Phaser.Utils.Objects.GetValue;

class Sides extends OverlapSizer {
    constructor(scene, config) {
        super(scene, config);
        this.type = 'rexSides';
        this.childrenMap = this.sizerChildren;
        this.previousChildKey = undefined;
        this.currentChildKey = undefined;

        // Callbacks
        var showChildCallback = GetValue$2d(config, 'showChildCallback', undefined);
        if (showChildCallback) { // Has showChildCallback, and hideChildCallback
            if (IsFunction(showChildCallback)) { // Custom callbacks
                var showChildCallbackScope = GetValue$2d(config, 'showChildCallbackScope', undefined);
                this.on('showchild', showChildCallback, showChildCallbackScope);

                var hideChildCallback = GetValue$2d(config, 'hideChildCallback', undefined);
                var hideChildCallbackScope = GetValue$2d(config, 'hideChildCallbackScope', undefined);
                this.on('hidechild', hideChildCallback, hideChildCallbackScope);
            } else { // Default callbacks
                var defaultCallbacks = GetDefaultCallbacks(showChildCallback);
                this.on('showchild', defaultCallbacks.show);
                this.on('hidechild', defaultCallbacks.hide);
            }
        }

        // Add elements
        var background = GetValue$2d(config, 'background', undefined);
        var panel = GetValue$2d(config, 'panel', undefined);
        var leftSide = GetValue$2d(config, 'leftSide', undefined);
        var rightSide = GetValue$2d(config, 'rightSide', undefined);
        var topSide = GetValue$2d(config, 'topSide', undefined);
        var bottomSide = GetValue$2d(config, 'bottomSide', undefined);

        if (background) {
            this.addBackground(background);
        }
        if (panel) {
            this.add(panel, 'panel', 'center', 0, true);
        }
        if (leftSide) {
            var expand = GetValue$2d(config, 'expand.left', true);
            this.add(leftSide, 'leftSide', 'left-top', 0, { height: expand });
        }
        if (rightSide) {
            var expand = GetValue$2d(config, 'expand.right', true);
            this.add(rightSide, 'rightSide', 'right-top', 0, { height: expand });
        }
        if (topSide) {
            var expand = GetValue$2d(config, 'expand.top', true);
            this.add(topSide, 'topSide', 'left-top', 0, { width: expand });
        }
        if (bottomSide) {
            var expand = GetValue$2d(config, 'expand.bottom', true);
            this.add(bottomSide, 'bottomSide', 'left-bottom', 0, { width: expand });
        }
    }

    reset() {
        this.previousChildKey = undefined;
        this.currentChildKey = 'panel';
        this.showChild('panel', true);
        this.hideChild('leftSide', true);
        this.hideChild('rightSide', true);
        this.hideChild('topSide', true);
        this.hideChild('bottomSide', true);
        return this;
    }
}

Object.assign(
    Sides.prototype,
    ShowChildMethods,
    methods$g
);

const IsPlainObject$r = Phaser.Utils.Objects.IsPlainObject;
const GetValue$2e = Phaser.Utils.Objects.GetValue;

var GetFrameUpdatingCallback = function (key, frame, gameObject) {
    var callback;
    if (key === undefined) {
        key = gameObject.texture.key;
        frame = gameObject.frame.name;
    } else if (IsPlainObject$r(key)) {
        var config = key;
        key = GetValue$2e(config, 'key', gameObject.texture.key);
        frame = GetValue$2e(config, 'frame', gameObject.frame.name);
    } else if (typeof (key) === 'string') ; else {
        callback = key;
    }

    if (callback === undefined) {
        callback = function (gameObject) {
            gameObject.setTexture(key, frame);
        };
    }
    return callback;
};

const GetValue$2f = Phaser.Utils.Objects.GetValue;
const GetAdvancedValue$6 = Phaser.Utils.Objects.GetAdvancedValue;
const Linear$c = Phaser.Math.Linear;

class Flip extends EaseValueTaskBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;
        // this.timer

        this.resetFromJSON(config);
        this.boot();
    }

    resetFromJSON(o) {
        super.resetFromJSON(o);
        this.setDuration(GetAdvancedValue$6(o, 'duration', 500));
        this.setEase(GetValue$2f(o, 'ease', 'Sine'));

        this.setOrientation(GetValue$2f(o, 'orientation', 0));
        this.setFrontFace(GetValue$2f(o, 'front', undefined));
        this.setBackFace(GetValue$2f(o, 'back', undefined));
        this.setFace(GetValue$2f(o, 'face', 0));
        return this;
    }

    setOrientation(orientation) {
        if (typeof (orientation) === 'string') {
            orientation = ORIENTATIONMODE$1[orientation];
        }
        this.orientation = orientation;
        return this;
    }

    get face() {
        return this._face;
    }

    set face(face) {
        if (typeof (face) === 'string') {
            face = FACEMODE[face];
        }
        this._face = face;
        if ((face === 0) && this.frontFaceCallback) {
            this.frontFaceCallback(this.parent);
        } else if ((face === 1) && this.backFaceCallback) {
            this.backFaceCallback(this.parent);
        }
    }

    setFace(face) {
        this.face = face;
        return this;
    }

    toggleFace() {
        var newFace = (this.face === 0) ? 1 : 0;
        this.setFace(newFace);
        return this;
    }

    setFrontFace(key, frame) {
        this.frontFaceCallback = GetFrameUpdatingCallback(key, frame, this.parent);
        return this;
    }

    setBackFace(key, frame) {
        this.backFaceCallback = GetFrameUpdatingCallback(key, frame, this.parent);
        return this;
    }

    start() {
        if (this.timer.isRunning) {
            return this;
        }

        this.timer
            .setDelay(this.delay)
            .setDuration(this.duration / 2)
            .setRepeat(1);  // 2 times

        super.start();
        return this;
    }

    flip(duration) {
        if (this.isRunning) {
            return this;
        }
        if (duration !== undefined) {
            this.setDuration(duration);
        }
        this.start();
        return this;
    }

    updateGameObject(gameObject, timer) {
        if (timer.justRestart) {
            this.toggleFace();
        }

        var t = timer.t;
        if (timer.isOddIteration) {  // Yoyo
            t = 1 - t;
        }
        t = this.easeFn(t);

        var value = Linear$c(1, 0, t);
        if (this.orientation === 0) {
            gameObject.scaleX = value;
        } else {
            gameObject.scaleY = value;
        }
    }
}

const ORIENTATIONMODE$1 = {
    x: 0,
    horizontal: 0,
    y: 1,
    vertical: 1,
};

const FACEMODE = {
    front: 0,
    back: 1,
};

const Vector3 = Phaser.Math.Vector3;
const Matrix4 = Phaser.Math.Matrix4;

var tempPosition = new Vector3();
var tempRotation = new Vector3();
var tempMatrix = new Matrix4();

var TransformVerts = function (mesh, x, y, z, rotateX, rotateY, rotateZ) {
    if (x === undefined) { x = 0; }
    if (y === undefined) { y = 0; }
    if (z === undefined) { z = 0; }
    if (rotateX === undefined) { rotateX = 0; }
    if (rotateY === undefined) { rotateY = 0; }
    if (rotateZ === undefined) { rotateZ = 0; }

    tempPosition.set(x, y, z);
    tempRotation.set(rotateX, rotateY, rotateZ);
    tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, true);

    for (var i = 0, cnt = mesh.vertices.length; i < cnt; i++) {
        mesh.vertices[i].transformMat4(tempMatrix);
    }
};

const Mesh = Phaser.GameObjects.Mesh;
const IsPlainObject$s = Phaser.Utils.Objects.IsPlainObject;
const GetValue$2g = Phaser.Utils.Objects.GetValue;
const GenerateGridVerts = Phaser.Geom.Mesh.GenerateGridVerts;
const RadToDeg$5 = Phaser.Math.RadToDeg;
const DegToRad$8 = Phaser.Math.DegToRad;

const FOV = 45;
const PanZ = 1 + (1 / Math.sin(DegToRad$8(FOV)));

class Image$1 extends Mesh {
    constructor(scene, x, y, key, frame, config) {
        if (IsPlainObject$s(x)) {
            config = x;
            x = GetValue$2g(config, 'x', 0);
            y = GetValue$2g(config, 'y', 0);
            key = GetValue$2g(config, 'key', null);
            frame = GetValue$2g(config, 'frame', null);
        }

        super(scene, x, y, key, frame);
        this.type = 'rexPerspectiveImage';
        this.setSizeToFrame();

        this.resetPerspective();
        this.panZ(PanZ);
        this.hideCCW = GetValue$2g(config, 'hideCCW', true);

        var girdWidth = GetValue$2g(config, 'gridWidth', 32);
        var girdHeight = GetValue$2g(config, 'girdHeight', girdWidth);
        this.resetVerts(girdWidth, girdHeight);
    }

    resetPerspective() {
        this.setPerspective(this.width, this.height, FOV);
        return this;
    }

    resetVerts(girdWidth, girdHeight) {
        if (girdWidth !== undefined) {
            this.girdWidth = girdWidth;
        }
        if (girdHeight !== undefined) {
            this.girdHeight = girdHeight;
        }

        // Clear faces and vertices
        this.clear();
        this.dirtyCache[9] = -1;
        if ((this.width === 0) || (this.height === 0)) {
            return this;
        }

        // Generate faces and vertices
        var frameWidth = this.frame.cutWidth,
            frameHeight = this.frame.cutHeight;
        GenerateGridVerts({
            mesh: this,
            texture: this.texture.key, frame: this.frame.name,

            width: frameWidth / this.height,
            height: frameHeight / this.height,

            widthSegments: Math.ceil(frameWidth / this.girdWidth),
            heightSegments: Math.ceil(frameHeight / this.girdHeight),
            flipY: this.frame.source.isRenderTexture
        });

        return this;
    }

    syncSize() {
        this.setSizeToFrame();  // Reset size
        this.resetPerspective();  // Reset perspective
        this.resetVerts();  // Reset verts
        return this;
    }

    get rotationX() {
        return this.modelRotation.x;
    }

    set rotationX(value) {
        this.modelRotation.x = value;
    }

    get angleX() {
        return RadToDeg$5(this.rotationX);
    }

    set angleX(value) {
        this.rotationX = DegToRad$8(value);
    }

    get rotationY() {
        return this.modelRotation.y;
    }

    set rotationY(value) {
        this.modelRotation.y = value;
    }

    get angleY() {
        return RadToDeg$5(this.rotationY);
    }

    set angleY(value) {
        this.rotationY = DegToRad$8(value);
    }

    get rotationZ() {
        return this.modelRotation.z;
    }

    set rotationZ(value) {
        this.modelRotation.z = value;
    }

    get angleZ() {
        return RadToDeg$5(this.rotationZ);
    }

    set angleZ(value) {
        this.rotationZ = DegToRad$8(value);
    }

    transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
        TransformVerts(this, x, y, z, rotateX, rotateY, rotateZ);
        return this;
    }

    forceUpdate() {
        this.dirtyCache[10] = 1;
        return this;
    }
}

const RT = Phaser.GameObjects.RenderTexture;
const IsPlainObject$t = Phaser.Utils.Objects.IsPlainObject;
const GetValue$2h = Phaser.Utils.Objects.GetValue;

class RenderTexture$1 extends Image$1 {
    constructor(scene, x, y, width, height, config) {
        if (IsPlainObject$t(x)) {
            config = x;
            x = GetValue$2h(config, 'x', 0);
            y = GetValue$2h(config, 'y', 0);
            width = GetValue$2h(config, 'width', 32);
            height = GetValue$2h(config, 'height', 32);
        }

        // render-texture -> perspective-image
        var rt = (new RT(scene, x, y, width, height))
            .setOrigin(0.5);

        super(scene, x, y, rt.texture.key, null, config);
        this.type = 'rexPerspectiveRenderTexture';
        this.rt = rt;
    }

    destroy(fromScene) {
        super.destroy(fromScene);

        this.rt.destroy();
        this.rt = null;
    }
}

const AnimationState = Phaser.Animations.AnimationState;
const IsPlainObject$u = Phaser.Utils.Objects.IsPlainObject;
const GetValue$2i = Phaser.Utils.Objects.GetValue;

const RadToDeg$6 = Phaser.Math.RadToDeg;
const DegToRad$9 = Phaser.Math.DegToRad;

const IsPlainObject$v = Phaser.Utils.Objects.IsPlainObject;

const DegToRad$a = Phaser.Math.DegToRad;

const RAD180 = DegToRad$a(180);

const GetValue$2j = Phaser.Utils.Objects.GetValue;
const Linear$d = Phaser.Math.Linear;

const IsPlainObject$w = Phaser.Utils.Objects.IsPlainObject;
const GetValue$2k = Phaser.Utils.Objects.GetValue;

const GetValue$2l = Phaser.Utils.Objects.GetValue;
const RadToDeg$7 = Phaser.Math.RadToDeg;
const DegToRad$b = Phaser.Math.DegToRad;
const WrapDegrees$1 = Phaser.Math.Angle.WrapDegrees;
const ShortestBetween$1 = Phaser.Math.Angle.ShortestBetween;
const Wrap = Phaser.Math.Wrap;
const Linear$e = Phaser.Math.Linear;

const IsPlainObject$x = Phaser.Utils.Objects.IsPlainObject;
const GetValue$2m = Phaser.Utils.Objects.GetValue;
const DegToRad$c = Phaser.Math.DegToRad;
const RadToDeg$8 = Phaser.Math.RadToDeg;
const WrapDegrees$2 = Phaser.Math.Angle.WrapDegrees;
const Linear$f = Phaser.Math.Linear;
const Wrap$1 = Phaser.Math.Wrap;

const IsPlainObject$y = Phaser.Utils.Objects.IsPlainObject;
const GetValue$2n = Phaser.Utils.Objects.GetValue;
const Wrap$2 = Phaser.Math.Wrap;

const Rectangle$4 = Phaser.Geom.Rectangle;
const Union = Phaser.Geom.Rectangle.Union;

var GetBoundsOfGameObjects = function (gameObjects, out) {
    if (out === undefined) {
        out = new Rectangle$4();
    } else if (out === true) {
        if (globBounds === undefined) {
            globBounds = new Rectangle$4();
        }
        out = globBounds;
    }

    var gameObject;
    var firstClone = true;
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        gameObject = gameObjects[i];
        if (!gameObject.getBounds) {
            continue;
        }

        GOBounds = gameObject.getBounds(GOBounds);

        if (firstClone) {
            out.setTo(GOBounds.x, GOBounds.y, GOBounds.width, GOBounds.height);
            firstClone = false;
        } else {
            Union(GOBounds, out, out);
        }
    }

    return out;
};

var GOBounds, globBounds;

var GetValue$2o = Phaser.Utils.Objects.GetValue;

var Snapshot = function (config) {
    var gameObjects = config.gameObjects;
    var renderTexture = config.renderTexture;
    if (gameObjects.length === 0) {
        if (renderTexture) {
            renderTexture.setSize(1, 1).clear();
        }
        return renderTexture;
    }

    var x = GetValue$2o(config, 'x', undefined);
    var y = GetValue$2o(config, 'y', undefined);
    var width = GetValue$2o(config, 'width', undefined);
    var height = GetValue$2o(config, 'height', undefined);
    var originX = GetValue$2o(config, 'originX', 0);
    var originY = GetValue$2o(config, 'originY', 0);
    var scrollX, scrollY;
    if ((width === undefined) || (height === undefined) || (x === undefined) || (y === undefined)) {
        // Union bounds of gameObjects
        var bounds = GetBoundsOfGameObjects(gameObjects, true);
        var isCenterOrigin = (x !== undefined) && (y !== undefined);
        if (isCenterOrigin) {
            width = Math.max((x - bounds.left), (bounds.right - x)) * 2;
            height = Math.max((y - bounds.top), (bounds.bottom - y)) * 2;
            originX = 0.5;
            originY = 0.5;
        } else {
            x = bounds.x;
            y = bounds.y;
            width = bounds.width;
            height = bounds.height;
            originX = 0;
            originY = 0;
        }
        scrollX = bounds.x;
        scrollY = bounds.y;
    } else {
        scrollX = x + ((0 - originX) * width);
        scrollY = y + ((0 - originY) * height);
    }

    // Configurate render texture
    if (!renderTexture) {
        var scene = gameObjects[0].scene;
        renderTexture = scene.add.renderTexture(x, y, width, height);
    } else {
        renderTexture.setPosition(x, y);
        if ((renderTexture.width !== width) || (renderTexture.height !== height)) {
            renderTexture.setSize(width, height);
        }
    }
    renderTexture.setOrigin(originX, originY);
    renderTexture.camera.setScroll(scrollX, scrollY);

    // Draw gameObjects
    gameObjects = SortGameObjectsByDepth(Clone(gameObjects));
    renderTexture.draw(gameObjects);

    return renderTexture;
};

const ContainerAdd$2 = ContainerLite.prototype.add;
const GetValue$2p = Phaser.Utils.Objects.GetValue;

class ContainerPerspective extends RenderTexture$1 {
    constructor(parentContainer, config) {
        var scene = parentContainer.scene;
        super(scene, parentContainer.x, parentContainer.y, 1, 1, config);
        scene.add.existing(this);
        this.setVisible(false);

        ContainerAdd$2.call(parentContainer, this);
        this.visibleSibling = [];
        this.perspectiveState = false;
        this.useParentBounds = GetValue$2p(config, 'useParentBounds', false);

        this.boot();
    }

    boot() {
        this.rexContainer.parent.once('destroy', this.onParentDestroy, this);
    }

    destroy(fromScene) {
        if (!this.scene) {
            return;
        }

        this.exit();
        this.rexContainer.parent.off('destroy', this.onParentDestroy, this);
        super.destroy(fromScene);
    }

    onParentDestroy(parent, fromScene) {
        this.destroy(fromScene);
    }

    enter() {
        this.exit();

        var parentContainer = this.rexContainer.parent;

        // Get and paste all visible children, which dose not include this render texture
        Snapshot({
            gameObjects: parentContainer.getAllVisibleChildren(),
            renderTexture: this.rt,
            x: this.x,
            y: this.y,
            width: ((this.useParentBounds) ? parentContainer.displayWidth : undefined),
            height: ((this.useParentBounds) ? parentContainer.displayHeighth : undefined),
            originX: ((this.useParentBounds) ? parentContainer.originX : undefined),
            originY: ((this.useParentBounds) ? parentContainer.originY : undefined),
        });
        this.syncSize();

        // Set this renderTexture to be visible
        parentContainer.setChildVisible(this, true);

        // Set visible sibling to be invisible
        parentContainer.children.forEach(function (child) {
            if (child !== this) {
                parentContainer.setChildVisible(child, false);
                this.visibleSibling.push(child);
            }
        }, this);

        this.perspectiveState = true;
        return this;
    }

    exit() {
        var parentContainer = this.rexContainer.parent;

        // Set all visible children to be visible back
        this.visibleSibling.forEach(function (child) {
            parentContainer.setChildVisible(child, true);
        }, this);
        this.visibleSibling.length = 0;

        // Set this renderTexture to be invisible        
        parentContainer.setChildVisible(this, false);
        this.perspectiveState = false;
        return this;
    }
}

var Resize = function (width, height) {
    if (this.scene.scale.autoRound) {
        width = Math.floor(width);
        height = Math.floor(height);
    }

    if ((this.width === width) && (this.height === height)) {
        return this;
    }

    var style = this.node.style;
    style.width = `${width}px`;
    style.height = `${height}px`;
    this.updateSize();
    return this;
};

const GetValue$2q = Phaser.Utils.Objects.GetValue;

var SetProperties = function (properties, config, out) {
    if (out === undefined) {
        out = {};
    }

    var property, value;
    for (var key in properties) {
        property = properties[key];  // [propName, defaultValue]
        value = GetValue$2q(config, key, property[1]);
        if (value !== undefined) {
            out[property[0]] = value;
        }
    }

    return out;
};

var RouteEvents = function (gameObject, element, elementEvents) {
    for (let eventName in elementEvents) { // Note: Don't use `var` here
        element[elementEvents[eventName]] = function (e) {
            gameObject.emit(eventName, gameObject, e);
        };
    }
};

var StopPropagationTouchEvents = function (element) {
    // Don't propagate touch/mouse events to parent(game canvas)
    element.addEventListener('touchstart', callback, false);
    element.addEventListener('touchmove', callback, false);
    element.addEventListener('touchend', callback, false);
    element.addEventListener('mousedown', callback, false);
    element.addEventListener('mouseup', callback, false);
    element.addEventListener('mousemove', callback, false);
};

var callback = function (e) {
    e.stopPropagation();
};

const DOMElement = Phaser.GameObjects.DOMElement;
const IsPlainObject$z = Phaser.Utils.Objects.IsPlainObject;
const GetValue$2r = Phaser.Utils.Objects.GetValue;

class InputText extends DOMElement {
    constructor(scene, x, y, width, height, config) {
        if (IsPlainObject$z(x)) {
            config = x;
            x = GetValue$2r(config, 'x', 0);
            y = GetValue$2r(config, 'y', 0);
            width = GetValue$2r(config, 'width', 0);
            height = GetValue$2r(config, 'height', 0);
        } else if (IsPlainObject$z(width)) {
            config = width;
            width = GetValue$2r(config, 'width', 0);
            height = GetValue$2r(config, 'height', 0);
        }

        if (config === undefined) {
            config = {};
        }

        var element;
        var textType = GetValue$2r(config, 'type', 'text');
        if (textType === 'textarea') {
            element = document.createElement('textarea');
            element.style.resize = 'none';
        } else {
            element = document.createElement('input');
            element.type = textType;
        }

        SetProperties(ElementProperties, config, element);

        var style = GetValue$2r(config, 'style', undefined);
        style = SetProperties(StyleProperties, config, style);
        // Apply other style properties
        var elementStyle = element.style;
        for (var key in config) {
            if ((key in ElementProperties) || (key in StyleProperties)) {
                continue;
            } else if (key in elementStyle) {
                style[key] = config[key];
            }
        }
        style['box-sizing'] = 'border-box';
        super(scene, x, y, element, style);
        this.type = 'rexInputText';
        this.resize(width, height);

        // Apply events
        RouteEvents(this, element, ElementEvents);

        // Don't propagate touch/mouse events to parent(game canvas)
        StopPropagationTouchEvents(element);

        if (GetValue$2r(config, 'selectAll', false)) {
            this.selectAll();
        }
    }

    get text() {
        return this.node.value;
    }

    set text(value) {
        this.node.value = value;
    }

    setText(value) { // Override
        this.text = value;
        return this;
    }

    get maxLength() {
        return this.node.maxLength;
    }

    set maxLength(value) {
        this.node.maxLength = value;
    }

    setMaxLength(value) {
        this.maxLength = value;
        return this;
    }

    get minLength() {
        return this.node.minLength;
    }

    set minLength(value) {
        this.node.minLength = value;
    }

    setMinLength(value) {
        this.minLength = value;
        return this;
    }

    get placeholder() {
        return this.node.placeholder;
    }

    set placeholder(value) {
        this.node.placeholder = value;
    }

    setPlaceholder(value) {
        this.placeholder = value;
        return this;
    }

    selectText() {
        this.node.select();
        return this;
    }

    get tooltip() {
        return this.node.title;
    }

    set tooltip(value) {
        this.node.title = value;
    }

    setTooltip(value) {
        this.tooltip = value;
        return this;
    }

    setTextChangedCallback(callback) {
        this.onTextChanged = callback;
        return this;
    }

    get readOnly() {
        return this.node.readOnly;
    }

    set readOnly(value) {
        this.node.readOnly = value;
    }

    setReadOnly(value) {
        if (value === undefined) {
            value = true;
        }
        this.readOnly = value;
        return this;
    }

    get spellCheck() {
        return this.node.spellcheck;
    }

    set spellCheck(value) {
        this.node.spellcheck = value;
    }

    setSpellCheck(value) {
        this.spellCheck = value;
        return this;
    }

    get fontColor() {
        return this.node.style.color;
    }

    set fontColor(value) {
        this.node.style.color = value;
    }

    setFontColor(value) {
        this.fontColor = value;
        return this;
    }

    setStyle(key, value) {
        this.node.style[key] = value;
        return this;
    }

    getStyle(key) {
        return this.node.style[key];
    }

    scrollToBottom() {
        this.node.scrollTop = this.node.scrollHeight;
        return this;
    }

    setEnabled(enabled) {
        if (enabled === undefined) {
            enabled = true;
        }
        this.node.disabled = !enabled;
        return this;
    }

    setBlur() {
        this.node.blur();
        return this;
    }

    setFocus() {
        this.node.focus();
        return this;
    }

    selectAll() {
        this.node.select();
        return this;
    }
}

var methods$h = {
    resize: Resize
};

Object.assign(
    InputText.prototype,
    methods$h
);

const ElementProperties = {
    id: ['id', undefined],
    text: ['value', undefined],
    maxLength: ['maxLength', undefined],
    minLength: ['minLength', undefined],
    placeholder: ['placeholder', undefined],
    tooltip: ['title', undefined],
    readOnly: ['readOnly', false],
    spellCheck: ['spellcheck', false],
    autoComplete: ['autocomplete', 'off'],
};

const StyleProperties = {
    align: ['textAlign', undefined],
    paddingLeft: ['padding-left', undefined],
    paddingRight: ['padding-right', undefined],
    paddingTop: ['padding-top', undefined],
    paddingBottom: ['padding-bottom', undefined],
    fontFamily: ['fontFamily', undefined],
    fontSize: ['font-size', undefined],
    color: ['color', '#ffffff'],
    backgroundColor: ['backgroundColor', 'transparent'],
    border: ['border', 0],
    borderColor: ['borderColor', 'transparent'],
    outline: ['outline', 'none'],
    direction: ['direction', undefined]
};

const ElementEvents = {
    textchange: 'oninput',
    click: 'onclick',
    dblclick: 'ondblclick',
    focus: 'onfocus',
    blur: 'onblur',
};

const GetValue$2s = Phaser.Utils.Objects.GetValue;

var CreateInputText = function (text, config) {
    if (config === undefined) {
        config = {};
    }

    var scene = text.scene;
    var style = text.style;
    var backgroundColor = GetValue$2s(config, 'backgroundColor', style.backgroundColor);
    if (backgroundColor === null) {
        backgroundColor = 'transparent';
    }

    config.text = GetValue$2s(config, 'text', text.text);
    config.fontFamily = GetValue$2s(config, 'fontFamily', style.fontFamily);
    config.fontSize = GetValue$2s(config, 'fontSize', style.fontSize);
    config.color = GetValue$2s(config, 'color', style.color);
    config.backgroundColor = backgroundColor;
    config.direction = GetValue$2s(config, 'rtl', style.rtl) ? 'rtl' : 'ltr';
    config.align = GetValue$2s(config, 'align', GetHAlign(style));

    // Built-in text game object with RTL only has 'right' align
    if ((config.direction === 'rtl') && (IsTextGameObject(text))) {
        config.align = 'right';
    }

    // config.paddingLeft = 0;
    // config.paddingRight = 0;
    // config.paddingTop = 0;
    // config.paddingBottom = 0;
    // var valign = GetVAlign(style);
    // switch (valign) {
    //     case 'top':
    //         break;
    //     case 'bottom':
    //         break;
    // }

    var inputText = new InputText(scene,
        text.x, text.y,
        GetValue$2s(config, 'width', text.width),
        GetValue$2s(config, 'height', text.height),
        config
    );
    inputText.setOrigin(text.originX, text.originY);
    scene.add.existing(inputText);
    return inputText;
};

var GetHAlign = function (style) {
    if (style.hasOwnProperty('align')) {
        return style.align;
    } else if (style.hasOwnProperty('halign')) {
        return style.halign;
    } else {
        return 'left';
    }
};

const GetValue$2t = Phaser.Utils.Objects.GetValue;

var LastOpenedEditor = undefined;

class TextEdit extends ComponentBase {
    constructor(gameObject) {
        // No event emitter
        super(gameObject, { eventEmitter: false });
        // this.parent = gameObject;

        this.inputText = undefined;
        this.onClose = undefined;
        this.delayCall = undefined;
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        this.close();
        if (LastOpenedEditor === this) {
            LastOpenedEditor = undefined;
        }

        super.shutdown(fromScene);
    }

    open(config, onCloseCallback) {
        if (LastOpenedEditor !== undefined) {
            LastOpenedEditor.close();
        }

        LastOpenedEditor = this;
        if (IsFunction(config)) {
            onCloseCallback = config;
            config = undefined;
        }
        if (onCloseCallback === undefined) {
            onCloseCallback = GetValue$2t(config, 'onClose', undefined);
        }

        var onOpenCallback = GetValue$2t(config, 'onOpen', undefined);
        var customOnTextChanged = GetValue$2t(config, 'onTextChanged', undefined);

        this.inputText = CreateInputText(this.parent, config)
            .on('textchange', function (inputText) {
                var text = inputText.text;
                if (customOnTextChanged) { // Custom on-text-changed callback
                    customOnTextChanged(this.parent, text);
                } else { // Default on-text-changed callback
                    this.parent.text = text;
                }
            }, this)
            .setFocus();
        this.parent.setVisible(false); // Set parent text invisible

        // Attach close event
        this.onClose = onCloseCallback;
        if (GetValue$2t(config, 'enterClose', true)) {
            this.scene.input.keyboard.once('keydown-ENTER', this.close, this);
        }
        // Attach pointerdown (outside of input-text) event, at next tick
        this.delayCall = this.scene.time.delayedCall(0, function () {
            this.scene.input.once('pointerdown', this.close, this);

            // Open editor completly, invoke onOpenCallback
            if (onOpenCallback) {
                onOpenCallback(this.parent);
            }

        }, [], this);

        return this;
    }

    close() {
        LastOpenedEditor = undefined;
        if (!this.inputText) {
            return this;
        }

        this.parent.setVisible(true); // Set parent text visible

        this.inputText.destroy();
        this.inputText = undefined;
        if (this.delayCall) {
            this.delayCall.remove();
            this.delayCall = undefined;
        }

        // Remove close event
        this.scene.input.keyboard.off('keydown-ENTER', this.close, this);
        this.scene.input.off('pointerdown', this.close, this);

        if (this.onClose) {
            this.onClose(this.parent);
        }
        return this;
    }

    get isOpened() {
        return (this.inputText !== undefined);
    }

    get text() {
        return (this.isOpened) ? this.inputText.text : this.parent.text;
    }
}

var Edit = function (gameObject, config, onCloseCallback) {
    if (!gameObject._edit) {
        gameObject._edit = new TextEdit(gameObject);
    }
    gameObject._edit.open(config, onCloseCallback);
    return gameObject._edit;
};

var TextRunWidthWrap = function (textObject) {
    var RunWidthWrap = function (width) {
        var padding = textObject.padding;
        var wrapWidth = width - padding.left - padding.right;
        var style = textObject.style;
        if (IsTextGameObject(textObject)) {
            style.wordWrapWidth = wrapWidth;
            style.maxLines = 0;
        } else {  // BBCode text, Tag text
            if (style.wrapMode === 0) { // Turn no-wrap to word-wrap
                style.wrapMode = 1;
            }
            style.wrapWidth = wrapWidth;
            style.maxLines = 0;
        }

        textObject.setFixedSize(width, 0);  // Redraw text
        return textObject;
    };
    return RunWidthWrap;
};

var DynamicTextRunWidthWrap = function (textObject) {
    var RunWidthWrap = function (width) {
        textObject
            .setFixedSize(width, 0)
            .runWordWrap();
        return textObject;
    };
    return RunWidthWrap;
};

var BitmapTextRunWidthWrap = function (textObject) {
    var RunWidthWrap = function (width) {
        textObject.setMaxWidth(width);
        return textObject;
    };
    return RunWidthWrap;
};

var IsDynamicTextGameObject = function (gameObject) {
    return (gameObject instanceof DynamicText);
};

var WrapExpandText = function (textObject, minWidth) {
    if (minWidth === undefined) {
        minWidth = 0;
    }

    textObject._minWidth = minWidth;

    textObject.runWidthWrap =
        IsDynamicTextGameObject(textObject) ? DynamicTextRunWidthWrap(textObject) :
            IsBitmapTextGameObject(textObject) ? BitmapTextRunWidthWrap(textObject) :
                TextRunWidthWrap(textObject);

    return textObject;
};

var CreateCover = function (gameObject, config) {
    var scene = gameObject.scene;
    var cover = new Cover(scene, config);
    scene.add.existing(cover);

    // Put cover behind game object
    if (gameObject.isRexContainerLite) {
        gameObject.moveDepthBelow(cover);
    } else {
        scene.children.moveBelow(cover, gameObject);
    }
    return cover;
};

var DefaultTransitCallbacks$1 = {
    popUp: function (gameObject, duration) {
        PopUp(gameObject, duration);
    },

    scaleDown: function (gameObject, duration) {
        // Don't destroy here
        ScaleDownDestroy(gameObject, duration, undefined, undefined, false);
    },

    fadeIn: function (gameObject, duration) {
        FadeIn$1(gameObject, duration);
    },

    fadeOut: function (gameObject, duration) {
        // Don't destroy here
        FadeOutDestroy(gameObject, duration, false);
    },
};

class State$1 extends FSM {
    constructor(parent, config) {
        super(config);
        this.parent = parent;
        this.init();
    }

    init() {
        this.start('IDLE');
    }

    // IDLE -> TRANS_OPNE
    next_IDLE() {
        return 'TRANS_OPNE';
    }
    // IDLE

    // TRANS_OPNE -> OPEN
    next_TRANS_OPNE() {
        return 'OPEN';
    }
    enter_TRANS_OPNE() {
        var modalBehavior = this.parent;
        modalBehavior.transitionIn();
        modalBehavior.delayCall(modalBehavior.transitInTime, this.next, this);
    }
    exit_TRANS_OPNE() {
        var modalBehavior = this.parent;
        modalBehavior.removeDelayCall();
    }
    // TRANS_OPNE

    // OPEN -> TRANS_CLOSE    
    next_OPEN() {
        return 'TRANS_CLOSE';
    }
    enter_OPEN() {
        var modalBehavior = this.parent;
        var duration = modalBehavior.displayTime;
        if (duration >= 0) {
            modalBehavior.delayCall(
                duration,
                modalBehavior.requestClose, // callback
                modalBehavior               // scope
            );
        }
        modalBehavior.onOpen();
    }
    exit_OPEN() {
        var modalBehavior = this.parent;
        modalBehavior.removeDelayCall();
    }
    // OPEN

    // TRANS_CLOSE -> CLOSE
    next_TRANS_CLOSE() {
        return 'CLOSE';
    }
    enter_TRANS_CLOSE() {
        var modalBehavior = this.parent;
        modalBehavior.transitionOut();
        modalBehavior.delayCall(modalBehavior.transitOutTime, this.next, this);
    }
    exit_TRANS_CLOSE() {
        var modalBehavior = this.parent;
        modalBehavior.removeDelayCall();
    }
    // TRANS_CLOSE

    // CLOSE
    next_CLOSE() {
    }
    enter_CLOSE() {
        var modalBehavior = this.parent;
        modalBehavior.onClose();
    }
    exit_CLOSE() {
    }
    // CLOSE
}

const GetValue$2u = Phaser.Utils.Objects.GetValue;
const Timer$2 = Phaser.Time.TimerEvent;

class Modal extends ComponentBase {
    constructor(gameObject, config) {
        super(gameObject, config);
        // this.parent = gameObject;
        // this.scene

        // Cover : key of modal, to block touch input        
        var coverConfig = GetValue$2u(config, 'cover');
        this.cover = (coverConfig !== false) ? CreateCover(gameObject, coverConfig) : undefined;

        // Close conditions:
        // OK/Cancel buttons, invoke modal.requestClose()
        var manualClose = GetValue$2u(config, 'manualClose', true);
        // Timeout/any-touch
        if (!manualClose) {
            this.setDisplayTime(GetValue$2u(config, 'duration.hold', 2000));
            var anyTouchClose = GetValue$2u(config, 'anyTouchClose', true);
            if (anyTouchClose) {
                this.anyTouchClose();
            }
        } else {
            this.setDisplayTime(-1);
        }

        this.setTransitInTime(GetValue$2u(config, 'duration.in', 200));
        this.setTransitOutTime(GetValue$2u(config, 'duration.out', 200));
        this.setTransitInCallback(GetValue$2u(config, 'transitIn', TransitionMode$1.popUp));
        this.setTransitOutCallback(GetValue$2u(config, 'transitOut', TransitionMode$1.scaleDown));
        this.destroyParent = GetValue$2u(config, 'destroy', true);

        this.timer = new Timer$2();
        this._state = new State$1(this, { eventEmitter: false });
        this.closeEventData = undefined;

        // Start
        this._state.next();
    }

    get state() {
        return this._state.state;
    }

    shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
            return;
        }

        // Registered in anyTouchClose()
        if (!this.cover) {
            this.scene.input.off('pointerup', this.requestClose, this);
        }

        if (this.cover && !fromScene) {
            this.cover.destroy();
            this.cover = undefined;
        }

        this.transitInCallback = undefined;
        this.transitOutCallback = undefined;
        this.closeEventData = undefined;

        this.removeDelayCall();

        super.shutdown(fromScene);
    }

    anyTouchClose() {
        if (this.cover) {
            this.cover.once('pointerup', this.requestClose, this);
        } else {
            this.scene.input.once('pointerup', this.requestClose, this);
        }
        return this;
    }

    transitionIn() {
        var duration = this.transitInTime;
        if (this.transitInCallback) {
            this.transitInCallback(this.parent, duration);
        }

        var cover = this.cover;
        if (cover) {
            FadeIn$1(cover, duration, cover.alpha);
        }

        return this;
    }

    transitionOut() {
        var duration = this.transitOutTime;
        if (this.transitOutCallback) {
            this.transitOutCallback(this.parent, duration);
        }

        var cover = this.cover;
        if (cover) {
            FadeOutDestroy(cover, duration, false);
        }

        return this;
    }

    onOpen() {
        this.emit('open', this.parent, this);
    }

    onClose() {
        this.emit('close', this.closeEventData);

        if (this.destroyParent) {
            this.parent.destroy();
            // Will invoke `this.destroy()`
        } else {
            this.destroy();
        }
    }

    delayCall(delay, callback, scope, args) {
        this.timer = this.scene.time.delayedCall(delay, callback, args, scope);
        return this;
    }

    removeDelayCall() {
        if (this.timer) {
            this.timer.remove(false);
            this.timer = undefined;
        }
        return this;
    }

    setTransitInTime(time) {
        this.transitInTime = time;
        return this;
    }

    setDisplayTime(time) {
        this.displayTime = time;
        return this;
    }

    setTransitOutTime(time) {
        this.transitOutTime = time;
        return this;
    }

    setTransitInCallback(callback) {
        if (typeof (callback) === 'string') {
            callback = TransitionMode$1[callback];
        }

        switch (callback) {
            case TransitionMode$1.popUp:
                callback = DefaultTransitCallbacks$1.popUp;
                break;
            case TransitionMode$1.fadeIn:
                callback = DefaultTransitCallbacks$1.fadeIn;
                break;
        }

        this.transitInCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
    }

    setTransitOutCallback(callback) {
        if (typeof (callback) === 'string') {
            callback = TransitionMode$1[callback];
        }

        switch (callback) {
            case TransitionMode$1.scaleDown:
                callback = DefaultTransitCallbacks$1.scaleDown;
                break;
            case TransitionMode$1.fadeOut:
                callback = DefaultTransitCallbacks$1.fadeOut;
                break;
        }

        this.transitOutCallback = callback;
        // callback = function(gameObject, duration) {}
        return this;
    }

    requestClose(closeEventData) {
        // Only can close modal in OPEN state
        if (this._state.state === 'OPEN') {
            this.closeEventData = (arguments.length > 0) ? closeEventData : this.parent;
            this._state.next(); // OPEN -> TRANS_CLOSE 
        }
        return this;
    }
}

const TransitionMode$1 = {
    popUp: 0,
    fadeIn: 1,
    scaleDown: 0,
    fadeOut: 1,
};

var Modal$1 = function (gameObject, config) {
    var modalBehavior = new Modal(gameObject, config);

    // Route modal's 'open', 'close' event
    modalBehavior.on('open', function () {
        gameObject.emit('modal.open', modalBehavior);
    });
    modalBehavior.on('close', function (closeEventData) {
        gameObject.emit('modal.close', closeEventData, modalBehavior);
    });

    // Reigster 'modal.requestClose' event for invoking modalBehavior.requestClose() method
    gameObject.on('modal.requestClose', modalBehavior.requestClose, modalBehavior);
    modalBehavior.on('close', function () {
        gameObject.off('modal.requestClose', modalBehavior.requestClose, modalBehavior);
    });

    return modalBehavior;
};

var ModalPromise = function (gameObject, config) {
    var modalBehavior = Modal$1(gameObject, config);
    return new Promise(function (resolve, reject) {
        modalBehavior.once('close', function (closeEventData) {
            resolve(closeEventData);
        });
    });
};

var PointToChild$1 = function (parents, x, y) {
    var parent;
    for (var i = 0, cnt = parents.length; i < cnt; i++) {
        parent = parents[i];
        if (!ContainsPoint(parent, x, y)) {
            continue;
        }

        return parent.pointToChild(x, y);
    }
    return null;
};

var EmitChildEvent = function (eventEmitter, eventName, parents, x, y, pointer) {
    var child;
    if (y === undefined) {
        child = x;
    } else {
        child = PointToChild$1(parents, x, y);
    }

    if (!child) {
        return;
    }

    eventEmitter.emit(eventName, child, pointer);
};

const GetValue$2v = Phaser.Utils.Objects.GetValue;

var ClickChild = function (config) {
    var clickConfig = GetValue$2v(config, 'click', undefined);
    if (clickConfig === false) {
        return;
    }

    if (clickConfig === undefined) {
        clickConfig = {};
    }
    if (!clickConfig.hasOwnProperty('threshold')) {
        clickConfig.threshold = 10;
    }

    this._click = new Button(this, clickConfig);
    this._click.on('click', function (button, gameObject, pointer) {
        EmitChildEvent(
            this.eventEmitter,
            `${this.input.eventNamePrefix}click`,
            this.input.targetSizers,
            pointer.x, pointer.y,
            pointer
        );
    }, this);
};

const GetValue$2w = Phaser.Utils.Objects.GetValue;

var OverChild = function (config) {
    var overConfig = GetValue$2w(config, 'over', undefined);
    if (overConfig === false) {
        return;
    }

    this
        .on('pointermove', OnMove$1, this)
        .on('pointerover', OnMove$1, this)
        .on('pointerout', OnOut$1, this);  // pointer-up is included too
};

var OnMove$1 = function (pointer) {
    var child = PointToChild$1(this.input.targetSizers, pointer.x, pointer.y);
    var preChild = this.input.lastOverChild;
    if (child && preChild &&
        (child === preChild)) {
        return;
    }

    this.input.lastOverChild = child;
    EmitChildEvent(
        this.eventEmitter,
        `${this.input.eventNamePrefix}out`,
        this.input.targetSizers,
        preChild, undefined,
        pointer
    );
    EmitChildEvent(
        this.eventEmitter,
        `${this.input.eventNamePrefix}over`,
        this.input.targetSizers,
        child, undefined,
        pointer
    );
};

var OnOut$1 = function (pointer) {
    var child = this.input.lastOverChild;
    this.input.lastOverChild = null;
    EmitChildEvent(
        this.eventEmitter,
        `${this.input.eventNamePrefix}out`,
        this.input.targetSizers,
        child, undefined,
        pointer
    );
};

const GetValue$2x = Phaser.Utils.Objects.GetValue;

var TapChild = function (config) {
    var tapConfig = GetValue$2x(config, 'tap', undefined);
    if (tapConfig === false) {
        return;
    }

    this._tap = new Tap(this, tapConfig);
    this._tap
        .on('tap', function (tap, gameObject, lastPointer) {
            EmitChildEvent(
                this.eventEmitter,
                `${this.input.eventNamePrefix}${tap.tapsCount}tap`,
                this.input.targetSizers,
                tap.x, tap.y,
                lastPointer
            );
        }, this);
};

const GetValue$2y = Phaser.Utils.Objects.GetValue;

var PressChild = function (config) {
    var pressConfig = GetValue$2y(config, 'press', undefined);
    if (pressConfig === false) {
        return;
    }

    this._press = new Press(this, pressConfig);
    this._press
        .on('pressstart', function (press, gameObject, lastPointer) {
            EmitChildEvent(
                this.eventEmitter,
                `${this.input.eventNamePrefix}pressstart`,
                this.input.targetSizers,
                press.x, press.y,
                lastPointer
            );
        }, this)
        .on('pressend', function (press, gameObject, lastPointer) {
            EmitChildEvent(
                this.eventEmitter,
                `${this.input.eventNamePrefix}pressend`,
                this.input.targetSizers,
                press.x, press.y,
                lastPointer
            );
        }, this);
};

const GetValue$2z = Phaser.Utils.Objects.GetValue;

var SwipeChild = function (config) {
    var swipeConfig = GetValue$2z(config, 'swipe', undefined);
    if (swipeConfig === false) {
        return;
    }

    if (swipeConfig === undefined) {
        swipeConfig = {};
    }
    swipeConfig.dir = '4dir';
    this._swipe = new Swipe(this, swipeConfig);
    this._swipe
        .on('swipe', function (swipe, gameObject, lastPointer) {
            var dirName =
                (swipe.left) ? 'left' :
                    (swipe.right) ? 'right' :
                        (swipe.up) ? 'up' :
                            'down';
            EmitChildEvent(
                this.eventEmitter,
                `${this.input.eventNamePrefix}swipe${dirName}`,
                this.input.targetSizers,
                swipe.x, swipe.y,
                lastPointer
            );
        }, this);
};

const GetValue$2A = Phaser.Utils.Objects.GetValue;

var SetChildrenInteractive = function (gameObject, config) {
    gameObject.setInteractive();

    gameObject.eventEmitter = GetValue$2A(config, 'eventEmitter', gameObject);
    gameObject.input.targetSizers = GetValue$2A(config, 'targets', [gameObject]);
    gameObject.input.eventNamePrefix = GetValue$2A(config, 'inputEventPrefix', 'child.');

    ClickChild.call(gameObject, config);
    OverChild.call(gameObject, config);
    TapChild.call(gameObject, config);
    PressChild.call(gameObject, config);
    SwipeChild.call(gameObject, config);

    return gameObject;
};

export { Anchor, BBCodeText, Badge as BadgeLabel, Buttons, Canvas, Chart$1 as Chart, CircleMaskImage, CircularProgress$1 as CircularProgress, CircularProgress as CircularProgressCanvas, Button as Click, ContainerLite as Container, Cover, CustomProgress, CustomShapes, Dialog, DynamicText, EaseMove, EaseMoveFrom, EaseMoveTo, Edit, Fade$1 as Fade, FadeIn$1 as FadeIn, FadeOutDestroy, Buttons$1 as FixWidthButtons, FixWidthSizer, Flip, FullWindowRectangle, GetParent as GetParentSizer, GetTopmostParent as GetTopmostSizer, GetViewport, GridButtons, GridSizer, GridTable$1 as GridTable, Hide, IsPointerInBounds, IsShown, Knob, Label, Menu, Modal$1 as Modal, ModalPromise, NinePatch, NumberBar, OverlapSizer, Pages, Pan, ContainerPerspective as Perspective, Pinch, Press, Rotate$1 as Rotate, RoundRectangle$1 as RoundRectangle, RoundRectangle$2 as RoundRectangleCanvas, ScrollablePanel, SetChildrenInteractive, Show, Sides, Sizer, Slider, Space, Swipe, Tabs, TagText, Tap, TextArea, TextBox, TextPlayer, Toast, TouchEventStop, TransitionImage, WaitComplete, WaitEvent, WrapExpandText };
